{"title":"Bagaimana cara menutup jendela dengan pegangannya?","draft":false,"url":"/bagaimana-cara-menutup-jendela-dengan-pegangannya-al2bpzlg","votes":"4","answers_count":"6","categories":["Komputer"],"tags":["windows","window"],"snippet":"Adakah yang tahu tentang aplikasi yang akan menutup jendela karena pegangannya? Baris perintah bagus.  Perhatikan, saya tidak ingin mematikan aplikasi terkait, melainkan jendela modal yang dimiliki oleh aplikasi itu.  Alasan:  Terkadang, dialog...","body":"<p> Adakah yang tahu tentang aplikasi yang akan menutup jendela karena pegangannya? Baris perintah bagus. </p>\n\n<p> Perhatikan, saya tidak ingin mematikan aplikasi terkait, melainkan jendela modal yang dimiliki oleh aplikasi itu. </p>\n\n<p><strong> Alasan: </strong></p>\n\n<p> Terkadang, dialog modal dibuka di bawah jendela utama di laptop saya. Ini terjadi tidak hanya sekali untuk VS dan Firefox. Sangat menyebalkan. </p>\n\n<p> Saya dapat menemukan jendela dengan Spy ++, tetapi tidak dapat membunuhnya. </p>\n\n<p><strong> EDIT: </strong></p>\n\n<p> Aplikasi yang memungkinkan untuk mengirim pesan ke jendela sembarang juga bagus, saya kira saya kemudian dapat mengirim sesuatu seperti WM_CLOSE atau apa pun. </p>\n\n<p><strong> EDIT: </strong></p>\n\n<p> Saya ingin menekankan, bahwa saya tidak tertarik untuk menutup jendela yang terlihat. Intinya adalah untuk menangani ketidaknormalan yang buruk ketika dialog modal terbuka di bawah jendela pemilik, yang memang terjadi dan tidak hanya sekali bagi saya saat bekerja dengan VS dan Firefox. Jadi, solusi yang diinginkan adalah menutup jendela dengan pegangannya atau, jika secara khusus dapat menemukan jendela yang dikaburkan dan menampilkannya. </p>","source":"https://superuser.com/questions/31733/how-can-i-close-windows-by-their-handle","author":"<a href=\"https://superuser.com/users/9089/mark\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">mark</span></a>","replies":[{"reply":"Alt-Tab biasanya membawa dialog modal kembali ke atas.","author":"<a href=\"https://superuser.com/users/6394/remus-rusanu\" target=\"_blank\" rel=\"nofollow noopener\">Remus Rusanu</a>"},{"reply":"Tidak dalam skenario saya. Ini hanya melakukannya jika dialog modal terbuka dengan gaya jendela tertentu (tidak ingat persis) yang membuat dialog muncul di bilah tugas.","author":"User"}],"answers":[{"answer":"<p> Oke, saya membuat aplikasi kecil yang berhasil. </p>\n\n<p><img src=\"https://i.stack.imgur.com/U1VnH.png\" alt=\"Screenshot\" class=\"img-fluid d-block my-2\" loading=\"lazy\"></p>\n\n<p> Anda bisa mendownloadnya <a href=\"http://www.xs4all.nl/~niff/stuff/CloseWindow.exe\" rel=\"nofollow noopener\" target=\"_blank\"> sini </a> . </p>\n\n<p> Pemakaian: </p>\n\n<ol>\n<li> Mulai programnya </li>\n<li> Arahkan mouse Anda ke jendela yang ingin Anda tutup (jangan klik di atasnya) </li>\n<li> Tekan hapus. </li>\n</ol>\n\n<p> Ini mengirimkan wm_close ke jendela di bawah kursor mouse. </p>\n\n<p> Delphi kode di bawah ini ... </p> <pre><code>unit uCloseWindow;\n\ninterface\n\nuses\n  Windows, Forms, Messages, SysUtils, Variants, Classes, Controls;\n\ntype\n  TfrmMain = class(TForm)\n    procedure FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);\n  public\n  end;\n\nvar\n  frmMain: TfrmMain;\n\nimplementation\n\n{$R *.dfm}\n\nprocedure TfrmMain.FormKeyDown(Sender: TObject; var Key: Word;\n  Shift: TShiftState);\nvar\n  HandleUnderCursor:HWND;\nbegin\n  if Key=VK_DELETE then\n  begin\n    HandleUnderCursor := WindowFromPoint(Mouse.CursorPos);\n    SendMessage(HandleUnderCursor,WM_CLOSE,0,0)\n  end;\nend;\n\nend.\n</code></pre>","votes":"5","source":"https://superuser.com/a/31735","author":"<a href=\"https://superuser.com/users/9612/wouter-van-nifterick\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Wouter van Nifterick</span></a>","replies":[{"reply":"Tidak baik. Seperti yang saya katakan, jendela itu tersembunyi di balik jendela lain. Seluruh tujuan itu menangani kasus-kasus jelek ini.","author":"User"},{"reply":"Lihat EDIT kedua di posting saya.","author":"User"},{"reply":"Tidak, Anda mengatakan itu &quot;di bawah&quot; jendela lain (menyiratkan posisi y), dan Anda tidak menyebutkan bahwa jendela itu tidak terlihat. Anda tidak sopan untuk tidak memberikan suara negatif setelah upaya yang saya lakukan untuk membantu Anda.","author":"User"},{"reply":"Setelah dipikir-pikir, Anda benar. Saya seharusnya menjelaskan diri saya lebih baik. Anda dapat menolak pertanyaan saya sebagai balasannya, karena tidak adanya kejelasan di dalamnya, saya layak menerimanya dengan adil.","author":"User"},{"reply":"Tidak ada alasan untuk meremehkan jawaban ini. Ini valid <i> pemrograman </i> jawaban atas pertanyaan yang tidak terlalu terkait dengan pemrograman. Downvoting timbal balik hampir tidak produktif.","author":"<a href=\"https://superuser.com/users/2077/sinan-%c3%9cn%c3%bcr\" target=\"_blank\" rel=\"nofollow noopener\">Sinan &#xDC;n&#xFC;r</a>"}]},{"answer":"<p> Saya menganggap ini sebagai alasan untuk mencoba Win32API untuk Ruby. </p> <pre><code>require 'Win32API'\n\nWM_CLOSE = 0x0010\nFindWindow = Win32API.new('user32', 'FindWindow', [\"P\", \"P\"], \"L\")\nSendMessage = Win32API.new('user32', 'SendMessage', [\"L\", \"L\", \"P\", \"P\"], \"L\")\n\ndef Send_WM_CLOSE(title)\n  handle = FindWindow.call(nil, title)\n  SendMessage.call(handle, WM_CLOSE, nil, nil) if handle != 0\nend\n\nif ARGV[0].to_i==0\n  title=String.new(ARGV[0])\n  Send_WM_CLOSE(title)\nelse\n  SendMessage.call(ARGV[0].to_i, WM_CLOSE, nil, nil)\nend\n</code></pre> <p> Dengan menggunakan ini, Anda dapat menutup notepad baru dengan </p> <pre><code>&gt; ruby closewindow.rb \"Untitled - Notepad\"\n</code></pre> <p> atau jika Anda tahu pegangannya </p> <pre><code>&gt; ruby closewindow.rb 15794730\n</code></pre>","votes":"3","source":"https://superuser.com/a/31734","author":"<a href=\"https://superuser.com/users/6724/jonas-elfstr%c3%b6m\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Jonas Elfstr&#246;m</span></a>","replies":[{"reply":"Bagus, tapi saya tidak akan memasang ruby ​​untuk itu :-)","author":"User"},{"reply":"Ada penginstal sekali klik, jika Anda berubah pikiran. <a href=\"http://rubyforge.org/projects/rubyinstaller/\" rel=\"nofollow noopener\" target=\"_blank\"> rubyforge.org/projects/rubyinstaller </a>","author":"<a href=\"https://superuser.com/users/6724/jonas-elfstr%c3%b6m\" target=\"_blank\" rel=\"nofollow noopener\">Jonas Elfstr&#xF6;m</a>"}]},{"answer":"<p> Berikut ini skrip Perl untuk melakukannya: </p> <pre><code>#!/usr/bin/perl\n\nuse strict;\nuse warnings;\n\nuse Win32::GuiTest qw(FindWindowLike SendKeys SetForegroundWindow);\n\ndie \"Need pattern to match against window titles\\n\" unless @ARGV;\nmy ($windowtitle) = @ARGV;\n\nmy ($myhandle) = FindWindowLike(0, qr/winclose\\.pl/);\n\nmy @windows = FindWindowLike(0, qr/\\Q$windowtitle\\E/i);\n\nfor my $handle ( @windows ) {\n    next if $handle == $myhandle;\n    SetForegroundWindow($handle);\n    SendKeys(\"%{F4}\");\n}\n</code></pre> <p> Dan berikut adalah beberapa hiburan menggunakan skrip seperti itu (tolong jangan anggap spam ini, saya hanya mencoba mengilustrasikan penggunaan Perl&#39;s <a href=\"http://search.cpan.org/perldoc/Win32::GuiTest\" rel=\"nofollow noopener\" target=\"_blank\"> Win32 :: GuiTest </a> : <a href=\"http://www.youtube.com/watch?v=BAg7K_uwNZs\" rel=\"nofollow noopener\" target=\"_blank\"> http://www.youtube.com/watch?v=BAg7K_uwNZs </a></p>","votes":"1","source":"https://superuser.com/a/31736","author":"<a href=\"https://superuser.com/users/2077/sinan-%c3%9cn%c3%bcr\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Sinan &#220;n&#252;r</span></a>","replies":[{"reply":"Imut. Tapi saya tidak ingin memasang perl hanya untuk ini.","author":"User"}]},{"answer":"<p> Ini akan sangat sederhana untuk memasak sendiri. Saya melihat Anda telah menolak Perl. Apa bahasa kesukaanmu </p>\n\n<p> Berikut adalah contoh C sederhana (tidak diuji, keluar dari memori): </p> <pre><code>#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){\n    HWND hWnd;\n\n    if(!sscanf(lpCmdLine, \"%i\", &amp;hWnd)){\n        MessageBox(null, \"Invalid argument\", \"Close Window\", MB_OK | MB_ICONERROR);\n        return 1;\n    }\n\n    PostMessage(hWnd, WM_CLOSE, 0, 0);\n}\n</code></pre> <p> Ini adalah contoh C # sederhana (sekali lagi, tidak diuji): </p> <pre><code>using System;\nusing System.Runtime.Interop;\n\nstatic class Program{\n    [DllImport(\"user32.dll\", CharSet=CharSet.Auto)]\n    static extern int PostMessage(int hWnd, int msg, int wParam, int lParam);\n\n    const int WM_CLOSE = 16;\n\n    static void Main(string[] args){\n        int hWnd;\n        if(args.Length == 1 &amp;&amp; int.TryParse(args[0], out hWnd))\n            PostMessage(hWnd, WM_CLOSE, 0, 0);\n        else MessageBox.Show(\"Invalid Argument\", \"CloseWindow\", MessageBoxButtons.OK, MessageBoxIcon.Error);\n    }\n}\n</code></pre>","votes":"1","source":"https://superuser.com/a/31737","author":"<a href=\"https://superuser.com/users/20746/p-daddy\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">P Daddy</span></a>","replies":[{"reply":"Kamu benar. Saya bertanya-tanya apakah ada solusi yang lebih ramah pengguna. Meskipun, saya telah menyebutkan baris perintah sederhana sudah cukup baik, biasanya orang mengharapkan beberapa UI bagus yang memungkinkan Anda memilih jendela, memberi tahu Anda semua jenis info tentangnya, dll ... Sampai sekarang, saya masih harus memasangkannya dengan Spy ++ . Tapi Anda benar.","author":"User"},{"reply":"Membuatnya menjadi GUI tidak membutuhkan banyak waktu, kecuali investasi kecil dalam waktu. Perilaku drag-a-target-and-highlight-a-window dari Spy ++ cukup mudah untuk diduplikasi dengan ikon dan kursor yang sesuai. Penyorotan jendela mudah dilakukan dengan fungsi WinAPI <code>GetWindowRgn</code> dan <code>FrameRgn</code>. Ada fungsi API lain yang akan memberi Anda info apa pun tentang jendela yang Anda cari. Dan <code>SetWindowPos</code> dapat digunakan untuk membawa dialog target ke atas urutan Z sehingga Anda dapat melihatnya dan berinteraksi dengannya, bukan hanya menutupnya.","author":"User"},{"reply":"Semuanya mudah dan semuanya butuh waktu yang tidak kita miliki. Mengapa menciptakan roda jika mungkin sudah ditemukan? Saya tahu cara kerjanya, Anda mengembangkan utilitas yang sedikit bagus untuk penggunaan sendiri, lalu Anda memperpanjangnya, lalu men-debugnya untuk memperbaiki bug dan orang dengan mudah menemukan dirinya membuang-buang waktu beberapa hari untuk sesuatu yang sudah dilakukan dan diuji oleh orang lain.","author":"User"},{"reply":"Anda punya poin yang bagus. Tetapi di sisi lain, dalam kasus seperti ini, saya yakin lebih banyak waktu mungkin dihabiskan untuk mencari solusi yang ada daripada membangunnya. Tidak setiap kebutuhan esoterik sudah dipenuhi secara memuaskan oleh produk yang ada — sebuah fakta yang saya berhutang pada kemakmuran saya.","author":"User"}]},{"answer":"<p> tekan <kbd> Alt </kbd> + <kbd> ESC </kbd> untuk mengirim jendela latar depan saat ini ke belakang. Terus tekan ini sampai Anda menemukan dialog. Ini akan menggilir jendela genap tidak di <kbd> Alt </kbd> + <kbd> Tab </kbd> daftar. </p>","votes":"0","source":"https://superuser.com/a/31784","author":"<a href=\"https://superuser.com/users/7548/recursive\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">recursive</span></a>","replies":[]},{"answer":"<p> Jadi jawaban ini melibatkan mengunduh pelari skrip gratis <a href=\"https://www.linqpad.net/\" rel=\"nofollow noopener\" target=\"_blank\"> LINQPad </a> untuk menjalankan skrip lalu menjalankannya.\nmenjalankannya, dan meminta Anda untuk menempatkan kursor di atas jendela yang ingin Anda tutup. Ini menginterogasi jendela itu untuk judul, menunjukkannya kepada Anda, lalu menanyakan apakah Anda ingin menutupnya. </p> <pre><code>// close an app's foremost window - will try to just close whatever window the mouse is over first, see if that does the trick\n// close works when linqpad runs as administrator. Used to close a modal in linqpad that was stuck\nopen System.Drawing\n\nmodule PInvoke = \n    type WindowHandle = nativeint\n    module Native = \n        open System.Drawing\n        open System.Runtime.InteropServices\n\n\n        //http://pinvoke.net/default.aspx/user32.SendMessage\n        // IntPtr would be fine here, nativeint is more idiomatic\n        [&lt;DllImport(\"User32\", SetLastError=true)&gt;]\n        extern nativeint private SendMessage(WindowHandle hWnd, int Msg, nativeint wParam, nativeint lParam)\n\n        [&lt;DllImport(\"User32\", EntryPoint=\"WindowFromPoint\", ExactSpelling = true)&gt;]\n        extern WindowHandle private WindowFromPoint (Point point)\n\n        // https://stackoverflow.com/questions/18184654/find-process-id-by-windows-handle\n        //https://stackoverflow.com/a/18184700/57883\n        [&lt;DllImport(\"User32\", SetLastError=true)&gt;]\n        extern int private GetWindowThreadProcessId(WindowHandle hWnd, int&amp; processId)\n\n        // https://stackoverflow.com/questions/1316681/getting-mouse-position-in-c-sharp\n        [&lt;DllImport(\"User32\", SetLastError=true)&gt;]\n        extern bool private GetCursorPos(Point&amp; lpPoint);\n\n        //https://stackoverflow.com/questions/647236/moving-mouse-cursor-programmatically\n        // claims sendInput is better than send messages for clicking\n        [&lt;DllImport(\"User32\", SetLastError=true)&gt;]\n        extern System.Int64 SetCursorPos(int x, int y);\n//        let dll = DllImportAttribute(\"\")\n\n        // But, if you need to get text from a control in another process, GetWindowText() won't work. Use WM_GETTEXT instead.\n        // another mapping for StringBuilder out\n        // you might need to get the string length from another call before calling this: https://www.pinvoke.net/default.aspx/user32.getwindowtext\n        [&lt;DllImport(\"User32\",CharSet=CharSet.Auto,EntryPoint=\"SendMessage\")&gt;]\n        extern nativeint SendWMText(WindowHandle hWnd, int msg, nativeint wParam, StringBuilder sb);\n\n    open Native\n\n    type SendMessageRaw = {hWnd:nativeint; msg:int; wParam:nativeint; lParam:nativeint}\n    type Message&lt;'t&gt; = \n        | Close of windowHandle:nativeint\n        | GetText of windowHandle:nativeint * withReturn :(string -&gt; unit)\n        | [&lt;Obsolete(\"Use only for testing, don't leave things unmapped\")&gt;]\n            Raw of SendMessageRaw\n\n    let ptToParam (pt:System.Drawing.Point) = nativeint (pt.Y &lt;&lt;&lt; 16 ||| pt.X)\n    let sendMessage message = \n        let sendMessage a b c d = SendMessage(a,b,c,d)\n        match message with\n        | Close hwnd -&gt;\n            let WM_CLOSE = 0x0010\n            printfn \"Attempting close\"\n            sendMessage hwnd WM_CLOSE IntPtr.Zero IntPtr.Zero\n        | GetText (hWnd,f) -&gt;\n\n            let WM_GETTEXTLENGTH = 0x000E\n            printfn \"Getting text length\"\n            let length: int =int&lt;|SendMessage(hWnd,WM_GETTEXTLENGTH, IntPtr.Zero, IntPtr.Zero)\n            printfn \"Got text length: %i \" length\n            let mutable sb = StringBuilder(length + 1)\n\n            let WM_GETTEXT = 0x000D\n\n            let result = SendWMText(hWnd,WM_GETTEXT,nativeint (length + 1),sb)\n            printfn \"Text returned is length %i\" sb.Length\n            sb.ToString()\n            |&gt; f\n            result\n        | Raw x -&gt; SendMessage(x.hWnd, x.msg, x.wParam, x.lParam)\n\n    let windowFromPoint(pt:Point) = \n        let mutable pt = pt\n        let hwnd = WindowFromPoint(pt)\n        if hwnd &lt;&gt; IntPtr.Zero then\n            Some hwnd\n        else None\n    let getCursorPos() = \n        let mutable pt = Point()\n        match GetCursorPos(&amp;pt) with\n        | true -&gt; Some pt\n        | false -&gt; None\n    let getWindowThreadProcessId hwnd = \n        let mutable pId = 0\n        let result = GetWindowThreadProcessId(hwnd, &amp;pId)\n        if pId &lt;&gt; 0 then\n            Some pId\n        else None\n\ntype WindowInfo = {PId:int;MainWindowHandle:nativeint; ProcessName:string}\nlet getWindowInfo hwnd = \n    hwnd\n    |&gt; PInvoke.getWindowThreadProcessId\n    |&gt; Option.map (Process.GetProcessById)\n    |&gt; Option.map (fun p -&gt;\n        {PId=p.Id; MainWindowHandle=p.MainWindowHandle; ProcessName=p.ProcessName}\n    )\n\nUtil.ReadLine(\"Put the cursor of the desired window\") |&gt; ignore\nlet currentPt = PInvoke.getCursorPos()\nprintfn \"Current Pos is %A\" currentPt\ncurrentPt\n|&gt; Option.bind(fun pt -&gt;\n    PInvoke.windowFromPoint pt\n)\n|&gt; Option.map(fun hWnd -&gt;\n    printfn \"Current hWnd is %A\" hWnd\n    let wi = getWindowInfo hWnd\n    printfn \"CurrentWindowInfo is %A\" wi\n    wi.Dump()\n    let pid = PInvoke.getWindowThreadProcessId hWnd\n    printfn \"With pId = %A\" pid\n    hWnd\n)\n|&gt; Option.iter(fun hWnd -&gt;\n    let text =\n        let mutable text:string = null\n        let r = PInvoke.sendMessage &lt;| PInvoke.GetText(hWnd,\n                    (fun s -&gt; \n                        printfn \" got text?\"\n                        text &lt;- s))\n        text\n    printfn \"Window text:%s\" text\n    if Util.ReadLine&lt;bool&gt;(\"Attempt close?\") then\n        PInvoke.sendMessage (PInvoke.Message.Close( hWnd))\n        |&gt; ignore&lt;nativeint&gt;\n)\n</code></pre>","votes":"0","source":"https://superuser.com/a/1367349","author":"<a href=\"https://superuser.com/users/39536/maslow\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Maslow</span></a>","replies":[]}]}
