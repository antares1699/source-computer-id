{"title":"Bagaimana aplikasi mengingat otentikasi untuk beberapa saat?","draft":false,"url":"/bagaimana-aplikasi-mengingat-otentikasi-untuk-beberapa-saat-kjtd34ht","votes":"4","answers_count":"2","categories":["Komputer"],"tags":["linux","authentication","password-management"],"snippet":"Di linux beberapa aplikasi terkadang dapat mengingat otentikasi. Sebagai contoh,  Manajer file mengingat otentikasi untuk sementara waktu, ketika kami memberikan kata sandi untuk memasang partisi. Jika kami memasang partisi lain segera setelah...","body":"<p> Di linux beberapa aplikasi terkadang dapat mengingat otentikasi. Sebagai contoh, </p>\n\n<ul>\n<li><p> Manajer file mengingat otentikasi untuk sementara waktu, ketika kami memberikan kata sandi untuk memasang partisi. Jika kami memasang partisi lain segera setelah memasang yang pertama, itu tidak akan meminta kata sandi. </p></li>\n<li><p> Aplikasi terminal, jika kita menjalankan beberapa tugas dengan <code>sudo</code> dan memberikan kata sandi, ia tidak akan meminta tindakan <code>sudo</code> berikutnya jika dilakukan dalam jangka waktu tertentu. </p></li>\n</ul>\n\n<p> Bagaimana fungsi ini diterapkan? Bagaimana saya bisa membuat aplikasi saya mengingat otentikasi root untuk suatu saat? </p>","source":"https://superuser.com/questions/1106370/how-do-applications-remember-authentication-for-sometime","author":"<a href=\"https://superuser.com/users/268976/niyasc\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">niyasc</span></a>","replies":[{"reply":"Otentikasi sebagian besar tidak disimpan dalam cache karena mungkin merupakan ancaman keamanan. sampai kecuali Anda memberikan aplikasi web ingat saya juga tidak akan menyimpan kata sandi. Jika itu operasi windows maka OS digunakan untuk menyimpan di dalamnya format temp terenkripsi dan itu juga tidak akan valid setelah mesin restart","author":"<a href=\"https://superuser.com/users/368738/vembutech\" target=\"_blank\" rel=\"nofollow noopener\">vembutech</a>"},{"reply":"Sebagai catatan tambahan, Anda sebaiknya mencantumkan partisi internal di <code>&#47;etc&#47;fstab</code> agar otomatis dipasang.","author":"<a href=\"https://superuser.com/users/1686/user1686\" target=\"_blank\" rel=\"nofollow noopener\">user1686</a>"},{"reply":"@vembutech Aplikasi web yang dirancang dengan baik tidak akan pernah menyimpan kata sandi sama sekali!","author":"<a href=\"https://superuser.com/users/331628/scott\" target=\"_blank\" rel=\"nofollow noopener\">Scott</a>"}],"answers":[{"answer":"<p> Memiliki program &quot;mengingat&quot; sesuatu itu mudah: menulisnya ke file di suatu tempat, lalu membacanya lagi nanti. Begitulah cara kerja semua pengaturan / preferensi. (Dalam hal ini, seberapa teratur <em> file </em> kerja.) </p>\n\n<p> (Mereka mungkin disimpan sebagai file dalam <code>~/.config/</code> pada disk; file dalam RAM pada <code>/run</code>; penyimpanan pengaturan abstrak seperti GConf atau Windows Registry; itu bervariasi.) </p>\n\n<p> Di keduanya <strong> contoh Anda </strong> , program / layanan yang relevan tidak mengingat detail autentikasi, tetapi hanya fakta bahwa autentikasi berhasil baru-baru ini (dan bahwa tindakan tersebut pada akhirnya diizinkan) - dengan kata lain, otorisasi. </p>\n\n<ul>\n<li><p> Saat memasang disk melalui GUI, permintaan pemasangan dikirim ke <em> UDisks </em> , yang kemudian bertanya <em> polkit </em> untuk konfirmasi. (&quot;Hai, pengguna X mencoba memasang disk Y, apakah itu diizinkan?&quot;) </p>\n\n<p> Karena polkit adalah layanan yang berjalan secara permanen, ia melacak otentikasi terbaru sepenuhnya dalam memori proses itu sendiri, dalam daftar tertaut (GList). Anda dapat mencari <code>src/polkitbackend</code> untuk kata-kata <code>temporary_authorization</code>. </p>\n\n<p> Jika Anda menerapkan fitur yang sama, contoh yang disederhanakan adalah: </p> <pre><code>authorizations = list()\n...\nauthorizations.append({user: \"niyasc\",\n                       action: \"mount drive\",\n                       expires: time.now() + 3600})\n</code></pre> <p> Program Anda juga bisa <a href=\"https://www.freedesktop.org/software/polkit/docs/0.105/polkit-apps.html\" rel=\"nofollow noopener\" target=\"_blank\"> gunakan polkit </a> . </p></li>\n<li><p><em> sudo </em> , di sisi lain, adalah alat sekali pakai, sehingga ia menyimpan informasi yang sama secara eksternal - sebagai file di bawah <code>(/var)/run/sudo/ts</code>. Stempel waktu &quot;terakhir diubah&quot; file dibandingkan untuk melihat apakah itu cukup baru, dan diperbarui setelah setiap penggunaan. </p> <pre><code># ls -l /run/sudo/ts\ntotal 4\n-rw------- 1 root grawity 80 Jul 29 12:15 /run/sudo/ts/grawity\n</code></pre> <p> Algoritme dalam kedua kasus tersebut, kira-kira: </p> <pre><code>def check_authorization(user) {\n    if has_old_authorization(user) {\n        expires = read_authorization(user);\n        if expires &gt; time.now() {\n            return true;\n        }\n    }\n    success = ask_for_authentication(user);\n    if success {\n        store_authorization(user, expires=time.now()+3600);\n    }\n    return success;\n}\n</code></pre> </li>\n</ul>\n\n\n\n<p> Ada metode lain untuk &quot;mengingat otentikasi&quot;, tetapi semuanya bermuara pada penyimpanan sekumpulan byte dalam sebuah file: </p>\n\n<ul>\n<li><p> Banyak aplikasi berbasis jaringan (mis. Klien email seperti Thunderbird atau Outlook) sebenarnya menyimpan nama pengguna &amp; sandi itu sendiri langsung di disk. Contoh yang disederhanakan adalah file ~ / .netrc: </p> <pre><code>machine imap.example.com\n    login niyasc@example.com\n    password foobar\n</code></pre> <p> Seringkali itu dienkripsi sebelum disimpan (aplikasi mungkin menggunakan fasilitas OS seperti GNOME-Keyring, atau mungkin mendukung &quot;kata sandi master&quot;), tetapi pada akhirnya itu <strong> hanya sepotong data yang dapat disimpan dalam sebuah file </strong> . </p></li>\n<li><p> Banyak <em> web </em> Aplikasi berbasis cookie menggunakan cookie untuk mengingat fakta bahwa Anda login. Saat login, server meminta browser Anda untuk mengingat sesuatu seperti &quot;session_id = SGVsbG8gd29ybGQh&quot;, dan mengirimkannya kembali pada setiap kunjungan berikutnya. Browser biasanya memiliki file <a href=\"https://unix.stackexchange.com/questions/36531/format-of-cookies-when-using-wget\" target=\"_blank\" rel=\"nofollow noopener\"> berbasis teks </a> atau database berbasis SQLite dari semua cookie yang dikeluarkan oleh semua situs web (&quot;toples cookie&quot;). </p>\n\n<p> Server juga memiliki basis data &#39;sesi&#39; yang berisi informasi tentang setiap cookie yang dikeluarkan, sehingga ketika menerima &quot;session_id = SGVsbG8gd29ybGQh&quot; yang sama ia tahu Anda niyasc: </p> <pre><code>SESSION_ID         USERNAME   ISSUED          EXPIRES\nSGVsbG8gd29ybGQh   niyasc     Jul 29, 11:47   Aug 29, 11:47\n6kJnRcg4KBAPrMJ4   fred       Jun 14, 22:13   Sep 14, 22:13\n...\n</code></pre> </li>\n<li><p> Beberapa protokol jaringan, seperti Kerberos atau SAML, menggunakan bentuk cookie yang disebut &quot;tiket&quot; atau &quot;token&quot;, yang <em> diri </em> memiliki informasi tentang kapan diterbitkan dan untuk siapa. (Mereka juga ditandatangani secara digital oleh layanan otentikasi sebagai bukti.) Ini juga memungkinkan server &#39;otentikasi&#39; dan server &#39;aplikasi&#39; dipisahkan untuk meningkatkan keamanan. </p></li>\n<li><p> Namun protokol lain, seperti SSH atau SSL / TLS, menggunakan tanda tangan digital - alih-alih memiliki kata sandi sama sekali, klien memiliki keypair pribadi (biasanya RSA atau [EC] DSA), yang juga disimpan sebagai file di disk - misalnya file <code>~/.ssh/id_rsa</code>. </p>\n\n<p> Untuk setiap koneksi, server mengirimkan &quot;tantangan&quot; (serangkaian byte acak); klien menandatanganinya dengan kunci pribadinya; server kemudian memverifikasi tanda tangan dan memeriksa apakah itu ditandatangani oleh salah satu kunci yang &quot;diizinkan&quot;. </p></li>\n</ul>","votes":"6","source":"https://superuser.com/a/1106394","author":"<a href=\"https://superuser.com/users/1686/user1686\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">user1686</span></a>","replies":[]},{"answer":"<p> Ini karena <a href=\"https://en.wikipedia.org/wiki/Cache_%28computing%29\" rel=\"nofollow noopener\" target=\"_blank\"> cache </a> . Konsep cache sangat sederhana. Ini adalah memori yang jauh lebih cepat daripada disk biasa. Kapan pun Anda ingin menemukan sesuatu atau menjalankan perintah, cache kontak pertama cpu, jika ada dalam cache, maka pengambilan terjadi dengan sangat cepat. Tetapi jika tidak, maka itu masuk ke memori normal dan menemukan kemudian mengambil dan seluruh proses membutuhkan waktu. </p>\n\n<p> Linux memahami dan menggunakan konsep caching. Setelah file diakses untuk pertama kali, isinya disimpan dalam memori (jika kosong) untuk digunakan di lain waktu. Lain kali Anda menjalankan perintah yang sama, CPU hanya mengambil konten dari memori, tanpa membuka atau membaca apa pun. Jadi itu meningkatkan kecepatan eksekusi secara keseluruhan. </p>\n\n<p> Katakanlah Anda membuka terminal dan kemudian mengetik perintahnya <strong> pwd </strong> . Untuk pertama kalinya, diperlukan beberapa saat untuk menampilkan direktori kerja saat ini. Sekarang jalankan <strong> pwd </strong> sekali lagi, kali ini Anda akan melihat bahwa eksekusinya sangat cepat. Karena saat menjalankan kedua kalinya, direktori kerja saat ini sudah tersimpan di memori. CPU baru saja mengambil informasinya. </p>\n\n<p> Semoga Anda sudah mendapat ide sekarang. </p>\n\n<p> Terima kasih. </p>","votes":"2","source":"https://superuser.com/a/1106377","author":"<a href=\"https://superuser.com/users/609011/animesh-patra\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Animesh Patra</span></a>","replies":[{"reply":"Selagi <i> konsep </i> sebagian besar sama, status otentikasi cache layanan sama sekali tidak ada hubungannya dengan file cache OS untuk kinerja. Tidak ada satu hal pun yang umum di antara penerapan keduanya.","author":"<a href=\"https://superuser.com/users/1686/user1686\" target=\"_blank\" rel=\"nofollow noopener\">user1686</a>"}]}]}
