{"title":"daftar beberapa jenis file di bash for loop","draft":false,"url":"/daftar-beberapa-jenis-file-di-bash-for-loop-ewc6xvhv","votes":"4","answers_count":"3","categories":["Komputer"],"tags":["bash","bash-scripting"],"snippet":"Saya menulis skrip yang mengubah gambar dalam folder. Skrip menggunakan for loop:  i=\"1\"for file in *.jpg; do     outputFile=$(echo \"image\"$(echo $i))     convert \"$file\" -resize 50x50 $outputFile     i=$[i+1]done  Yang ingin saya lakukan...","body":"<p> Saya menulis skrip yang mengubah gambar dalam folder. Skrip menggunakan for loop: </p> <pre>\ni=\"1\"\nfor file in *.jpg; do\n     outputFile=$(echo \"image\"$(echo $i))\n     convert \"$file\" -resize 50x50 $outputFile\n     i=$[i+1]\ndone\n</pre> <p> Yang ingin saya lakukan adalah mengizinkan skrip dijalankan pada beberapa ekstensi jenis file. Sekarang saya sudah mencoba melakukan: </p> <pre>\nfor file in *.jpg *.JPG *.jpeg; do\n....\ndone\n</pre> <p> Masalah yang saya miliki dengan ini adalah bahwa jika Anda berada di folder dengan semua * .JPG dan tidak ada * .jpg, skrip masih menabrak i + 1 meskipun tidak ada gambar, karena tetap menjalankan loop for, setelah tidak menemukan apapun * .jpg itu akan menjadi * .JPG. <br>\n<br> Bagaimana cara menargetkan beberapa ekstensi file tanpa menjalankannya sendiri per jenis? Contoh, apakah sintaksnya seperti ini: <br></p> <pre>\nfor file in [*.jpg | *.JPG]; do\n...\n</pre> <p> ? <br> Dengan begitu folder keluaran saya selalu berisi gambar berlabel seperti ini: <br> image1.jpg <br> image2.jpg <br> image3.jpg <br> dll .. <br>\n<br> Alih-alih berakhir dengan folder kehilangan image1.jpg karena tidak ada * .jpg untuk dijalankan terlebih dahulu. </p>","source":"https://superuser.com/questions/912096/list-multiple-file-types-in-bash-for-loop","author":"<a href=\"https://superuser.com/users/442930/ob7\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">OB7</span></a>","replies":[{"reply":"... tetapi bagaimana dengan menggunakan <code>if [ -e &quot;$file&quot; ]</code> ... <code>fi</code> dan mengeksekusi konversi dan kenaikan hanya jika file tersebut ada? (Anda dapat menggunakan tes lain untuk memeriksa tautan, dll.). Ini harus melindungi bahkan jika Anda memiliki direktori bernama Jpg.","author":"<a href=\"https://superuser.com/users/257269/hastur\" target=\"_blank\" rel=\"nofollow noopener\">Hastur</a>"}],"answers":[{"answer":"<h3 class=\"h5\"> Solusinya </h3>\n\n<p> Gunakan nullglob. Letakkan baris berikut sebelum loop <code>for</code>: </p> <pre><code>shopt -s nullglob\n</code></pre> <p> <code>nullglob</code> berarti jika tidak ada file seperti itu, glob dihapus dari daftar. Amati tanpa nullglob: </p> <pre><code>$ echo  *.jpg *.JPG *.jpeg\ntest.jpg *.JPG *.jpeg\n</code></pre> <p> Sekarang, dengan nullglob: </p> <pre><code>$ echo  *.jpg *.JPG *.jpeg\ntest.jpg *.JPG *.jpeg\n</code></pre> <h3 class=\"h5\"> Script yang Direvisi </h3>\n\n<p> Skrip lengkapnya bisa jadi: </p> <pre><code>i=1\nshopt -s nullglob\nfor file in *.jpg *.JPG *.jpeg; do\n     convert \"$file\" -resize 50x50 \"image$i.jpg\"\n     i=$((i+1))\ndone\n</code></pre> <p> Tiga catatan: </p>\n\n<ol>\n<li><p> Dalam definisi <code>outputFile</code>, semua pernyataan <code>echo</code> itu tidak diperlukan. </p></li>\n<li><p> Mengikuti konvensi, saya menambahkan ekstensi, <code>.jpg</code>, ke nama file output Anda. Jika Anda benar-benar tidak menginginkan ekstensi tersebut, hapus saja. </p></li>\n<li><p> Saya mengganti <code>$[...]</code> dengan bentuk yang lebih standar: <code>$((...))</code>. </p></li>\n</ol>","votes":"7","source":"https://superuser.com/a/912099","author":"<a href=\"https://superuser.com/users/277295/john1024\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">John1024</span></a>","replies":[{"reply":"Cara yang lebih andal untuk menemukan <i> semua </i> JPEG di direktori saat ini: <code>file * | grep &#39;JPEG image data&#39; | cut -d: -f1</code>","author":"<a href=\"https://superuser.com/users/41316/dummy00001\" target=\"_blank\" rel=\"nofollow noopener\">Dummy00001</a>"}]},{"answer":"<ol>\n<li> Karena Anda ingin mencari lebih dari satu <em> berbeda </em> (case insensitive),\njawaban <code>shopt -s nullglob</code> sangat bagus untuk digunakan. </li>\n<li><p> Jika Anda hanya mencari <pre><b>@(</b><i>pattern-list</i><b>)</b></pre>, <code>*.JPG</code>,\ndan enam kombinasi lain dari huruf besar dan kecil,\nhal termudah untuk dilakukan adalah </p> <pre class=\"lang-none prettyprint-override\"><code>for file in *.[Jj][Pp][Gg]\n</code></pre> <p> yang mencari file yang namanya </p>\n\n<ul>\n<li> (sesuatu), diikuti oleh </li>\n<li> <code>.</code> (titik), diikuti oleh </li>\n<li> <code>J</code> atau <code>j</code>, diikuti oleh </li>\n<li> <code>P</code> atau <code>p</code>, diikuti oleh </li>\n<li> <code>G</code> atau <code>g</code> </li>\n</ul>\n\n<p> dengan kata lain, </p>\n\n<ul>\n<li> (sesuatu), diikuti oleh </li>\n<li> <code>.</code> (titik), diikuti oleh </li>\n<li> &quot;jpg&quot;, dalam beberapa kombinasi huruf besar dan kecil </li>\n</ul></li>\n<li><p> Jadi salah satu cara untuk menyelesaikan masalah Anda adalah </p> <pre class=\"lang-none prettyprint-override\"><code>shopt -s nullglob\nfor file in *.[Jj][Pp][Gg] *.[Jj][Pp][Ee][Gg]\ndo …\n</code></pre> </li>\n<li><p> Trik <code>[…]</code> bagus untuk diketahui, tapi ada cara yang lebih baik.\nJika saya memberi tahu Anda bahwa ada opsi shell bernama <code>nocaseglob</code>,\nbisakah kamu menebak apa fungsinya? </p> <pre class=\"lang-none prettyprint-override\"><code>shopt -s nullglob nocaseglob\nfor file in *.jpg *.jpeg\ndo …\n</code></pre> <p> jadi sekarang <code>j</code> artinya </p>\n\n<ul>\n<li> (sesuatu), diikuti oleh </li>\n<li> <code>.</code> (titik), diikuti oleh </li>\n<li> &quot;jpg&quot;, dalam beberapa kombinasi huruf besar dan kecil </li>\n</ul>\n\n<p> dan perintah di atas\nakan cocok dengan <code>shopt -s nullglob nocaseglob\nfor file in *.jpg *.jpeg\ndo …\n</code>, <code>*.JPG</code>, <code>*.Jpg</code>, <code>*.jpeg</code>, <code>*.jPeG</code>, dll. </p></li>\n<li><p> Cara lain adalah dengan menggunakan opsi shell <code>extglob</code>\nuntuk mengaktifkan operator pencocokan pola yang diperluas.\nAnda masih menginginkan <code>nullglob</code> dan <code>nocaseglob</code>.\nSemua operator pencocokan pola yang diperluas terlihat seperti </p> <pre><b><i>(some_special_character)</i>  (</b>  <i>pattern-list</i>  <b>)</b></pre> <p> di mana spasi ditambahkan untuk kejelasan,\ndan <em> <code>pattern-list</code> </em> adalah daftar <em> <code>pattern</code>-an </em> dipisahkan oleh <code>|</code> karakter.\nSalah satu yang terlihat paling menarik untuk tujuan Anda adalah </p> <pre><b>@(</b><i>pattern-list</i><b>)</b></pre> <p> yang berarti cocok dengan salah satu pola yang terdaftar.\nJadi sekarang skripnya menjadi </p> <pre><b><i>(some_special_character)</i>  (</b>  <i>pattern-list</i>  <b>)</b></pre> <p> Ini mungkin terlihat seperti mengetik lebih banyak,\ntetapi pengorbanannya bergeser seiring dengan bertambahnya jumlah ekstensi. Mempertimbangkan, </p> <pre class=\"lang-none prettyprint-override\"><code>for file in *.@(jpg|jpeg|jfif|exif|tif|tiff|gif|bmp|png|svg)\n</code></pre> <p> sedikit lebih pendek dari </p> <pre class=\"lang-none prettyprint-override\"><code>for file in *.jpg *.jpeg *.jfif *.exif *.tif *.tiff *.gif *.bmp *.png *.svg\n</code></pre> </li>\n<li><p> Di mana Anda belajar melakukan <code>j</code>?\nTentu, <code>$(<i>some_command(s)</i> …)</code> pasti bisa berguna,\ndan mungkin kadang-kadang <code>$(echo …)</code>, tetapi Anda terlalu sering menggunakannya.\nSangat bagus untuk dikatakan </p> <pre class=\"lang-none prettyprint-override\"><code>outputFile=\"image$i\"\n</code></pre> <p> dan Anda mungkin bahkan tidak membutuhkan tanda kutip ( <em> dalam pernyataan penugasan </em> ). </p></li>\n<li><p> Oke, Anda bisa dimaafkan <em> sekali ini saja </em> ,\nkarena Anda tahu bahwa nilai <code>outputFile</code> adalah jinak,\nkarena Anda menyetelnya dari string tidak kosong yang konstan,\nkarakter non-khusus (<code>image</code>) ditambah variabel\nyang Anda setel ke string konstan karakter non-kosong, tidak khusus (<code>1</code>)\ndan hanya melakukan operasi aritmatika sepele di atasnya.\nTapi, sebagai aturan umum, Anda harus melakukannya <em> selalu </em> mengutip semua referensi\nuntuk variabel shell, kecuali Anda memiliki alasan yang sangat bagus untuk tidak melakukannya\ndan Anda yakin tahu apa yang Anda lakukan.\nJadi, idealnya, perintah <code>convert</code> Anda adalah </p> <pre class=\"lang-none prettyprint-override\"><code>convert \"$file\" -resize 50x50 \"$outputFile\"\n</code></pre> <p> (dengan kutipan sekitar <code>$outputFile</code>.) </p></li>\n</ol>","votes":"3","source":"https://superuser.com/a/912224","author":"<a href=\"https://superuser.com/users/150988/scott\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Scott</span></a>","replies":[]},{"answer":"<p> Anda ingin mengganti bagian ini: </p> <pre><code>for file in *.jpg; do\n</code></pre> <p> Dengan ini: </p> <pre><code>for file in $(ls *.jpg *.JPG); do\n</code></pre>","votes":"-1","source":"https://superuser.com/a/912105","author":"<a href=\"https://superuser.com/users/24670/tuan-anh-hoang-vu\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Tuan Anh Hoang-Vu</span></a>","replies":[{"reply":"menggunakan <code>ls</code> dalam loop for seperti ini tidak disarankan. Lihat <a href=\"http://mywiki.wooledge.org/ParsingLs\" rel=\"nofollow noopener\" target=\"_blank\"> Mengapa Anda tidak perlu mengurai output ls </a>","author":"<a href=\"https://superuser.com/users/282910/slizzered\" target=\"_blank\" rel=\"nofollow noopener\">Slizzered</a>"}]}]}
