{"title":"Jumlah utas yang optimal saat melakukan banyak tugas","draft":false,"url":"/jumlah-utas-yang-optimal-saat-melakukan-banyak-tugas-c9hkgqd2","votes":"4","answers_count":"4","categories":["Komputer"],"tags":["multi-core","parallel-processing","multi-threaded"],"snippet":"Saya tahu pertanyaan serupa telah diajukan, tetapi saya pikir kasus saya sedikit berbeda.  Katakanlah saya memiliki komputer dengan 8 core dan memori tak terbatas dengan OS Linux.  Saya memiliki perangkat lunak kalkulasi...","body":"<p> Saya tahu pertanyaan serupa telah diajukan, tetapi saya pikir kasus saya sedikit berbeda. </p>\n\n<p> Katakanlah saya memiliki komputer dengan 8 core dan memori tak terbatas dengan OS Linux. </p>\n\n<p> Saya memiliki perangkat lunak kalkulasi bernama Gaussian yang dapat memanfaatkan multithreading. Jadi saya menyetel jumlah utasnya menjadi 8 untuk satu kalkulasi untuk kecepatan maksimum. Namun saya benar-benar tidak dapat memutuskan apa yang harus saya lakukan ketika saya perlu menjalankan misalnya 8 perhitungan secara bersamaan. Dalam hal ini, haruskah saya menyetel jumlah utas ke 1 (total 8 utas muncul dalam 8 proses) atau menyimpannya 8 (total 64 utas muncul dalam 8 proses) untuk setiap pekerjaan? Apakah itu sangat penting? Pertanyaan terkait adalah apakah OS secara otomatis melakukan parkir inti ke inti yang berbeda untuk setiap utas? </p>\n\n<p><strong> EDIT: </strong> Saya tahu pembandingan adalah cara terbaik untuk mengetahuinya. Masalahnya, komputer itu milik universitas saya jadi mereka sibuk sepanjang waktu. Dengan kata lain, beban kerjanya bervariasi dalam cara yang tidak terkendali bagi saya karena orang lain juga menggunakan komputer ini untuk kalkulasi mereka, membuat percobaan menjadi tidak mungkin. Juga perangkat lunaknya sangat mahal ($ 1500 atau sesuatu) dan berlisensi untuk setiap komputer, jadi saya tidak bisa begitu saja menjalankan benchmark di komputer pribadi saya ... </p>","source":"https://superuser.com/questions/664550/optimum-number-of-threads-while-multitasking","author":"<a href=\"https://superuser.com/users/184828/thegd\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">theGD</span></a>","replies":[{"reply":"Menghormati jawaban (benar dan akurat) yang diberikan, tidak ada jaminan bahwa program akan bekerja lebih baik dengan jumlah utas maksimum daripada dengan satu utas (misalnya, mungkin diprogram lebih baik untuk utas tunggal, beberapa utas mungkin memperlambat proses secara keseluruhan, dll), meskipun jika diprogram, itu <i> Sebaiknya </i> . Seperti yang ditunjukkan oleh konsensus umum, hal terbaik yang harus dilakukan adalah membandingkan setiap konfigurasi dengan set pengujian terbatas.","author":"<a href=\"https://superuser.com/users/228536/doktoro-reichard\" target=\"_blank\" rel=\"nofollow noopener\">Doktoro Reichard</a>"},{"reply":"Anda hanya harus mengukurnya.","author":"<a href=\"https://superuser.com/users/36744/der-hochstapler\" target=\"_blank\" rel=\"nofollow noopener\">Der Hochstapler</a>"}],"answers":[{"answer":"<p> Idealnya, jumlah utas total untuk semua tugas harus berupa jumlah inti sistem, kecuali pada sistem yang mendukung hyper-threading, yang harus dua kali jumlah inti. Jadi jika sistem tidak memiliki hyper-threading, ada 8 penghitungan yang berjalan, masing-masing harus dijalankan dalam satu utas. </p>\n\n<p><em> Banyak prosesor Intel hadir dengan hyper-threading, sehingga setiap inti dapat mendukung dua utas. Misalnya sistem 8 inti yang mendukung hyper-threading harus memiliki 16 utas untuk memanfaatkan sistem sepenuhnya. </em></p>","votes":"5","source":"https://superuser.com/a/665653","author":"<a href=\"https://superuser.com/users/147438/ramchandra-apte\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Ramchandra Apte</span></a>","replies":[]},{"answer":"<p> Jawabannya tergantung pada apa yang prosesnya lakukan dan bagaimana multi-threading diprogram,\nartinya Anda perlu bereksperimen. </p>\n\n<p> Jika proses menggunakan semaphores dan mekanisme pengecualian lainnya untuk perselisihan antara\nutas pada sumber daya umum (seperti memori), maka semakin sedikit jumlah utasnya\ndalam prosesnya, semakin sedikit jumlah konflik yang akan menyebabkan menunggu. </p>\n\n<p> Selama menunggu, thread tidak melakukan apa pun, jadi menunggu akan berdampak negatif pada throughput.\nDalam hal ini, lebih banyak proses dan lebih sedikit utas per proses akan meningkatkan throughput,\njadi 8x8 akan memiliki kinerja yang lebih baik dari 1x64. </p>\n\n<p> Di sisi lain, jika setiap utas benar-benar terisolasi dan tidak ada kesamaan bersama\nsumber daya, maka sistem operasi akan menjadwalkan utas tanpa perbedaan apa pun\nantara dua kasus 8x8 atau 1x64.\nDalam hal ini hanya jumlah utas yang penting untuk total keluaran,\njadi kedua kasus memiliki kinerja yang sama. </p>","votes":"3","source":"https://superuser.com/a/665746","author":"<a href=\"https://superuser.com/users/8672/harrymc\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">harrymc</span></a>","replies":[{"reply":"Karena pembaruan Anda mengatakan bahwa komputer sangat sibuk, maka terlalu banyak utas akan memiliki efek sebaliknya yaitu memperlambat komputer. Mengalihkan CPU di antara utas adalah operasi yang mahal.","author":"<a href=\"https://superuser.com/users/8672/harrymc\" target=\"_blank\" rel=\"nofollow noopener\">harrymc</a>"}]},{"answer":"<p> Jumlah yang benar tergantung pada berapa banyak waktu yang dihabiskan proses yang diblokir di IO. </p>\n<p> Buku &quot;Programming Concurrency on the JVM&quot; memiliki beberapa informasi bagus tentang ini: </p>\n<blockquote>\n<p> &quot;Menentukan Jumlah Thread&quot;. Untuk masalah besar, kami ingin memiliki setidaknya jumlah utas sebanyak jumlah inti yang tersedia. Ini akan memastikan bahwa sebanyak mungkin inti yang tersedia untuk proses digunakan untuk menyelesaikan masalah kita ... </p>\n<p> Jadi jumlah minimum utas sama dengan jumlah inti yang tersedia. Jika semua tugas komputasi intensif, maka inilah yang kita butuhkan. Memiliki lebih banyak utas sebenarnya akan merugikan dalam kasus ini karena inti akan menjadi konteks yang beralih antar utas ketika masih ada pekerjaan yang harus dilakukan. Jika tugas bersifat intensif IO, maka kita harus memiliki lebih banyak utas. </p>\n<p> Saat tugas menjalankan operasi IO, utasnya akan diblokir. Prosesor segera mengalihkan konteks untuk menjalankan utas lain yang memenuhi syarat. Jika kami hanya memiliki utas sebanyak jumlah inti yang tersedia, meskipun kami memiliki tugas yang harus dilakukan, mereka tidak dapat berjalan karena kami belum menjadwalkannya pada utas untuk diambil oleh prosesor. </p>\n<p> Jika tugas menghabiskan 50 persen dari waktu yang diblokir, maka jumlah utas harus dua kali jumlah inti yang tersedia. Jika mereka menghabiskan lebih sedikit waktu untuk diblokir - yaitu, komputasi intensif - maka kita harus memiliki lebih sedikit utas tetapi tidak kurang dari jumlah inti. Jika mereka menghabiskan lebih banyak waktu untuk diblokir - yaitu, mereka intensif IO - maka kita harus memiliki lebih banyak utas, khususnya, beberapa kelipatan jumlah inti. </p>\n<p> Jadi kita bisa menghitung jumlah utas yang kita perlukan sebagai berikut: </p>\n<p> Jumlah utas = Jumlah Inti yang Tersedia / (1 - Koefisien Pemblokiran) </p>\n</blockquote>\n<p> Jika Anda perlu menjalankan beberapa penghitungan secara bersamaan, mungkin melihat apakah mungkin untuk menjalankannya dalam satu proses dengan kumpulan utas yang berukuran tepat. </p>\n<p> Sebaliknya, jika Anda memiliki jumlah utas yang optimal untuk satu kalkulasi, tetapi kemudian menjalankan 8 sekaligus, Anda mungkin memiliki terlalu banyak. </p>\n<p> Solusi terbaik adalah melakukan benchmark secara eksperimental. </p>\n<p> Saya tidak begitu yakin apa yang Anda maksud dengan parkir inti, tetapi CPU akan cenderung terus menjalankan utas yang sama pada inti tertentu karena alasan cache, meskipun kadang-kadang juga akan memindahkannya karena alasan panas / daya yang berbeda. Anda dapat menyelidiki ini dengan menggunakan alat seperti htop. </p>","votes":"3","source":"https://superuser.com/a/667101","author":"<a href=\"https://superuser.com/users/125080/stephenbez\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">stephenbez</span></a>","replies":[{"reply":"Masalahnya, komputer milik universitas saya sehingga selalu sibuk. Dengan kata lain, beban kerjanya bervariasi dalam cara yang tidak terkendali bagi saya karena orang lain juga menggunakan PC tersebut untuk kalkulasi mereka, membuat percobaan menjadi tidak mungkin.","author":"<a href=\"https://superuser.com/users/184828/thegd\" target=\"_blank\" rel=\"nofollow noopener\">theGD</a>"},{"reply":"I / O masih jauh dari satu-satunya sumber daya bersama di antara utas.","author":"<a href=\"https://superuser.com/users/8672/harrymc\" target=\"_blank\" rel=\"nofollow noopener\">harrymc</a>"}]},{"answer":"<p> Anda telah menjawab pertanyaan itu sendiri. &quot;komputer milik universitas saya sehingga mereka sibuk sepanjang waktu&quot; </p>\n\n<p> Anda sebenarnya hanya mendapatkan sepotong prosesor. Untuk menyelesaikan pekerjaan dengan cara yang paling efisien, overhead pengalihan tugas dan multipleks, dan menunggu sumber daya harus diminimalkan. Oleh karena itu, Anda harus selalu mempertimbangkan untuk melakukannya dengan satu utas. </p>\n\n<p> Multi-threading selalu kurang efisien jika dihitung berdasarkan &quot;daya pemrosesan&quot; karena overhead pengalihan konteks. Ini hanya mempercepat masalah untuk memanfaatkan semua sumber daya kosong yang &quot;gratis&quot;. Ide: menggunakan 8 komputer untuk menjalankan masalah mungkin 7,9 kali lebih cepat, yang tidak pernah bisa lebih dari 8. </p>\n\n<p> Jika semua ini didedikasikan untuk Anda, lakukan saja secara paralel untuk mempercepat, jika tidak, jaga agar tetap menjadi satu utas dan biarkan orang lain menggunakan inti yang tersisa untuk pekerjaan lain. </p>\n\n<p> Ngomong-ngomong, dengan cara yang egois, ada alat topi merah yang disebut grid yang dapat membagi pekerjaan Anda ke semua linux di seluruh kampus. (&gt; 200). Ini akan berjalan sangat cepat, hanya saja jangan sampai ketahuan, karena itu akan memperlambat semua orang. atau gunakan alat lama, mathlab parallel. </p>","votes":"1","source":"https://superuser.com/a/667858","author":"<span itemprop=\"name\">user218473</span>","replies":[]}]}
