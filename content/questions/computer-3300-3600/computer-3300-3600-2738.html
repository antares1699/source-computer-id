{"title":"Transisi SELinux dari unconfined_r ke user_r","draft":false,"url":"/transisi-selinux-dari-unconfined-r-ke-user-r-bpe2lewr","votes":"4","answers_count":"3","categories":["Komputer"],"tags":["linux","sudo","selinux","access-control"],"snippet":"Pada mesin Fedora 18, saya memiliki konteks SELinux berikut sebagai pengguna biasa yang dibuat selama instalasi:  $ sestatusSELinux status:                 enabledLoaded policy name:             targetedCurrent mode:                   enforcingMode from config file:...","body":"<p> Pada mesin Fedora 18, saya memiliki konteks SELinux berikut sebagai pengguna biasa yang dibuat selama instalasi: </p> <pre><code>$ sestatus\nSELinux status:                 enabled\nLoaded policy name:             targeted\nCurrent mode:                   enforcing\nMode from config file:          enforcing\nPolicy MLS status:              enabled\nPolicy deny_unknown status:     allowed\n</code></pre> <p> dan </p> <pre><code>$ id -Z\nunconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023\n</code></pre> <p> Saya ingin menjalankan program dengan peran selinux terbatas <code>user_r</code>, bukan <code>unconfined_r</code> saya saat ini, jadi saya membuat pengguna baru dengan pengguna SELinux terbatas <code>user_r</code>: </p> <pre><code># useradd -MN -Z user_u johndoe\n# echo 'fubar' | passwd johndoe --stdin\n</code></pre> <p> Sekarang, saya membuka tty baru dan login sebagai <code>johndoe</code> menggunakan <code>agetty</code>. Ia mengeluh bahwa <code>/home/johndoe</code> tidak ada, tetapi pada dasarnya, ia memasukkan saya. Konteks SELinux: </p> <pre><code>$ id -Z\nuser_u:user_r:user_t:s0\n</code></pre> <p> <code>user_u:user_r:user_t</code> sempurna dan apa yang saya inginkan. Tapi saya ingin mencapai ini dalam sebuah naskah <em> sudah </em> berjalan sebagai <code>unconfined_u</code> dan bukan sebagai login baru. Saya mencoba dengan <code>sudo</code>: </p>\n\n<p> Jika saya menggunakan <code>sudo -u</code>, saya mendapatkan: </p> <pre><code>$ sudo -u johndoe id -Z\nunconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023\n</code></pre> <p> Artinya, pengguna SELinux tidak berubah. </p>\n\n<p> Saya juga mencoba: </p> <pre><code>$ sudo -r user_r -u johndoe id -Z\nsudo: unconfined_u:user_r:user_t:s0-s0:c0.c1023 is not a valid context\nsudo: unable to execute /bin/id: Invalid argument\n</code></pre> <p> Jadi, tidak beruntung juga. </p>\n\n<p> Jadi bagaimana cara saya beralih dari peran <code>unconfined_r</code> ke <code>user_r</code>, menggunakan <code>sudo</code> atau <code>su</code> (atau yang lainnya)? </p>","source":"https://superuser.com/questions/687456/selinux-transition-from-unconfined-r-to-user-r","author":"<a href=\"https://superuser.com/users/62149/arjunshankar\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">ArjunShankar</span></a>","replies":[],"answers":[{"answer":"<p> Sudahkah Anda mencoba solusi policycoreutils-sandbox? Ini persis seperti yang Anda inginkan. Misalnya jika Anda ingin menjalankan Firefox di lingkungan yang dibatasi SELinux (sayangnya, tetapi untuk alasan yang baik, &quot;kotak pasir&quot; hanya didukung pada distribusi Red Hat): </p> <pre><code>/usr/bin/sandbox -X -t sandbox_web_t firefox\n</code></pre> <p> SELinux dibedakan dari sistem MAC berbasis LSM lainnya karena fleksibilitas dan kemampuan penyesuaiannya. </p>\n\n<p> Ini memungkinkan Anda untuk melakukan apa yang Anda inginkan, meskipun itu tidak masuk akal. Salah satu prasyaratnya adalah Anda menyadari setidaknya prinsip dan konsep dasar. </p>\n\n<p> Ada beberapa hal yang perlu diperhatikan di sini: </p>\n\n<ul>\n<li> ID keamanan identitas SELinux unconfined_u harus\nterkait dengan pengenal keamanan peran user_r SELinux jika Anda\ningin kombinasi &quot;unconfined_u: user_r&quot; dalam konteks keamanan\nberlaku. </li>\n</ul>\n\n<p> Ini dapat dilakukan dengan: </p> <pre><code>semanage user -m -L s0 -r s0-s0:c0.c1023 -R \"unconfined_r system_r user_r\" -P user unconfined_u\n</code></pre> <ul>\n<li> Pengenal keamanan peran SELinux unconfined_r harus diizinkan\nsecara manual (melalui sudo dalam kasus ini) diubah menjadi user_r SELinux\npengenal keamanan peran. </li>\n</ul>\n\n<p> Ini dapat dilakukan dengan membuat modul kebijakan sederhana: </p> <pre><code>cat &gt; myuser.te &lt;&lt;EOF\nmodule myuser 1.0;\nrequire { role unconfined_r, user_r; }\nallow unconfined_r user_r;\nEOF\n\ncheckmodule -M -m myuser.te -o myuser.mod\nsemodule_package -o myuser.pp -m myuser.mod\nsudo semodule -i myuser.pp\n</code></pre> <ul>\n<li><p> Sudo perlu diberi tahu pengenal keamanan tipe SELinux mana itu\nharus digunakan bersama dengan keamanan peran user_r SELinux yang ditentukan\npengenal </p>\n\n<p> sudo -r user_r -t user_t id -Z </p></li>\n</ul>\n\n<p> Saya yakin saya telah menyentuh semua pertimbangan tetapi saya mungkin telah mengabaikan beberapa dan contoh saya mungkin salah ketik. Lihat halaman manual untuk perintah yang saya sebutkan. </p>","votes":"4","source":"https://superuser.com/a/688375","author":"<a href=\"https://superuser.com/users/281867/domg472\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">domg472</span></a>","replies":[{"reply":"<code>sandbox -t sandbox_min_t id -Z</code> <i> tidak </i> tunjukkan bahwa peran SELinux berubah menjadi <code>sandbox_min_t</code>. Saya belum cukup tahu tentang SELinux untuk menandai jawaban ini sebagai &#39;benar&#39;, jadi untuk saat ini, ini mendapat +1. Terima kasih @ domg472. Saya akan menindaklanjuti jika saya tahu lebih banyak.","author":"<a href=\"https://superuser.com/users/62149/arjunshankar\" target=\"_blank\" rel=\"nofollow noopener\">ArjunShankar</a>"}]},{"answer":"<p> Saat menggunakan <strong> MLS </strong> , perintahmu </p>\n\n<p> <code>sudo -u johndoe id -Z</code> </p>\n\n<p> berarti Anda melewati Anda <strong> wewenang </strong> dan <strong> Tipe </strong> ke sudo. Anda harus menggunakan perintah </p>\n\n<p> <code>sudo -r user_r -u johndoe id -Z</code> </p>\n\n<p> Selain itu, jika Anda mencoba masuk dengan konsol atau ssh, Anda juga dapat melihat peran dan jenis yang benar. </p>\n\n<p><strong> EDIT: </strong> Saya ingin memberikan beberapa catatan juga.\nAnda tidak dapat mengubah konteks Anda (<code>id -Z</code>) jika tidak ada transisi yang valid. Anda akan mendapatkan error seperti </p>\n\n<p> <code>sudo: ... is not a valid context</code> </p>\n\n<p> Untuk menjadi root, pertama-tama Anda harus masuk <strong> sudoers </strong> file dan <strong> staff_u </strong> pengguna selinux. Untuk sudo, saya hanya suka menambahkan <code>myuser ALL=/bin/su</code> untuk menggunakan <code>sudo su -</code>. Setelah saya melakukan <code>sudo su -</code>, menjadi root, saya menjalankan <code>newrole -r sysadm_r</code> untuk mendapatkan hak admin sistem. Hal ini tidak mengherankan karena sudo tidak dapat diubah <strong> wewenang </strong> . Sama seperti, sebelum keluar saya menjalankan <code>newrole -r staff_r</code> untuk mengembalikan peran saya sendiri. Setelah itu saya log out, jika tidak shell hang (kesalahan konteks yang valid). </p>","votes":"2","source":"https://superuser.com/a/862177","author":"<a href=\"https://superuser.com/users/406652/kazim-sarikaya\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Kazim SARIKAYA</span></a>","replies":[]},{"answer":"<p> Itu cukup rumit. Saya mendapatkan sesuatu yang berfungsi melalui peretasan. Pertama, tulis skrip Anda dalam sebuah file. Kemudian, gunakan <code>semanage fcontext</code> untuk menambahkan aturan pelabelan. SELinux menggunakan label ini untuk menerapkan kurungan. Dalam contoh saya, saya mereproduksi konteks postgres. </p> <pre><code># semanage fcontext -a -s system_u -t postgresql_exec_t /absolute/path/to/my-script\n# restorecon -v my-script\n</code></pre> <p> SELinux mengetahui beberapa transisi. Misalnya systemd berjalan di init_t dan file berlabel postgresql_exec_t ditransisikan dalam konteks postgresql. Jadi, saya menulis layanan oneshot systemd untuk menggunakan kembali transisi itu. </p> <pre><code># /etc/systemd/system/multi-users.target.wants/my-script.service\n[Unit]\nDescription=My Script\nAfter=syslog.target\nAfter=network.target\n\n[Service]\nType=oneshot\n\nUser=postgres\nGroup=postgres\n\nExecStart=/usr/local/bin/cornac-selinux\n</code></pre> <p> Kemudian, jalankan dengan <code>systemctl</code> </p> <pre><code># systemctl start my-script.service\n# journalctl -n 10 --no-pager\naoût 19 15:19:11 bernace-db0 cornac-selinux[14928]: + id                                                                                \naoût 19 15:19:11 bernace-db0 cornac-selinux[14928]: uid=26(postgres) gid=26(postgres) groupes=26(postgres) contexte=system_u:system_r:postgresql_t:s0                                                                                                                            \n</code></pre> <p> Itulah yang terbaik yang dapat saya lakukan sejauh ini, tanpa menulis modul kebijakan kustom. </p>","votes":"1","source":"https://superuser.com/a/1472893","author":"<a href=\"https://superuser.com/users/710632/%c3%89tienne-bersac\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">&#201;tienne Bersac</span></a>","replies":[]}]}
