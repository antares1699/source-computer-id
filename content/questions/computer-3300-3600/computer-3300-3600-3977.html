{"title":"Bagaimana cara memotong file menjadi beberapa bagian dengan lebih efisien?","draft":false,"url":"/bagaimana-cara-memotong-file-menjadi-beberapa-bagian-dengan-lebih-efisien-rdtq4evr","votes":"4","answers_count":"4","categories":["Komputer"],"tags":["bash","shell","file-io","script"],"snippet":"Misalkan saya memiliki file teks 10MB foo.txt, dan memiliki 100.000 baris. Sekarang, saya ingin memproses foo.txt jendela demi jendela, dengan ukuran jendela 10.  Skrip saya saat ini seperti ini:  for ((i=0;i&lt;$lines;i=i+$step))do...","body":"<p> Misalkan saya memiliki file teks 10MB <code>foo.txt</code>, dan memiliki 100.000 baris. Sekarang, saya ingin memproses <code>foo.txt</code> jendela demi jendela, dengan ukuran jendela 10. </p>\n\n<p> Skrip saya saat ini seperti ini: </p> <pre><code>for ((i=0;i&lt;$lines;i=i+$step))\ndo    \n    head -$((i+step)) $1 | tail -$step &gt; tmp1\n    head -$((i+step)) $2 | tail -$step &gt; tmp2\n    setstr=$setstr' '`./accuracy.sh tmp1 tmp2`\ndone\necho $setstr | awk '{for (i=1;i&lt;=NF;i++) sum+=$i; }END{print sum/NF}'\n</code></pre> <p> Tapi itu berjalan lambat. Adakah cara sederhana dan lebih efisien untuk melakukan ini? </p>","source":"https://superuser.com/questions/504132/how-to-cut-a-file-into-pieces-more-efficiently","author":"<a href=\"https://superuser.com/users/205629/jackwm\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">JackWM</span></a>","replies":[],"answers":[{"answer":"<p> Anda dapat melakukannya dengan <code>split</code>: </p>\n\n<p> Berikut contoh cara menggunakannya: </p> <pre><code>split -l 10 input_file output_file_prefix_\n</code></pre> <p> Opsi <code>-l</code> adalah singkatan dari <code>--lines=</code> </p>\n\n<p> Dan ini akan membagi <code>input_file</code> menjadi potongan-potongan dengan masing-masing 10 baris, menjadi file-file ini: </p> <pre><code>output_file_prefix_aa\noutput_file_prefix_ab\noutput_file_prefix_ac\n...\n</code></pre> <p> dan seterusnya. </p>\n\n<p> Untuk cara lain Anda dapat menggunakan <code>split</code>, lihat <code>man split</code> atau <a href=\"http://www.computerhope.com/unix/usplit.htm\" rel=\"nofollow noopener\" target=\"_blank\"> sini </a></p>","votes":"5","source":"https://superuser.com/a/504133","author":"<a href=\"https://superuser.com/users/166178/sampson-chen\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">sampson-chen</span></a>","replies":[{"reply":"terima kasih, sampson. Satu masalah dengan solusi Anda adalah itu akan menghasilkan file temporal dalam jumlah besar. Dalam contoh saya, itu akan menjadi 10.000 file. Terakhir kali, saya menggunakan Java untuk membagi file, dan butuh waktu lama untuk menghapusnya.","author":"User"},{"reply":"@JackWM Bagaimana Anda menghapus file-file sementara? Apakah itu seperti <code>rm output_file_prefix_*</code>?","author":"<a href=\"https://superuser.com/users/166178/sampson-chen\" target=\"_blank\" rel=\"nofollow noopener\">sampson-chen</a>"},{"reply":"<code>rm</code> akan melaporkan kesalahan karena jumlah file yang besar. Dan meskipun kami menghindari ini, penghapusan masih membutuhkan banyak waktu.","author":"User"}]},{"answer":"<p> Akan berguna untuk memiliki lebih banyak konteks tentang tujuan akhir Anda daripada cuplikan kode. Secara khusus, apakah Anda memiliki kendali atas akurasi.sh? </p>\n\n<p> Bagaimanapun, jika Anda ingin tetap menggunakan bash, maka Anda bisa melakukannya </p> <pre><code>for ((i=0;i&lt;$lines;i+=$step))\ndo\n  let end=i+10\n  sed -n $i,${end}p $1 &gt;tmp1\n  sed -n $i,${end}p $2 &gt;tmp2\n  ...\ndone\n</code></pre>","votes":"1","source":"https://superuser.com/a/505393","author":"<a href=\"https://superuser.com/users/173336/peter-sundstrom\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Peter Sundstrom</span></a>","replies":[]},{"answer":"<p> Tidak yakin mengapa ini dimigrasi dari StackOverflow. Sedangkan <code>split</code> adalah a <em> superuser </em> jawaban gaya, pertanyaannya tentang pemrograman. Misalnya, berikut adalah jawaban yang menerapkan apa yang Anda cari di tahun <code>awk</code>. </p>\n\n<p> Salah satu aspek yang sangat berguna dari <code>awk</code> adalah cara menangani pipa. </p> <pre><code>#!/usr/bin/awk -f\n\nBEGIN {\n  cmd=\"/path/to/handler\"\n}\n\n{\n  print | cmd\n}\n\nNR % 10 == 0 {\n  close(cmd)\n}\n</code></pre> <p> <code>cmd</code> Anda akan dibuka kembali jika ditutup ... dan ditutup setiap baris ke-10, untuk membuka kembali baris keluaran berikutnya. </p>\n\n<p> Efeknya akan menjalankan <code>handler</code> setiap 10 baris input. Di akhir file, <code>handler</code> akan dijalankan dengan baris apa pun yang tersisa, karena <code>cmd</code> secara otomatis ditutup saat keluar dari awk. </p>\n\n<p> Sebenarnya, Anda tidak perlu menggunakan variabel seperti <code>cmd</code> untuk menyimpan perintah ... tetapi itu membuatnya lebih mudah untuk menyesuaikan perintah, karena Anda perlu memperhatikan dengan SANGAT hati-hati untuk kesalahan ketik pada <code>close()</code> Anda. </p>","votes":"0","source":"https://superuser.com/a/504247","author":"<a href=\"https://superuser.com/users/113356/ghoti\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">ghoti</span></a>","replies":[]},{"answer":"<p> Solusi ini tidak menggunakan file sementara apa pun. Apa yang dilakukan adalah menyimpan setiap baris dalam array penyangga yang dapat menampung sepuluh baris. Setiap kali nomor baris habis dibagi sepuluh, itu mencetak semua baris di buffer. </p>\n\n<p> Jebakan yang jelas adalah ketika file input (# baris) tidak habis dibagi sepuluh. Solusinya adalah melakukan pemeriksaan dalam klausa {} END. Sesuatu seperti: </p> <pre>\n$ echo {1..33} | tr \\  \\\\n |\\\n    awk '{lines=NR} END{ if (lines%10!=0) { print \"leftover lines\"} }'\nleftover lines\n\n# STEP1 use modulo to do something every tenth\n$ echo {1..200} |tr \\  \\\\n |\\\n    awk '{a[NR%10]=$0; if (NR%10==0) {print \"ten\"} }' | cat -n\n     1  ten\n     2  ten\n     3  ten\n     4  ten\n     5  ten\n     6  ten\n     7  ten\n     8  ten\n     9  ten\n    10  ten\n    11  ten\n    12  ten\n    13  ten\n    14  ten\n    15  ten\n    16  ten\n    17  ten\n    18  ten\n    19  ten\n    20  ten\n\n# STEP 2 do something with every line\n$ echo {1..10} | tr \\  \\\\n | awk '{ b+=$0} END {print b}'\n55\n\n# putting it together\n$ cat every10.awk\n{\n        a[NR%10]=$0;\n        if (NR%10==0) {\n                for (i in a) {\n                        printf \"%s+\", a[i]\n                        b+=a[i];\n                }\n                print \"0=\" b;\n                b=0\n        }\n}\n$ echo {1..200} | tr \\  \\\\n | awk -f every10.awk  | column -s= -t\n4+5+6+7+8+9+10+1+2+3+0                     55\n14+15+16+17+18+19+20+11+12+13+0            155\n24+25+26+27+28+29+30+21+22+23+0            255\n34+35+36+37+38+39+40+31+32+33+0            355\n44+45+46+47+48+49+50+41+42+43+0            455\n54+55+56+57+58+59+60+51+52+53+0            555\n64+65+66+67+68+69+70+61+62+63+0            655\n74+75+76+77+78+79+80+71+72+73+0            755\n84+85+86+87+88+89+90+81+82+83+0            855\n94+95+96+97+98+99+100+91+92+93+0           955\n104+105+106+107+108+109+110+101+102+103+0  1055\n114+115+116+117+118+119+120+111+112+113+0  1155\n124+125+126+127+128+129+130+121+122+123+0  1255\n134+135+136+137+138+139+140+131+132+133+0  1355\n144+145+146+147+148+149+150+141+142+143+0  1455\n154+155+156+157+158+159+160+151+152+153+0  1555\n164+165+166+167+168+169+170+161+162+163+0  1655\n174+175+176+177+178+179+180+171+172+173+0  1755\n184+185+186+187+188+189+190+181+182+183+0  1855\n194+195+196+197+198+199+200+191+192+193+0  1955\n\n</pre> <p> Idenya di sini adalah menggunakan blok cetak awk dari sepuluh baris dan memprosesnya, atau memproses dengan awk secara langsung jika operasi aritmatika sederhana atau operasi string. </p>","votes":"0","source":"https://superuser.com/a/507544","author":"<a href=\"https://superuser.com/users/86129/%d0%af%d1%80%d0%be%d1%81%d0%bb%d0%b0%d0%b2-%d0%a0%d0%b0%d1%85%d0%bc%d0%b0%d1%82%d1%83%d0%bb%d0%bb%d0%b8%d0%bd\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Ярослав Рахматуллин</span></a>","replies":[]}]}
