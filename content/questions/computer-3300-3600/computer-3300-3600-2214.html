{"title":"Apa itu perintah Linux untuk menemukan file yang berisi beberapa string tetapi tidak yang lain?","draft":false,"url":"/apa-itu-perintah-linux-untuk-menemukan-file-yang-berisi-beberapa-string-tetapi-tidak-yang-lain-fghqohoc","votes":"4","answers_count":"4","categories":["Komputer"],"tags":["string","grep","xargs"],"snippet":"Saya mencoba mencari banyak file XML untuk string tertentu tetapi tidak untuk string lain, dan saya mengalami masalah dalam menyusun perintah untuk melakukannya. Saya hanya ingin daftar nama file yang cocok dengan...","body":"<p> Saya mencoba mencari banyak file XML untuk string tertentu tetapi tidak untuk string lain, dan saya mengalami masalah dalam menyusun perintah untuk melakukannya. Saya hanya ingin daftar nama file yang cocok dengan kriteria penyertaan / pengecualian. Saya sudah mencoba: </p> <pre><code>find . -name *.xml -exec grep -li \"string1\\|string2\" {} \\; | xargs grep -Li \"string3\\|string4\"\n</code></pre> <p> Tetapi saya mengalami masalah karena nama file yang dikembalikan dari <a href=\"http://en.wikipedia.org/wiki/Find_%28command%29\" rel=\"nofollow noopener\" target=\"_blank\"> Temukan </a> memiliki spasi dalam nama mereka dan yang kedua <a href=\"http://en.wikipedia.org/wiki/Grep\" rel=\"nofollow noopener\" target=\"_blank\"> grep </a> memecah semuanya menjadi potongan-potongan kecil dan tentu saja tidak menemukan file seperti itu. Saya sudah mencoba menambahkan <code>-0</code> ke file <a href=\"http://en.wikipedia.org/wiki/Xargs\" rel=\"nofollow noopener\" target=\"_blank\"> xargs </a> , dan menghapus kesalahan, tetapi dikatakan &quot;Nama file terlalu panjang&quot; dan hanya menjalankan grep pertama. </p>\n\n<p> Bagaimana cara mengubah perintah ini agar berfungsi dengan baik pada file dengan spasi di namanya? </p>","source":"https://superuser.com/questions/296536/what-is-a-linux-command-to-find-files-containing-some-strings-but-not-another","author":"<a href=\"https://superuser.com/users/85812/cicerone-cojocaru\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Cicerone Cojocaru</span></a>","replies":[{"reply":"Bukankah ini milik pengguna super?","author":"User"},{"reply":"bash scripting terkait dengan pemrograman dan pemeliharaan sistem, jadi menurut saya itu milik di situs mana pun.","author":"<a href=\"https://superuser.com/users/36873/aioobe\" target=\"_blank\" rel=\"nofollow noopener\">aioobe</a>"},{"reply":"Tidak pada kotak unix saat ini, tetapi saya kira (dengan asumsi GNU grep), Anda dapat mencoba sesuatu seperti <code>find . -name &quot;*.xml&quot; -exec grep -liZ &quot;string1\\|string2&quot; {} \\; | xargs -0 grep -Li &quot;string3\\|string4&quot;</code> (Bendera <code>Z</code> hingga <code>grep</code> tidak mengeluarkan terminator pada daftar hasilnya, yang seharusnya kompatibel dengan <code>xargs -0</code>)","author":"<a href=\"https://superuser.com/users/68807/matt-gibson\" target=\"_blank\" rel=\"nofollow noopener\">Matt Gibson</a>"},{"reply":"@pilcrow Itu tidak akan berfungsi dalam keadaan ini, karena -print0 hanya akan mencetak nama file, tidak hanya memilih nama file yang cocok dengan grep pertama. Ini adalah output dari grep pertama yang melewati pipa, itulah mengapa menurut saya tanda -Z itulah yang dibutuhkan. Sulit dikatakan tanpa kotak untuk dimainkan :)","author":"<a href=\"https://superuser.com/users/68807/matt-gibson\" target=\"_blank\" rel=\"nofollow noopener\">Matt Gibson</a>"},{"reply":"@ Mat, ya, dan ada lebih dari satu cara untuk melakukannya. :)","author":"<a href=\"https://superuser.com/users/27582/pilcrow\" target=\"_blank\" rel=\"nofollow noopener\">pilcrow</a>"},{"reply":"@pilcrow Selalu ada! :)","author":"<a href=\"https://superuser.com/users/68807/matt-gibson\" target=\"_blank\" rel=\"nofollow noopener\">Matt Gibson</a>"}],"answers":[{"answer":"<p> Ada lebih dari satu cara untuk melakukannya. Ini harus menjaga jumlah proses yang dijalankan seminimal mungkin: </p> <pre><code>find . -name \\*.xml -print0          \\   # List of *.xml files (NUL-terminated)\n  | xargs -0 grep -Zli 'string[12]'  \\   # is input to first grep, which sends (NUL-term'd)\n  | xargs -0 grep -Li  'string[34]'      # file list to second grep\n</code></pre> <p> Terima kasih <a href=\"https://stackoverflow.com/users/300836/\" target=\"_blank\" rel=\"nofollow noopener\"> Matt Gibson </a> untuk mengingatkan kita tentang flag <code>-Z</code> ke GNU grep. </p>","votes":"3","source":"https://superuser.com/a/296538","author":"<a href=\"https://superuser.com/users/27582/pilcrow\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">pilcrow</span></a>","replies":[{"reply":"Ya, itu metode yang bagus. @Cicerone - perhatikan juga bahwa @pilcrow dan saya sama-sama berasumsi bahwa Anda perlu keluar dari <code>*.xml</code> entah bagaimana untuk menghindari perluasan shell.","author":"<a href=\"https://superuser.com/users/68807/matt-gibson\" target=\"_blank\" rel=\"nofollow noopener\">Matt Gibson</a>"},{"reply":"Yang ini juga berfungsi dan sangat cepat!","author":"User"}]},{"answer":"<p> Anda dapat melakukan semuanya dalam satu <code>find</code> yang menghindari semua masalah dengan spasi di nama file. Sesuatu seperti </p> <pre><code>find . -exec grep -liq \"string1\\|string2\" {} \\; -not -exec grep -liq \"string3\\|string4\" {} \\; -print\n</code></pre> <p> The &quot;-q&quot; menekan semua keluaran grep. Primer <code>-exec</code> mengembalikan nilai true ketika proses keluar dengan status 0, seperti yang dilakukan grep ketika menemukan kecocokan, dan primer <code>-not</code> membalikkannya. Jadi kami langsung menempatkan dua ketentuan pada <code>find</code>, dan sebagai hasilnya kami hanya mencetak nama file yang memenuhi keduanya - tidak perlu pipa! </p>","votes":"3","source":"https://superuser.com/a/296537","author":"<a href=\"https://superuser.com/users/72514/ernest-friedman-hill\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Ernest Friedman-Hill</span></a>","replies":[{"reply":"Saya baru saja mengerjakan detailnya saat jawaban Anda muncul.","author":"User"},{"reply":"Maaf @ Colin. Saya benci ketika itu terjadi pada saya :)","author":"<a href=\"https://superuser.com/users/72514/ernest-friedman-hill\" target=\"_blank\" rel=\"nofollow noopener\">Ernest Friedman-Hill</a>"},{"reply":"+1 untuk solusi di mana sangat mungkin bahwa file tersebut masih dalam cache disk saat grep kedua mulai berfungsi.","author":"<a href=\"https://superuser.com/users/41337/ole-tange\" target=\"_blank\" rel=\"nofollow noopener\">Ole Tange</a>"}]},{"answer":"<p> Seperti yang disebutkan dalam komentar saya, saya pikir semua yang Anda lewatkan adalah tanda -Z pada <code>grep</code> pertama yang mengikuti -0 yang Anda coba pada <code>xargs</code> Anda: </p> <pre><code>find . -name \"*.xml\" -exec grep -liZ \"string1\\|string2\" {} \\; | xargs -0 grep -Li \"string3\\|string4\"\n</code></pre>","votes":"2","source":"https://superuser.com/a/296539","author":"<a href=\"https://superuser.com/users/68807/matt-gibson\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Matt Gibson</span></a>","replies":[]},{"answer":"<p> Jika faktor pembatasnya adalah CPU (yaitu disk Anda cepat) dan Anda memiliki lebih banyak inti CPU, Anda dapat menggunakan GNU Parallel: </p> <pre><code>find . -type f| parallel grep -Lq foo {} '||' grep -l bar {}\n</code></pre> <p> Dengan menjalankan dua <code>grep</code> segera setelah satu sama lain, kemungkinan besar file tersebut masih dalam cache disk. Jika pencarian disk lambat, Anda dapat menambahkan <code>-j1</code> untuk menonaktifkan paralelisme. </p>\n\n<p> Tonton video intro untuk mempelajari lebih lanjut: <a href=\"http://www.youtube.com/watch?v=OpaiGYxkSuQ\" rel=\"nofollow noopener\" target=\"_blank\"> http://www.youtube.com/watch?v=OpaiGYxkSuQ </a></p>","votes":"0","source":"https://superuser.com/a/297043","author":"<a href=\"https://superuser.com/users/41337/ole-tange\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Ole Tange</span></a>","replies":[]}]}
