{"title":"Pengalihan file vs dd","draft":false,"url":"/pengalihan-file-vs-dd-zbyi5qio","votes":"4","answers_count":"2","categories":["Komputer"],"tags":["bash","dd","pipe"],"snippet":"Misalkan saya ingin menyalurkan output dari beberapa perintah ke dalam file. Apakah ada perbedaan, betapapun kecil atau bernuansa, antara hanya ... yah, menyalurkannya ke file seperti  some-command &gt; file  dan menyalurkannya melalui...","body":"<p> Misalkan saya ingin menyalurkan output dari beberapa perintah ke dalam file. Apakah ada perbedaan, betapapun kecil atau bernuansa, antara hanya ... yah, menyalurkannya ke file seperti </p> <pre><code>some-command &gt; file\n</code></pre> <p> dan menyalurkannya melalui <code>dd</code> suka </p> <pre><code>some-command | dd $MAYBE_SOME_OPTIONS_LIKE_BS of=file\n</code></pre> <p> Pertanyaan ini terutama untuk memuaskan rasa ingin tahu saya, dan kecuali bentuk yang terakhir memiliki beberapa manfaat atau kasus penggunaan yang tidak dapat diabaikan, dalam praktiknya saya akan mengampuni latihan dengan jari saya dan memilih yang pertama. </p>","source":"https://superuser.com/questions/1470608/file-redirection-vs-dd","author":"<a href=\"https://superuser.com/users/606750/mona-the-monad\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Mona the Monad</span></a>","replies":[],"answers":[{"answer":"<h3 class=\"h5\"> Akses langsung ke <code>file</code> </h3>\n\n<blockquote> <pre><code>some-command &gt; file\nsome-command | dd $MAYBE_SOME_OPTIONS_LIKE_BS of=file\n</code></pre> </blockquote>\n\n<p> Dalam kasus pertama <code>some-command</code> mengetahuinya menulis ke <code>file</code>, sehingga dapat mengambil metadata (seperti mtime atau size) untuk alasan apa pun. Metadata semacam itu memiliki arti yang berguna untuk file biasa tetapi untuk pipa tanpa nama, metadata tersebut tidak ada artinya. </p>\n\n<p> <code>some-command</code> bahkan mungkin tertarik untuk membuka apa yang ditunjukkan stdout-nya untuk membaca, yang cukup aman untuk file biasa dan jelas bukan hal yang benar untuk dilakukan dalam kasus kedua Anda. </p>\n\n<p> Tapi skenario ini sangat jarang, saya kira. </p>\n\n<hr>\n\n<h3 class=\"h5\"> Dicari vs tidak dicari </h3>\n\n<p> Perilaku <code>some-command</code> mungkin bergantung pada apakah stdoutnya dapat dicari atau tidak. Biasanya tidak demikian, meskipun mungkin saja. File biasa dapat dicari (Anda dapat membaca / menulis di lokasi mana pun). Pipa tidak bisa dicari. </p>\n\n<p> <code>dd</code> sendiri adalah contoh yang valid. Pertimbangkan <code>some-command</code> menjadi <code>dd if=/dev/zero bs=1 count=1 seek=1</code>. Kedua contoh Anda menjadi: </p> <pre><code>dd if=/dev/zero bs=1 count=1 seek=1 &gt; file\ndd if=/dev/zero bs=1 count=1 seek=1 | dd of=file\n</code></pre> <p> Perintah pertama akan berfungsi, itu akan meninggalkan <code>file</code> dengan dua byte nol di dalamnya. Pada perintah kedua, <code>dd</code> yang pertama akan mengeluh bahwa ia tidak dapat mencari, ia akan keluar; <code>dd</code> kedua tidak akan mendapatkan apa-apa, tidak menulis apa-apa dan keluar tanpa kesalahan. </p>\n\n<p> Saya akui dengan <code>seek</code> ini tidak benar-benar biasa &quot;menyalurkan output dari beberapa perintah ke dalam file&quot;. Tetapi secara umum <code>some-command</code> dapat mendeteksi jika stdout-nya dapat dicari dan kemudian mengalirkan keluaran yang berbeda <em> tanpa </em> sebenarnya mencari. Fungsi shell ini melakukannya sebagai bukti konsep: </p> <pre><code>is-seekable() {\n  if &lt;/dev/null dd bs=1 count=0 seek=1 conv=notrunc 2&gt;/dev/null; then\n    echo seekable\n  else\n    echo non-seekable\n  fi\n  }\n</code></pre> <p> Coba ini dan periksa file setelah masing-masing: </p> <pre><code>is-seekable &gt; file\nis-seekable | dd of=file\n</code></pre> <hr>\n\n<p> Mengetahui semua hal di atas, ada skenario di mana saya akan mempertimbangkan perintah kedua Anda: jika <code>some-command</code> memang berperilaku berbeda dalam dua kasus (seperti fungsi <code>is-seekable</code> kami) dan saya ingin &quot;berpikir&quot; itu menulis ke pipa tetapi saya ingin output masuk file. Kalau begitu ya. Meskipun saya lebih suka menggunakan <code>cat</code> daripada <code>dd</code> (mungkin tidak masalah). Misalnya. Saya mungkin ingin mendapatkan <code>non-seekable</code> dari <code>is-seekable</code> dan menuliskannya ke sebuah file: </p> <pre><code>is-seekable | cat &gt; file\n</code></pre> <p> Tetapi hanya jika itu membuat perbedaan. Jika tidak, itu akan menjadi (dalam) &quot;penggunaan tidak berguna tahun <code>cat</code>&quot; yang terkenal. Atau dalam kasus Anda &quot;penggunaan <code>dd</code> yang tidak berguna&quot;; atau bahkan &quot;penggunaan berbahaya&quot; jika Anda menangani status keluar dengan buruk. </p>\n\n<hr>\n\n<h3 class=\"h5\"> Status keluar </h3>\n\n<p> Sekarang coba dua contoh ini: </p> <pre><code>false &gt; file\nfalse | dd of=file\n</code></pre> <p> Jika Anda memeriksa <code>$?</code> setelah yang kedua, Anda akan menemukan <code>0</code> (kecuali <code>dd</code> gagal). Kasus kedua Anda membuang status keluar <code>some-command</code> (biasanya; misalnya dalam investigasi Bash <code>set -o pipefail</code>, yang tidak portabel). </p>\n\n<p> Jadi dalam kasus kedua <code>some-command</code> mungkin gagal karena alasan apa pun dan Anda (atau lebih tepatnya logika skrip Anda) tidak akan mengetahuinya. Ini cukup untuk <em> menghindari </em> pemipaan yang tidak perlu ke <code>dd</code> (atau pemipaan yang tidak perlu sama sekali). </p>\n\n<hr>\n\n<h3 class=\"h5\"> Izin </h3>\n\n<p> Nuansa lain: <code>some-command &gt; file</code> membuat (sub) shell membuka file sebelum <code>some-command</code> muncul (dieksekusi ke); <code>dd of=file</code> membuka file atas namanya sendiri. </p>\n\n<p> Ada cara untuk memberikan lebih banyak hak akses ke <code>some-command</code> daripada perintah &quot;biasa&quot; lainnya. Dengan kata lain ada cara untuk membuat <code>dd</code> biasa berperilaku lebih seperti <code>sudo dd</code> tanpa kata sandi. Anda tidak boleh melakukannya dan mudah-mudahan tidak ada yang melakukannya, namun itu mungkin. </p>\n\n<p> Apa yang dapat Anda lakukan adalah memberikan hak akses sesuai permintaan: <code>sudo dd</code>. Ini dapat berguna saat mencoba menulis ke file terbatas. Analisa ini: </p> <pre><code>some-command &gt; restricted_file               # doesn't work\nsudo some-command &gt; restricted_file          # doesn't work\nsome-command | sudo dd &gt; restricted_file     # doesn't work\nsudo sh -c 'some_command &gt; restricted_file'  # works, but it runs some_command as root\n                                             #  you may not want this\nsome-command | sudo dd of=restricted_file    # works\nsome-command | sudo tee restricted_file      # works, more common, possibly with\n                                             #  &gt; /dev/null to suppress output to tty\n</code></pre> <p> Saya pikir ini sangat dekat dengan &quot;manfaat atau kasus penggunaan yang tidak dapat diabaikan&quot;. </p>\n\n<hr>\n\n<h3 class=\"h5\"> Mungkin beberapa pilihan </h3>\n\n<p> Jelas, <code>$MAYBE_SOME_OPTIONS_LIKE_BS</code> dapat mengubah perilaku <code>dd</code>. Saya memahami bahwa opsi seperti <code>conv=swab</code> berada di luar jangkauan karena Anda ingin <code>file</code> menerima data yang sama dalam kedua kasus. </p>\n\n<p> Masih ada beberapa opsi yang dapat membuat perbedaan. Contoh: </p>\n\n<ul>\n<li><p> <code>status=progress</code> akan mencetak statistik kecepatan transfer dan volume pada stderr, saat memproses setiap blok masukan; </p></li>\n<li><p> <code>oflag=noatime</code> tidak akan memperbarui stempel waktu akses file; </p></li>\n<li><p> <code>oflag=nolinks</code> akan gagal jika file tersebut memiliki banyak tautan keras; </p></li>\n<li><p> dan <a href=\"https://www.gnu.org/software/coreutils/manual/html_node/dd-invocation.html#dd-invocation\" rel=\"nofollow noopener\" target=\"_blank\"> lebih </a> . </p></li>\n</ul>\n\n<p> Contoh di atas adalah ekstensi GNU, bukan portabel. Portabel <code>dd</code> dicirikan <a href=\"https://pubs.opengroup.org/onlinepubs/9699919799/utilities/dd.html\" rel=\"nofollow noopener\" target=\"_blank\"> sini </a> . </p>\n\n<hr>\n\n<h3 class=\"h5\"> CIUMAN </h3>\n\n<p> Akhirnya ada <a href=\"https://en.wikipedia.org/wiki/KISS_principle\" rel=\"nofollow noopener\" target=\"_blank\"> Prinsip KISS </a> : tetap sederhana dan bodoh. Kasus pertama Anda sangat sederhana. </p>","votes":"5","source":"https://superuser.com/a/1470733","author":"<a href=\"https://superuser.com/users/432690/kamil-maciorowski\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Kamil Maciorowski</span></a>","replies":[{"reply":"Jawaban yang sangat detail untuk pertanyaan kecil! Satu hal lagi yang saya ingin tahu adalah cara file dialokasikan (jika ada perbedaan sama sekali). Saya tahu pada filesystem seperti <code>ext4</code>, itu tidak terlalu penting, tetapi di mana pun itu akan atau mungkin penting, bagaimana jika saya melakukan sesuatu seperti, katakanlah, beri <code>dd</code> ukuran blok (itulah sebabnya saya mengisyaratkan itu)? Jelas, jika saya benar-benar ingin mengalokasikan file sebelumnya, saya akan menggunakan <code>fallocate</code> atau sesuatu.","author":"<a href=\"https://superuser.com/users/606750/mona-the-monad\" target=\"_blank\" rel=\"nofollow noopener\">Mona the Monad</a>"}]},{"answer":"<p> Tidak ada pengguna yang melihat adanya perbedaan. Dari sudut pandang kinerja, keraguan akan ada perbedaan juga. Jika Anda memikirkan kedua skenario tersebut, ada pro dan kontra tetapi ini sangat bergantung pada apa yang ingin Anda capai. </p>\n\n<p> Sebagai contoh:\nfile kucing | dd of = file2 vs cat file&gt; file2.\nPerbedaannya di sini adalah, cat akan membuka file, dd akan mewarisi aliran kecuali Anda menentukan ukuran blok atau semacam bendera penulisan, itu akan mulai menulis ke tumpukan fs segera. </p>\n\n<p> Jika Anda tidak menggunakan fitur apa pun dari dd, Anda cukup banyak hanya mencari perantara, menambahkan proses, garpu ganda ini saya asumsikan akan memiliki kerugian kinerja minimal vs hanya membiarkan dd menangani if ​​= file of = newfile. Keuntungannya, dalam hal ini, Anda dapat mencari / melewati di dd dan yah, hanya ada satu proses. </p>\n\n<p> Jika yang Anda maksud hanyalah pengalihan file vs dd, saya akan mengatakan tidak ada perbedaan jika Anda tidak menyediakan dd dengan flag / parameter apa pun. Anda dapat menggunakan dalam kasus ini sebagai penyangga perantara, tetapi ada alternatif yang lebih baik, misalnya:\nfile kucing | penyangga | gzip&gt; konten gzip.\nMisalnya, panggilan bertumpuk di atas, katakanlah Anda memiliki sumber super cepat, dan tujuan yang lambat, dengan buffer di antara Anda dapat memastikan sisi penerima selalu memiliki antrian masukan yang sibuk, dan jika Anda mengompresi Anda dapat pastikan CPU Anda tidak menunggu IO. </p>\n\n<p> Sekali lagi, semua kasus tepi, itu akan membutuhkan pertanyaan terpisah, tetapi seperti yang Anda lihat, jika kita berbicara secara tegas dari satu vs yang lain, bahkan jika ada perbedaan, keraguan itu akan terlihat kecuali untuk kasus tepi ekstrim. </p>\n\n<p> Semoga ini bisa membantu, pertanyaan ini cukup menarik untuk saya katakan, butuh waktu beberapa saat untuk memikirkannya. </p>","votes":"1","source":"https://superuser.com/a/1470651","author":"<a href=\"https://superuser.com/users/464862/ddemuro\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">ddemuro</span></a>","replies":[{"reply":"+1 untuk penyebutan <code>buffer</code>, karena saya lupa bahwa itu adalah sesuatu.","author":"<a href=\"https://superuser.com/users/606750/mona-the-monad\" target=\"_blank\" rel=\"nofollow noopener\">Mona the Monad</a>"},{"reply":"Ngomong-ngomong, pada sistem tanpa <code>buffer</code>, dapatkah <code>dd</code> dengan ukuran blok bertindak sebagai solusi peretasan sementara?","author":"<a href=\"https://superuser.com/users/606750/mona-the-monad\" target=\"_blank\" rel=\"nofollow noopener\">Mona the Monad</a>"},{"reply":"Sebenarnya ya, Anda harus bisa menggunakan ukuran blok sebagai buffer yang benar-benar hacky. Saya akan menyarankan untuk tidak melakukannya karena itu tidak akan benar-benar menambah banyak kinerja dan buffer adalah solusi yang lebih cocok. Saya suka pertanyaannya lol benar-benar membuat saya banyak berpikir. Cara terbaik yang pernah saya lihat jenis pemipaan ini digunakan adalah sehubungan dengan <code>pv</code> untuk melihat kemajuan. Juga saat mengompresi aliran, buffer dan pv menjadi sangat berguna.","author":"<a href=\"https://superuser.com/users/464862/ddemuro\" target=\"_blank\" rel=\"nofollow noopener\">ddemuro</a>"},{"reply":"Apa yang membuat <code>buffer</code> lebih cepat? Semacam quirk pengoptimalan tingkat rendah?","author":"<a href=\"https://superuser.com/users/606750/mona-the-monad\" target=\"_blank\" rel=\"nofollow noopener\">Mona the Monad</a>"},{"reply":"Benar, <code>dd</code> memiliki lebih banyak struktur kontrol daripada <code>buffer</code>. Meski begitu, jika ada yang bisa melihat perbedaannya, saya akan sangat terkejut. Saya kira saya lebih suka motto Linux memiliki aplikasi khusus untuk penggunaan tertentu. Membiasakan diri dengan buffer dan dd untuk tujuan mereka menurut saya adalah yang terbaik. Jangan lupa bahwa dengan <code>buffer</code> Anda mendapatkan parameter yang sangat berguna untuk mengelolanya dengan tepat. Dengan <code>dd</code> Anda semacam palu paku dengan obeng.","author":"<a href=\"https://superuser.com/users/464862/ddemuro\" target=\"_blank\" rel=\"nofollow noopener\">ddemuro</a>"}]}]}
