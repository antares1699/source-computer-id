{"title":"Per byte akses memori RAM","draft":false,"url":"/per-byte-akses-memori-ram-nhy7e0nr","votes":"4","answers_count":"5","categories":["Komputer"],"tags":["64-bit","memory"],"snippet":"Saya hanya punya pertanyaan sederhana. Saat ini chip DDR memori berukuran 64 bit, dan bus data CPU juga memiliki lebar 64 bit. Tetapi memori masih diatur dalam satu byte. Jadi, yang ingin...","body":"<p> Saya hanya punya pertanyaan sederhana. Saat ini chip DDR memori berukuran 64 bit, dan bus data CPU juga memiliki lebar 64 bit. Tetapi memori masih diatur dalam satu byte. Jadi, yang ingin saya tanyakan adalah, ketika CPU memilih beberapa alamat memori, seharusnya satu byte, bukan? Karena porsi memori terendah yang dapat Anda akses adalah 1 byte. Tetapi, jika Anda mendapatkan 1 byte per 1 alamat, mengapa bus memori lebar 8 byte? </p>","source":"https://superuser.com/questions/138800/per-bytes-ram-memory-acess","author":"<a href=\"https://superuser.com/users/32569/user32569\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">user32569</span></a>","replies":[],"answers":[{"answer":"<p> Kami menyebut arsitektur komputer kami sebagai <a href=\"http://en.wikipedia.org/wiki/Memory_address\" rel=\"nofollow noopener\" target=\"_blank\"> <code>byte-addressable</code> </a> - artinya, memori dialamatkan sebagai byte. Itu membantu kami menarik 8-bit data dalam satu waktu. Tapi, itu tidak selalu menjadi norma, dan lebar lainnya digunakan. </p>\n\n<p> Bahkan ketika Anda menggunakan komputer alamat-byte berbasis Intel, memori yang Anda gunakan biasanya diakses dengan lebar yang berbeda (64 bit seperti pada contoh Anda). </p>\n\n<p> Ini membantu dalam menangani jumlah data yang lebih besar dengan ruang alamat yang lebih sedikit. </p>\n\n<p> Jawaban saya sebenarnya selesai di sini, namun, saya mengoceh lebih lanjut untuk berbicara tentang bagaimana akses memori dilakukan yang mungkin membantu memikirkan tentang abstraksi yang diterapkan (dan mungkin juga memotivasi Anda untuk membaca lebih banyak tentang kenangan). </p>\n\n<hr>\n\n<p> Jika Anda telah melihat tongkat DDR-RAM, Anda pasti ingat melihat beberapa chip pada PCB hijau. Ini bergaris bersama untuk akses paralel. Itu membuat akses RAM Anda lebih cepat. </p>\n\n<p> Di depan modul RAM adalah Pengontrol Memori. Ini dirancang untuk mengakses data dalam lebar bit yang lebih lebar (32, 64, 128 bit - tergantung pada desain). </p>\n\n<p> Ketika Anda mengakses satu byte dari ruang memori ini, pengontrol memori benar-benar mendapatkan &quot;kata memori&quot; yang lengkap; di sini, sebuah kata sebenarnya adalah lebar akses ini dari pengontrol memori. </p>\n\n<p> Yang berarti jika lebarnya 128 bit, Anda selalu mengambil 16 byte dari alamat yang merupakan kelipatan 16. </p>\n\n<p> Jadi, sekarang apa yang terjadi jika Anda menginginkan byte di alamat 18 (= 16 + 2)? <br> Nah, Anda mendapatkan 16 byte dari alamat 16 dan membuang 15 di antaranya! </p>\n\n<p> Lebih menarik lagi, apa yang terjadi jika Anda ingin menulis satu byte pada alamat 19? <br> Anda mengambil 16 byte dari alamat 16, mengubah byte ke-3 (alamat ke-19), dan kemudian menulis kembali semua 16 byte ini (menyenangkan ya?). </p>\n\n<p> Semua ini cukup sulit. Pengontrol memori dirancang untuk mengelola ini dan bekerja pada beberapa permintaan secara paralel. </p>\n\n<p> Kita bahkan belum membicarakan tentang &#39;saluran ganda&#39; <code>:-)</code> </p>\n\n<hr>\n\n<p> Berikut adalah referensi dari Wikipedia tentang <a href=\"http://en.wikipedia.org/wiki/DDR_SDRAM#Organization\" rel=\"nofollow noopener\" target=\"_blank\"> Organisasi DDR SDRAM </a></p>\n\n<blockquote>\n  <p> PC3200 adalah DDR SDRAM yang dirancang untuk beroperasi pada 200 MHz menggunakan chip DDR-400 <br> dengan bandwidth 3.200 MB / s. Saat memori dipompa ganda, <br> ini berarti clock rate efektif memori PC3200 adalah 400 MHz. </p>\n  \n  <p> Modul non-ECC 1 GB PC3200 biasanya dibuat dengan enam belas chip 512 Mbit, <br> 8 di setiap sisi (512 Mbits × 16 chip) / (8 bits (per byte)) = 1.024 MB. <br> Chip individu yang membentuk modul memori 1 GB biasanya <br> diatur dengan 64 Mbits dan lebar data 8 bit untuk setiap chip, <br> umumnya dinyatakan sebagai 64M × 8. </p>\n  \n  <p> Memori yang diproduksi dengan cara ini adalah RAM dengan kepadatan rendah dan biasanya akan <br> kompatibel dengan motherboard apa pun yang menetapkan memori PC3200 DDR-400. </p>\n</blockquote>\n\n<p> Dari <a href=\"http://en.wikipedia.org/wiki/Memory_controller#Purpose\" rel=\"nofollow noopener\" target=\"_blank\"> Pengontrol Memori </a> halaman </p>\n\n<blockquote>\n  <p> Lebar bus adalah jumlah garis paralel yang tersedia untuk berkomunikasi dengan sel memori. <br> Lebar bus pengontrol memori berkisar dari 8-bit di sistem sebelumnya, hingga 512-bit di sistem dan kartu video yang lebih rumit (biasanya diterapkan sebagai empat pengontrol memori simultan 64-bit yang beroperasi secara paralel, meskipun beberapa dirancang untuk beroperasi dalam &quot;mode geng &quot;di mana dua pengontrol memori 64-bit dapat digunakan untuk mengakses perangkat memori 128-bit). </p>\n</blockquote>","votes":"4","source":"https://superuser.com/a/138812","author":"<a href=\"https://superuser.com/users/263/nik\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">nik</span></a>","replies":[{"reply":"Jawaban bagus. Tapi, jika satu alamat = 8Bytes, mengapa bus 32 alamat masih bisa menggunakan memori 4GB? Bukankah seharusnya 4G * 64?","author":"<a href=\"https://superuser.com/users/32569/user32569\" target=\"_blank\" rel=\"nofollow noopener\">user32569</a>"},{"reply":"Dan ada satu hal lagi. Ketika saya melihat output dari compiler C, itu alamat misalnya kolom char bytes. Jadi, saya kira ada beberapa chip di CPU yang memeriksa instruksi selanjutnya dan jika ada Byte lain dari lokasi memorry berikutnya, itu memuat seluruh blok memori ke dalam cache?","author":"<a href=\"https://superuser.com/users/32569/user32569\" target=\"_blank\" rel=\"nofollow noopener\">user32569</a>"},{"reply":"@ b-gen, Ketika kita mengatakan byte-addressable, satu alamat selalu 8-bit (yaitu satu byte). Namun, pengontrol memori yang bekerja mengatakan lebar 64-bit akan mengambil 8 byte (lebih dari 8 alamat) bersama-sama. Namun, untuk dapat mengalamatkan (katakanlah) &#39;byte&#39; kedua dalam 8 byte tersebut, pengalamatannya masih berbasis byte. Misalnya, 8 byte berikutnya akan diakses dengan menambahkan 8 ke alamat.","author":"<a href=\"https://superuser.com/users/263/nik\" target=\"_blank\" rel=\"nofollow noopener\">nik</a>"},{"reply":"Yang benar-benar buruk adalah jika Anda memiliki data yang tidak selaras secara alami. Katakanlah Anda memiliki integer 64-bit yang dimulai pada alamat fisik 0x44. Ini menempati byte 0x44 hingga 0x4B. Tetapi 0x44 hingga 0x47 berada dalam satu &quot;kata&quot; memori dan 0x48 hingga 0x4B berada dalam satu &quot;kata&quot; memori. Membaca atau menulis sepanjang itu akan membutuhkan akses <i> dua </i> kata memori delapan byte yang berbeda. Tak perlu dikatakan, ini bisa menjadi kinerja yang sukses.","author":"<a href=\"https://superuser.com/users/348119/jamie-hanrahan\" target=\"_blank\" rel=\"nofollow noopener\">Jamie Hanrahan</a>"},{"reply":"@JamieHanrahan meskipun saya bukan ahli dalam hal ini, saya berasumsi bahwa ini adalah alasan yang sama mengapa akses memori yang tidak selaras menyebabkan kinerja tinggi pada GPU.","author":"<a href=\"https://superuser.com/users/628467/tara\" target=\"_blank\" rel=\"nofollow noopener\">Tara</a>"},{"reply":"@Dudeson ya, memang.","author":"<a href=\"https://superuser.com/users/348119/jamie-hanrahan\" target=\"_blank\" rel=\"nofollow noopener\">Jamie Hanrahan</a>"}]},{"answer":"<p> Lebih cepat mentransfer sejumlah besar data 8 byte sekaligus daripada 1. Selain itu, tidak ada cara untuk benar-benar mengatasi byte tunggal di luar cache CPU karena beberapa bit alamat terakhir tidak memiliki koneksi fisik lagi (karena mereka tidak dibutuhkan). </p>","votes":"2","source":"https://superuser.com/a/138802","author":"<a href=\"https://superuser.com/users/26316/ignacio-vazquez-abrams\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Ignacio Vazquez-Abrams</span></a>","replies":[{"reply":"Ok, jadi jika saya mengerti, Anda mengatakan bahwa sekarang, lebar data akses RAM minimal adalah 8 byte per alamat, dan kompatibilitasnya dipertahankan melalui cache CPU? Tapi, bagaimana dengan skenario ini ?: Saya ingin menyimpan 1 byte ke dalam RAM, jadi saya menyimpannya ke dalam cache CPU. Tapi, dari cache harus menuliskannya ke dalam memori. (misalnya jika saya ingin beralih ke multitask). Jadi masih harus menulis 1 byte. Bagaimana jika itu tidak dapat alamat hanya 8 byte pada saat itu?","author":"<a href=\"https://superuser.com/users/32569/user32569\" target=\"_blank\" rel=\"nofollow noopener\">user32569</a>"},{"reply":"BTW: Apakah Anda 100% yakin tentang apa yang Anda tulis? Karena, mereka tidak akan menambahkan ekstensi alamat Fisik jika beberapa bit alamat terputus karena sel data 8 byte.","author":"<a href=\"https://superuser.com/users/32569/user32569\" target=\"_blank\" rel=\"nofollow noopener\">user32569</a>"},{"reply":"Untuk menulis satu byte, ia perlu membaca kumpulan 8 byte yang ada, memodifikasi satu byte, lalu menulis semua 8 sekaligus. PAE bekerja dengan menambahkan bit alamat pada file <i> lain </i> akhir.","author":"<a href=\"https://superuser.com/users/26316/ignacio-vazquez-abrams\" target=\"_blank\" rel=\"nofollow noopener\">Ignacio Vazquez-Abrams</a>"},{"reply":"PAE hanya menambahkan beberapa bit tingkat tinggi ke kemungkinan alamat fisik. Tiga bit orde rendah tetap tidak terhubung ke bus RAM. Faktanya, jika Anda melihat pinout pada CPU modern yang memiliki alamat dan pin data terpisah, Anda akan menemukan pin alamat mulai dari A3 - tidak ada pin untuk A0, A1, atau A2. RAM hanya dapat dialamatkan dalam apa yang dilihat CPU sebagai potongan delapan-byte (dan ini selalu diselaraskan pada batas-batas 8-byte).","author":"<a href=\"https://superuser.com/users/348119/jamie-hanrahan\" target=\"_blank\" rel=\"nofollow noopener\">Jamie Hanrahan</a>"}]},{"answer":"<p> Saya berbicara tanpa keahlian yang hebat tetapi secara kasar ... </p>\n\n<p> Prosesor mengambil satu kata dalam satu waktu (yaitu prosesor 64 bit mengambil 8 byte pada satu waktu). Namun ketika mengambil satu byte, mereka secara efektif membuang 7 byte lainnya. Skema pengalamatan memori biasanya masih dianggap sebagai byte, tetapi jika Anda menarik data secepat mungkin, Anda menggunakan alamat yang disesuaikan dengan kata, yaitu alamat yang dapat dibagi dengan panjang kata dalam byte. Dalam sistem 64 bit Anda akan menggunakan alamat 0, 8, 16, 24, dll. </p>\n\n<p> Jika Anda menarik kata dari alamat yang tidak sesuai dengan kata, katakanlah 5, prosesor harus melakukan dua pengambilan, satu untuk byte 5, 6, 7 dan yang kedua 8, 9, 10, 11, 12, jadi itu akan memakan waktu dua kali lebih lama. </p>\n\n<p> Mengatasi byte secara individual berguna untuk semua jenis alasan, tetapi orang dapat dengan mudah membayangkan desain prosesor yang menangani pengalamatan kata sebagai gantinya. Jika Anda menginginkan byte, Anda akan mendapatkan sebuah kata, kosongkan byte yang tidak Anda inginkan, dan acak byte tersebut ke bagian bawah kata. Dengan cara itulah yang terjadi, mendapatkan byte berarti mendapatkan sebuah kata, dan kemudian mengambil satu byte darinya, lebih mudah untuk menganggapnya sebagai byte pada alamat 10 daripada kata 1, byte 3. </p>\n\n<p> Di luar CPU, RAM tidak pernah melihat bit alamat yang lebih rendah, RAM diatur sebagai kata-kata, model CPU / Programmerlah yang memberikan ilusi pengalamatan byte. </p>","votes":"1","source":"https://superuser.com/a/138809","author":"<a href=\"https://superuser.com/users/4097/christopher-edwards\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Christopher Edwards</span></a>","replies":[{"reply":"Itu tidak sepenuhnya akurat. Prosesor 32 bit kami telah menggunakan bus memori lebar 64-bit cukup lama. &quot;ukuran kata memori&quot; belum tentu sama dengan lebar register bilangan bulat CPU (yang dimaksud dengan &quot;prosesor 32 bi&quot;). Namun, sebagian besar dari yang terbaik baik-baik saja.","author":"<a href=\"https://superuser.com/users/348119/jamie-hanrahan\" target=\"_blank\" rel=\"nofollow noopener\">Jamie Hanrahan</a>"}]},{"answer":"<p> Dalam contoh Anda, saat menulis satu byte, dari sudut pandang kata memori, kata tersebut telah berubah. Anda dan saya sama-sama tahu bahwa hanya sedikit saja yang berbeda, tetapi terlepas dari itu, memori sekarang perlu disegarkan. Jadi kata itu ditulis kembali ke memori - semuanya 64 bit. Ini akan benar, tidak peduli berapa ukuran minimum memori yang dapat dialamatkan. Ketika memori memiliki lebar 8-bit, semua 8 bit akan telah ditulis meskipun mungkin hanya 1 bit yang berubah. </p>","votes":"0","source":"https://superuser.com/a/138813","author":"<a href=\"https://superuser.com/users/25944/jrobert\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">JRobert</span></a>","replies":[]},{"answer":"<p> Dari apa yang saya ingat dari hari-hari saya Assembler dan pekerjaan perangkat keras tingkat rendah, memori sebenarnya diakses di halaman. Anda tidak pernah benar-benar mengakses satu byte, atau bahkan lebar bus dari RAM, melainkan dalam blok (saya tidak dapat memberikan angka pasti — terutama karena jumlahnya bervariasi — tetapi angka 4KB terdengar sangat familiar [mungkin saya memikirkan segmen, meskipun itu 64KB]). </p>\n\n<p> Intinya adalah sangat tidak efisien untuk mengalamatkan satu byte, terutama karena alamat memori berikutnya yang akan diakses kemungkinan besar berada tepat di sebelahnya. Dengan demikian, ketika Anda mengakses satu byte, sistem menyimpan satu blok RAM (menurut Anda untuk apa berbagai cache CPU itu?) Setiap perubahan yang Anda lakukan dilakukan pada RAM yang di-cache itu, sehingga jika Anda menuliskannya kembali, itu bisa tulis blok dengan bagus dan cepat. Byte diakses dengan sendirinya, tetapi dari blok yang di-cache; artinya, CPU tidak mengambil satu byte, tetapi mengembalikan hanya satu byte. </p>\n\n<p> Dengan sistem saat ini yang jauh lebih besar, saya membayangkan bahwa mereka perlu menyimpan cache lebih banyak lagi untuk mengoptimalkan berbagai hal (karena itu cache CPU lebih besar). </p>","votes":"0","source":"https://superuser.com/a/138815","author":"<a href=\"https://superuser.com/users/3279/synetech\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Synetech</span></a>","replies":[{"reply":"Mengingat secara spesifik dalam pertanyaan, saya cenderung tidak setuju dengan penggunaan kata <code>block</code> dalam konteks ukuran 4KB dan 64KB dalam jawaban Anda. Cache-lines dan cache-memory berada pada tingkat yang berbeda dari hierarki perangkat keras. (lihat <a href=\"http://en.wikipedia.org/wiki/CPU_cache\" rel=\"nofollow noopener\" target=\"_blank\"> en.wikipedia.org/wiki/CPU_cache </a> terhadap tautan di jawaban saya)","author":"<a href=\"https://superuser.com/users/263/nik\" target=\"_blank\" rel=\"nofollow noopener\">nik</a>"},{"reply":"Saya menggunakan blok sebagai istilah umum (&quot;potongan&quot; terdengar agak aneh). Yang saya pikirkan adalah a <i> halaman </i> memori. Meskipun seperti yang saya katakan, itu sudah lama, jadi saya tidak terlalu mengingat detail persisnya. Saya akan mengeluarkan buku Assembler tua berwarna oranye itu untuk melihat apakah saya bisa mendapatkan penyegar.","author":"<a href=\"https://superuser.com/users/3279/synetech\" target=\"_blank\" rel=\"nofollow noopener\">Synetech</a>"},{"reply":"Halaman 4K adalah aspek terjemahan alamat, bukan akses memori. Dan segmen bisa lebih besar dari 64KB. Kebanyakan OS modern tidak banyak menggunakan segmen; pada kenyataannya mereka semua tidak termasuk dalam arsitektur x64.","author":"<a href=\"https://superuser.com/users/348119/jamie-hanrahan\" target=\"_blank\" rel=\"nofollow noopener\">Jamie Hanrahan</a>"}]}]}
