{"title":"Bagaimana bash menguji &#39;false&#39;?","draft":false,"url":"/bagaimana-bash-menguji-39false39-pitbqxuv","votes":"4","answers_count":"2","categories":["Komputer"],"tags":["linux","bash","conditional-statements"],"snippet":"$ false$ echo $?1$ if [[ false ]]; then echo 'do it'; fido it$ test false &amp;&amp; echo 'do it'do it$ COND=false$ echo $COND...","body":"<pre><code>$ false\n$ echo $?\n1\n\n$ if [[ false ]]; then echo 'do it'; fi\ndo it\n\n$ test false &amp;&amp; echo 'do it'\ndo it\n\n$ COND=false\n$ echo $COND\nfalse\n$ if [[ $COND -ne 0 ]]; then echo 'do it'; fi\n$ if [[ $COND -ne true ]]; then echo 'do it'; fi\n</code></pre> <p> Ini IMO omong kosong, apa yang saya lewatkan di sini? </p>\n\n<p> - Perbarui </p>\n\n<p> Jadi berikut ini adalah bagaimana kelanjutannya: </p> <pre><code>$ COND=false\n$ if ! $COND; then echo 'do it'; fi\ndo it\n$ if $COND; then echo 'do it'; fi\n</code></pre> <p> Tetapi saya ingin menggabungkan <code>$COND</code> dengan ekspresi bersyarat lainnya dalam satu ekspresi tes yang lebih besar (atau <code>[[ {expr} &amp;&amp; {expr} ]]</code>). Jadi, jika <code>$COND</code> salah, itu tidak berfungsi di dalam <code>[[ {expr} ]]</code> secara intuitif. Sepertinya <code>[[ {expr} ]]</code> agak menyesatkan ketika yang saya butuhkan lebih seperti: </p> <pre><code>$ COND=false\n$ if ! $COND &amp;&amp; test -d ${HOME}/bin ; then echo 'do it'; fi\ndo it\n</code></pre>","source":"https://superuser.com/questions/1400335/how-does-bash-test-false","author":"<a href=\"https://superuser.com/users/696718/darren-weber\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Darren Weber</span></a>","replies":[{"reply":"Melihat <a href=\"https://stackoverflow.com/q/19670061\" target=\"_blank\" rel=\"nofollow noopener\"> jawaban ini di Stack Overflow </a> .","author":"<a href=\"https://superuser.com/users/167207/giacomo1968\" target=\"_blank\" rel=\"nofollow noopener\">Giacomo1968</a>"}],"answers":[{"answer":"<p> Sintaks shell sangat bergantung pada konteks. Artinya, apa arti suatu hal (seperti <code>true</code> atau <code>false</code>) sangat bergantung pada di mana hal itu terjadi. Dalam contoh Anda, <code>false</code> memiliki tiga arti yang sangat berbeda: perintah, nilai string, dan nama variabel (tidak ada) yang berisi nilai integer. Biarkan saya menjalankan contoh: </p>\n\n<ul>\n<li><p> <code>false</code> sebagai perintah: </p> <pre><code>false; echo $?    # prints \"1\"\nif false; then echo \"yep\"; else echo \"nope\"; fi    # prints \"nope\"\n</code></pre> <p> Ada perintah bernama &quot;false&quot; (umumnya / usr / bin / false, atau bash bawaan yang melakukan hal yang sama) yang tidak benar-benar melakukan apa pun kecuali keluar dengan status gagal. Sebagai status keluar, nol menunjukkan keberhasilan (yang semacam kebenaran-seperti) dan bukan nol menunjukkan kegagalan (yang semacam palsu). Ini adalah kebalikan dari konvensi nol = salah, bukan nol = benar yang lebih umum, tetapi untuk status keluar itu lebih masuk akal. </p></li>\n<li><p> <code>false</code> sebagai nilai string yang tidak ditafsirkan: </p> <pre><code>if [[ false ]]; then echo \"yep\"; else echo \"nope\"; fi     # prints \"yep\"\nif [[ true ]]; then echo \"yep\"; else echo \"nope\"; fi      # prints \"yep\"\nif [[ wibble ]]; then echo \"yep\"; else echo \"nope\"; fi    # prints \"yep\"\nif [[ \"this is a string\" ]]; then echo \"yep\"; else echo \"nope\"; fi    # prints \"yep\"\n[[ false ]]; echo $?    # prints \"0\" (=success)\n[ false ]; echo $?      # prints \"0\" (=success)\ntest false; echo $?     # prints \"0\" (=success)\n</code></pre> <p> Dalam semua kasus ini, perintah <code>test</code> atau sinonimnya <code>[</code> atau ekspresi bersyarat bash <code>[[ ]]</code> tidak mendapatkan ekspresi, hanya satu string, jadi perintah tersebut melakukan pengujian yang sangat sederhana: apakah itu string panjang bukan-nol? &quot;true&quot;, &quot;false&quot;, &quot;wibble&quot;, dll. semuanya bukan-nol, jadi perintah / ekspresi seperti kebenaran, maka berhasil. Dibandingkan dengan: </p> <pre><code>[[ \"\" ]]; echo $?    # prints \"1\" (=failure), because the string is zero-length\n[[ ]]; echo $?       # prints \"1\" (=failure), because there isn't even a string\n[ ]; echo $?         # same\n</code></pre> <p> Perhatikan bahwa <code>test</code> dan <code>[</code> adalah perintah normal, dan &quot;false&quot; (dan &quot;wibble&quot; dll) hanyalah argumen untuk itu. <code>[[ ]]</code> adalah sedikit sintaks bash yang dapat digunakan sebagai pengganti perintah. Argumen / isinya diuraikan secara berbeda dari nama perintah itu sendiri. </p></li>\n<li><p> <code>false</code> sebagai nama variabel yang mungkin berisi bilangan bulat: </p> <pre><code>if [[ false -eq true ]]; then echo \"equal\"; else echo \"nope\"; fi     # prints \"equal\"\n</code></pre> <p> Yang ini sedikit lebih aneh, dan bergantung pada detail bagaimana bash <code>[[ ]]</code> menguji persamaan numerik. Perhatikan bahwa dalam ekspresi <code>[[ ]]</code> (dan <code>[ ]</code> dan <code>test</code>), <code>-eq</code> pengujian untuk persamaan numerik, dan <code>=</code> pengujian untuk persamaan string. Jadi misalnya, <code>[[ 01 -eq 1 ]]</code> (karena 1 dan 01 secara numerik sama) adalah benar, tetapi <code>[[ 01 = 1 ]]</code> salah (karena keduanya bukan string yang sama). Dalam kasus <code>[[ false -eq true ]]</code>, &quot;true&quot; dan &quot;false&quot; bukanlah nilai integer, jadi bash mencoba mengonversinya menjadi integer dengan memperlakukannya sebagai nama variabel (dan berharap variabel berisi nilai integer). Faktanya, tidak ada yang didefinisikan sebagai variabel, jadi keduanya mengevaluasi ke string kosong, yang dapat diartikan sebagai bilangan bulat 0. Perhatikan: </p> <pre><code>if [[ false -eq true ]]; then echo \"equal\"; else echo \"nope\"; fi     # prints \"equal\"\nif [[ false -eq 0 ]]; then echo \"equal\"; else echo \"nope\"; fi        # prints \"equal\"\nfalse=5\nif [[ false -eq true ]]; then echo \"equal\"; else echo \"nope\"; fi     # now prints \"nope\"\n</code></pre> <p> Perhatikan bahwa mendefinisikan <code>false</code> sebagai variabel tidak berpengaruh pada penggunaan lainnya; ketika digunakan sebagai perintah itu akan tetap keluar dengan status 1, dan ketika digunakan sebagai string itu masih &quot;salah&quot; (bukan &quot;5&quot;). </p></li>\n</ul>","votes":"5","source":"https://superuser.com/a/1400807","author":"<a href=\"https://superuser.com/users/7778/gordon-davisson\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Gordon Davisson</span></a>","replies":[]},{"answer":"<p> Anda tidak menjalankan perintah <code>false</code>, tetapi menggunakan <code>[[</code> (mirip dengan perintah builtin <code>test</code> dan <code>[</code>) untuk mengevaluasi ekspresi &quot;false&quot;, dan tanpa memberikan apa pun untuk mengevaluasinya, ia melakukan ini: </p>\n\n<blockquote>\n  <p> tali <br> -n string <br> True jika panjang string bukan nol. </p>\n</blockquote>\n\n<p> Lihat bagian EKSPRESI KONDISI <code>man bash</code> untuk info lebih lanjut. </p>\n\n<p> <code>if</code> <em> tidak </em> jalankan perintah yang diberikan, lalu periksa status keluarnya. </p>\n\n<p><sub> [Kesopanan yang dirujuk <a href=\"https://stackoverflow.com/questions/19670061/bash-if-false-returns-true\" target=\"_blank\" rel=\"nofollow noopener\"> jawaban dari SO </a> ] </sub></p>","votes":"1","source":"https://superuser.com/a/1400523","author":"<a href=\"https://superuser.com/users/307834/xen2050\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Xen2050</span></a>","replies":[{"reply":"Terima kasih, juga menemukan penjelasan yang bagus di <a href=\"https://stackoverflow.com/questions/19670061/bash-if-false-returns-true/47876317#47876317\" title=\"bash if false returns true\" target=\"_blank\" rel=\"nofollow noopener\"> stackoverflow.com/questions/19670061/bash-if-false-returns-true/â€¦ </a>","author":"<a href=\"https://superuser.com/users/696718/darren-weber\" target=\"_blank\" rel=\"nofollow noopener\">Darren Weber</a>"}]}]}
