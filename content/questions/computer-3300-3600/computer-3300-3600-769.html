{"title":"(Ubuntu / Linux) Perintah “find” memberikan hasil yang berbeda berdasarkan tanda kutip","draft":false,"url":"/ubuntu-linux-perintah-find-memberikan-hasil-yang-berbeda-berdasarkan-tanda-kutip-gq9delkk","votes":"4","answers_count":"2","categories":["Komputer"],"tags":["linux","ubuntu","command-line"],"snippet":"Saya menggunakan  find -iname *prib*  dan hanya mendapatkan satu hasil &quot;./prib09jack.pdf&quot; dengan  find -iname \"*prib*\"   Saya mendapatkan lebih banyak hasil yang saya cari seperti  ./Dir1/PRIB09/prib09jackTFF1.pdf  dan banyak lagi, tetapi mengapa penting bahwa...","body":"<p> Saya menggunakan </p> <pre><code>find -iname *prib*\n</code></pre> <p> dan hanya mendapatkan satu hasil &quot;./prib09jack.pdf&quot; dengan </p> <pre><code>find -iname \"*prib*\" \n</code></pre> <p> Saya mendapatkan lebih banyak hasil yang saya cari seperti </p> <pre><code>./Dir1/PRIB09/prib09jackTFF1.pdf\n</code></pre> <p> dan banyak lagi, tetapi mengapa penting bahwa tanda kutip ada di sekitar &quot; <em> prib </em> &quot;? </p>\n\n<p> Terbaik. </p>","source":"https://superuser.com/questions/181042/ubuntu-linuxfind-command-gives-different-results-based-on-quotation-marks","author":"<a href=\"https://superuser.com/users/47618/vass\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Vass</span></a>","replies":[{"reply":"Apakah Anda meluncurkan perintah dari direktori yang sama dan mendapatkan jawaban yang berbeda? Apa struktur perintah find keseluruhan yang Anda gunakan karena ada banyak opsi yang mempengaruhi hasilnya.","author":"<a href=\"https://superuser.com/users/16487/dtlussier\" target=\"_blank\" rel=\"nofollow noopener\">dtlussier</a>"},{"reply":"Saya berada di direktori yang sama untuk setiap penggunaan hanya mengubah kutipan di sekitar string pencarian.","author":"<a href=\"https://superuser.com/users/47618/vass\" target=\"_blank\" rel=\"nofollow noopener\">Vass</a>"}],"answers":[{"answer":"<p> Jika ada file (atau file) yang cocok dengan <code>*prib*</code> di direktori saat ini ketika perintah find dijalankan, shell akan memperluas wildcard untuk mencocokkan nama file terlebih dahulu sebelum menyerahkan argumen ke <strong> Temukan </strong> , dan menghasilkan perintah berbeda yang dijalankan dari yang diharapkan pengguna. </p>\n\n<p> Sebagai contoh, </p> <pre><code>$ ls foo*\nfoobar\n\n$ find -iname foo*\n./foobar\n\n$ find -iname \"foo*\"\n./foobar\n./dir/foobz\n./dir2/fooblat\n</code></pre> <p> Singkatnya, Quotes menunda interpretasi wildcard untuk perintah find yang akan dijalankan. Kurangnya kutipan segera meluas. </p>","votes":"10","source":"https://superuser.com/a/181056","author":"<a href=\"https://superuser.com/users/4969/kmarsh\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">kmarsh</span></a>","replies":[{"reply":"wow, itu dalam sekali. Saya tidak bisa mengatakan bahwa saya benar-benar memahaminya. Jadi, haruskah saya selalu menggunakan tanda kutip dalam situasi serupa? Apa yang Anda katakan terdengar seperti jika menemukan string yang cocok dengan bentuk karakter pengganti, penelusuran selanjutnya mengikuti perluasan karakter pengganti awal ini. Dan kutipan itu menghentikan hal ini terjadi. (jika saya tidak salah halaman manual tidak mengatakan apa-apa untuk menghindari kesalahan seperti itu).","author":"<a href=\"https://superuser.com/users/47618/vass\" target=\"_blank\" rel=\"nofollow noopener\">Vass</a>"},{"reply":"Anda akan menemukannya dijelaskan di halaman manual <code>bash</code>, bukan halaman manual <code>find</code>, karena kutipan ditangani oleh shell. Pada dasarnya (untuk mengulangi apa yang kmarsh katakan), jika Anda menggunakan <code>*prib*</code> tanpa tanda kutip, bash mencari file di direktori saat ini dengan nama yang cocok dengan pola itu dan mengganti <code>*prib*</code> dengan nama file sebelum memanggil <code>find</code>. Jika Anda menggunakan tanda kutip, bash meninggalkan <code>*prib*</code> sendiri.","author":"<a href=\"https://superuser.com/users/2419/david-z\" target=\"_blank\" rel=\"nofollow noopener\">David Z</a>"},{"reply":"@Vass: Anda dapat menggunakan <code>echo *prib*</code> dan semacamnya untuk melihat apa yang dilakukan bash pada argumen sebelum meneruskannya ke perintah. <code>echo</code> sendiri hanya mencetak argumennya tidak berubah, jadi outputnya memberi tahu Anda tentang apa bash memperluas <code>*prib*</code>.","author":"<a href=\"https://superuser.com/users/1033/sth\" target=\"_blank\" rel=\"nofollow noopener\">sth</a>"},{"reply":"@bayu_joo Terima kasih banyak. itu membuka mata. Terima kasih banyak karena mau repot-repot memberi tahu saya ini. Sepertinya ada dimensi lain pada baris perintah yang tidak saya sadari.","author":"<a href=\"https://superuser.com/users/47618/vass\" target=\"_blank\" rel=\"nofollow noopener\">Vass</a>"},{"reply":"@David, terima kasih atas elaborasi, dan @Vass, senang membantu dan terima kasih atas jawaban yang diterima. @sth bagus, saya juga menggunakan echo ketika saya ingin melihat apa yang akan terjadi dengan ekspansi wildcard.","author":"<a href=\"https://superuser.com/users/4969/kmarsh\" target=\"_blank\" rel=\"nofollow noopener\">kmarsh</a>"}]},{"answer":"<p> Masalahnya adalah bahwa shell Anda memperluas wildcard * sebelum menyerahkannya untuk ditemukan. Anda ingin menemukan untuk mendapatkannya, jadi Anda harus menghindarinya. Kutipan melakukan itu, atau Anda bisa melakukannya </p>\n\n<blockquote>\n  <p> <code>find -iname \\*iprib\\*</code> </p>\n</blockquote>\n\n<p> dan itu akan berhasil juga. Kuncinya adalah, Anda ingin wildcard membuatnya ditemukan tidak ditafsirkan oleh hal lain di sepanjang jalan (seperti cangkang Anda). </p>","votes":"1","source":"https://superuser.com/a/181143","author":"<a href=\"https://superuser.com/users/1785/pjz\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">pjz</span></a>","replies":[]}]}
