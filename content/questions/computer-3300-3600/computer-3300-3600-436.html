{"title":"Bagaimana cara mengekstrak nomor versi menggunakan sed?","draft":false,"url":"/bagaimana-cara-mengekstrak-nomor-versi-menggunakan-sed-qon99bnr","votes":"4","answers_count":"2","categories":["Komputer"],"tags":["regex","sed"],"snippet":"Saya mencoba menemukan ekspresi reguler terbaik untuk mengekstrak nomor versi dari string. Sebagai contoh:   echo \"Version 1.2.4.1 (release mode)\" | sed -ne 's/.*\\([0-9]\\+\\.[0-9]\\+\\.[0-9]\\+\\.[0-9]\\+\\).*/\\1/p'  Masalahnya di sini adalah bahwa ini hanya berfungsi jika...","body":"<p> Saya mencoba menemukan ekspresi reguler terbaik untuk mengekstrak nomor versi dari string. Sebagai contoh: </p> <pre><code> echo \"Version 1.2.4.1 (release mode)\" | sed -ne 's/.*\\([0-9]\\+\\.[0-9]\\+\\.[0-9]\\+\\.[0-9]\\+\\).*/\\1/p'\n</code></pre> <p> Masalahnya di sini adalah bahwa ini hanya berfungsi jika nomor versi dalam format &quot;a.b.c.d&quot;. Jika seseorang memutuskan untuk menambah atau menghapus digit (&quot;a.b.c.d.e&quot;, &quot;a.b.c&quot;), itu akan rusak. Jadi saya ingin memfaktorkan regex dan memberi tahu sed bahwa saya ingin: </p>\n\n<p> (1 atau lebih angka diikuti dengan titik) x 1 kali atau lebih, diikuti dengan angka. </p>\n\n<p> Saya tidak dapat menemukan cara &quot;mengelompokkan&quot; &quot;1 atau lebih angka diikuti dengan titik&quot; sehingga saya dapat mengetahui bahwa saya menginginkan pola itu setidaknya sekali. Saya sudah mencoba ini tetapi tidak berhasil: </p> <pre><code>\\([0-9]\\+\\.\\)\\+\n</code></pre> <p> Ada ide? </p>","source":"https://superuser.com/questions/363865/how-to-extract-a-version-number-using-sed","author":"<a href=\"https://superuser.com/users/107843/liberforce\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">liberforce</span></a>","replies":[{"reply":"Lihat: <a href=\"http://stackoverflow.com/questions/82064/a-regex-for-version-number-parsing\" target=\"_blank\" rel=\"nofollow noopener\"> Ekspresi reguler untuk penguraian nomor versi </a>","author":"<a href=\"https://superuser.com/users/48078/slhck\" target=\"_blank\" rel=\"nofollow noopener\">slhck</a>"}],"answers":[{"answer":"<p> Coba perintah &#39;sed&#39; berikutnya: </p> <pre><code>$ echo \"Version 1.2.4.1 (release mode)\" | sed -ne 's/[^0-9]*\\(\\([0-9]\\.\\)\\{0,4\\}[0-9][^.]\\).*/\\1/p'\n1.2.4.1\n</code></pre> <p> Ini menggunakan sintaks {i, j}, yang memilih ekspresi beberapa kali antara angka pertama dan terakhir. Tidak boleh ada angka dalam string sebelum nomor versi. </p>\n\n<p> Contoh lain: </p> <pre><code>$ echo \"Version 1.2.4.1.6 (release mode)\" | sed -ne 's/[^0-9]*\\(\\([0-9]\\.\\)\\{0,4\\}[0-9][^.]\\).*/\\1/p'\n1.2.4.1.6 \n$ echo \"Version 1.2 (release mode)\" | sed -ne 's/[^0-9]*\\(\\([0-9]\\.\\)\\{0,4\\}[0-9][^.]\\).*/\\1/p'\n1.2 \n$ echo \"Version 1.2. (release mode)\" | sed -ne 's/[^0-9]*\\(\\([0-9]\\.\\)\\{0,4\\}[0-9][^.]\\).*/\\1/p'\n$ \n</code></pre> <p><strong> EDIT untuk komentar </strong> : </p> <pre><code>$ echo \"Version 1.2.4.1.90 (release mode)\" | sed -nre 's/^[^0-9]*(([0-9]+\\.)*[0-9]+).*/\\1/p'\n</code></pre>","votes":"9","source":"https://superuser.com/a/363878","author":"<a href=\"https://superuser.com/users/88308/birei\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Birei</span></a>","replies":[{"reply":"Anda menentukan di sini jumlah digit yang Anda inginkan. Yang saya inginkan adalah itu berfungsi dengan sejumlah digit.","author":"<a href=\"https://superuser.com/users/107843/liberforce\" target=\"_blank\" rel=\"nofollow noopener\">liberforce</a>"},{"reply":"Saya sudah mengedit jawabannya. Saya harap ini berhasil sekarang.","author":"<a href=\"https://superuser.com/users/88308/birei\" target=\"_blank\" rel=\"nofollow noopener\">Birei</a>"},{"reply":"Saya akan gagal pada 1.2.4.10 misalnya, tapi saya mendapat gambaran umum, terima kasih.","author":"<a href=\"https://superuser.com/users/107843/liberforce\" target=\"_blank\" rel=\"nofollow noopener\">liberforce</a>"},{"reply":"Saya akhirnya mengubah sedikit jawaban terakhir Anda untuk bekerja dengan angka dengan beberapa digit, dan menambahkan sintaks regexp yang diperpanjang yang ditunjukkan Vinicius kepada saya. Ini memberi saya: <code>echo &quot;Version 1.2.4.1.90 (release mode)&quot; | sed -nre &#39;s&#47;^[^0-9]*(([0-9]+\\.)*[0-9]+).*&#47;\\1&#47;p&#39;</code>. Terima kasih kepada Anda berdua atas jawaban Anda!","author":"<a href=\"https://superuser.com/users/107843/liberforce\" target=\"_blank\" rel=\"nofollow noopener\">liberforce</a>"},{"reply":"Saya telah mengedit jawabannya untuk menunjukkan perintah &#39;sed&#39; terakhir yang benar. Terima kasih.","author":"<a href=\"https://superuser.com/users/88308/birei\" target=\"_blank\" rel=\"nofollow noopener\">Birei</a>"}]},{"answer":"<p> Coba ini: </p> <pre><code>[0-9]+(\\.[0-9]+)*\n</code></pre> <p> Artinya &quot;cocokkan 1 atau lebih digit dan kemudian cocokkan dengan sejumlah (titik + digit)&quot;. </p>","votes":"3","source":"https://superuser.com/a/363880","author":"<a href=\"https://superuser.com/users/8387/vinicius-pinto\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Vinicius Pinto</span></a>","replies":[{"reply":"Saya sudah mencoba tetapi Anda lupa melarikan diri dari karakter, jadi saya mencoba beberapa kombinasi berbeda, tetapi gagal bahkan dengan melarikan diri, kecuali saya tidak menemukan yang tepat.","author":"<a href=\"https://superuser.com/users/107843/liberforce\" target=\"_blank\" rel=\"nofollow noopener\">liberforce</a>"},{"reply":"Anda harus meneruskan flag -E agar regex diinterpretasikan sebagai regex yang diperluas, seperti di: sed -E -e &#39;s / [0-9] + ($ | \\. [0-9] +) * / x / g &#39;in.txt&gt; out.txt","author":"<a href=\"https://superuser.com/users/8387/vinicius-pinto\" target=\"_blank\" rel=\"nofollow noopener\">Vinicius Pinto</a>"},{"reply":"Saya menggunakan sed di MinGW, dan sepertinya -E tidak ada di versi itu (sed 4.2.1). Opsi itu diganti namanya -r atau --regexp-extended. Terima kasih atas tipnya.","author":"<a href=\"https://superuser.com/users/107843/liberforce\" target=\"_blank\" rel=\"nofollow noopener\">liberforce</a>"}]}]}
