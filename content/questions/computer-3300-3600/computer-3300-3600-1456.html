{"title":"Fungsi BASH tidak keluar dari karakter kontrol","draft":false,"url":"/fungsi-bash-tidak-keluar-dari-karakter-kontrol-1tg6jg69","votes":"4","answers_count":"1","categories":["Komputer"],"tags":["shell-script","bashrc","bash-scripting"],"snippet":"Saya memiliki fungsi yang saya gunakan untuk menemukan sesuatu, tetapi sayangnya setiap kali saya memberikannya karakter kontrol ($intVal atau testing : dll) itu tersedak. Saya bertanya-tanya apa perbaikannya?  Saya dapat memahami bahwa...","body":"<p> Saya memiliki fungsi yang saya gunakan untuk menemukan sesuatu, tetapi sayangnya setiap kali saya memberikannya karakter kontrol (<code>$intVal</code> atau <code>testing :</code> dll) itu tersedak. Saya bertanya-tanya apa perbaikannya? </p>\n\n<p> Saya dapat memahami bahwa menggunakan <code>$</code> atau <code>%</code> atau <code>:</code> dll di grep tanpa melarikan diri menyebabkan masalah ini, tetapi karena saya meneruskannya dengan referensi, saya tidak yakin bagaimana cara menghindarinya ... </p>\n\n<p> Bagaimanapun, ini kodenya. </p> <pre><code>function ffind()\n{\n     if [ $1 ] ; then\n         find -type f | grep -ir '$1' * | grep -v '.svn'\n     else\n         echo \"'$1' is not a valid resource\"\n     fi\n}\n</code></pre> <p> Contoh: </p> <pre><code>$ ffind $intVal\n'' is not a valid resource\n\n$ ffind \"testing :\"\nbash: [: testing: unary operator expected\n'testing :' is not a valid resource\n</code></pre>","source":"https://superuser.com/questions/468780/bash-function-not-escaping-control-characters","author":"<a href=\"https://superuser.com/users/78468/ehime\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">ehime</span></a>","replies":[{"reply":"Sudahkah Anda mencoba mengubah kutipan tunggal menjadi ganda? &quot;$ 1&quot; bukan &#39;$ 1&#39;. Itu tidak sama dalam bash.","author":"<a href=\"https://superuser.com/users/148049/mnmnc\" target=\"_blank\" rel=\"nofollow noopener\">mnmnc</a>"}],"answers":[{"answer":"<h2 class=\"h4\"> Contoh pertama </h2> <pre><code>$ ffind $intVal\n'' is not a valid resource\n</code></pre> <p> Ini tidak berhasil karena <strong> <code>$foo</code> adalah sintaks untuk variabel </strong> , dan Anda tidak memiliki variabel bernama <code>intVal</code> set, jadi <code>$intVal</code> diterjemahkan ke string kosong. Karena variabel juga tidak dikutip, tidak ada argumen sama sekali yang diteruskan ke <code>ffind</code>. </p>\n\n<p> Untuk memperbaikinya, keluar dari <code>$</code> - baik <strong> <code>\\$intVal</code> </strong> (garis miring terbalik) atau <strong> <code>'$intVal'</code> </strong> (kutipan tunggal). </p>\n\n<p> Jika Anda benar-benar <em> memiliki </em> variabel bernama <code>intVal</code>, bagaimanapun, masukkan <strong> dua kali lipat </strong> kutipan sebagai gantinya - <strong> <code>\"$intVal\"</code> </strong> - ini akan memperluas nilai variabel, tetapi tidak akan membaginya. </p>\n\n<p> Perhatikan bahwa ada <em> mana ada </em> sebagai &quot;melewati referensi&quot; di bash. Hanya ada pass-by-value dan (tricky) pass-by-name. </p>\n\n<h2 class=\"h4\"> Contoh kedua </h2> <pre><code>$ ffind \"testing :\"\nbash: [: testing: unary operator expected\n'testing :' is not a valid resource\n</code></pre> <p> Ini tidak berhasil karena <strong> Anda lupa memberi tanda kutip di sekitar <code>$1</code> </strong> di baris <code>if [ $1 ]</code>, oleh karena itu memang demikian <strong> tunduk pada pemisahan kata </strong> , dan tiga argumen diteruskan ke <code>[</code> builtin: </p>\n\n<ul>\n<li> &quot;<code>[</code>&quot; </li>\n<li> &quot;<code>testing</code>&quot; </li>\n<li> &quot;<code>:</code>&quot; </li>\n<li> &quot;<code>]</code>&quot; </li>\n</ul>\n\n<p> alih-alih dua yang diharapkan: </p>\n\n<ul>\n<li> &quot;<code>[</code>&quot; </li>\n<li> &quot;<code>testing :</code>&quot; </li>\n<li> &quot;<code>]</code>&quot; </li>\n</ul>\n\n<p> Contoh # 1 juga terpengaruh oleh ini, karena <code>[ $1 ]</code> dibagi menjadi (&quot;<code>]</code>&quot;, &quot;<code>]</code>&quot;) dan bukan (&quot;<code>[</code>&quot;, &quot;<code>​</code>&quot;, &quot;<code>intVal</code>&quot;). Contoh # 1 bekerja secara tidak sengaja, karena ternyata <code>[ ]</code> valid. (Saya tidak tahu itu ...) </p>\n\n<p> Untuk memperbaiki masalah ini, beri tanda kutip ganda sekitar <code>$1</code> - <code>[ \"$1\" ]</code>. </p>\n\n<p><strong> catatan: </strong> Meskipun <code>[</code> adalah standar, ada juga operator <code>[[</code> khusus bash, yang sebenarnya memiliki aturan penguraian yang berbeda dari kode lainnya - khususnya, ia tidak memisahkan variabel yang diperluas. Dalam bash, <code>[[ $1 ]]</code> dan <code>[[ \"$1\" ]]</code> keduanya setara, tidak seperti alternatif <code>[</code> mereka. </p>\n\n<h2 class=\"h4\"> Lebih banyak bug </h2>\n\n<p> Fungsi Anda juga memiliki beberapa masalah lain yang tidak ditampilkan dalam contoh. </p> <pre><code>find -type f | grep -ir '$1' * | grep -v '.svn'\n</code></pre> <p> Di baris ini: </p>\n\n<ol>\n<li><p> Kata <code>'$1'</code> memiliki tanda kutip tunggal di sekitarnya. Artinya itu <em> pesta </em> tidak akan memperluas isinya - Anda benar-benar memberi tahu <em> grep </em> untuk mencari regex <code>$1</code>, dan bukan untuk argumen baris perintah. </p>\n\n<p> Untuk mengatasinya, gunakan tanda kutip ganda - <code>\"$1\"</code> </p></li>\n<li><p> Pertama <em> grep </em> perintah diberitahu untuk mencari secara rekursif <strong> isi </strong> dari semua file di direktori saat ini (<code>-r</code> dan wildcard <code>*</code>). </p>\n\n<p> Pada saat yang sama, Anda menyalurkan output <code>find -type f</code> ke <em> grep </em> - sepertinya mencoba untuk memberitahu <em> grep </em> untuk mencari <strong> nama </strong> dari semua file. </p>\n\n<p> Ini tidak akan berhasil karena <em> grep </em> , seperti kebanyakan filter, tidak akan membaca dari stdin jika diberikan satu atau lebih file untuk dicari. Saya tidak tahu apa yang Anda coba cari - nama file atau konten file - jadi pilih salah satu: </p>\n\n<ul>\n<li><p> Untuk mencari hanya nama file, pertahankan pipa tetapi hapus spesifikasi file: </p> <pre><code> find -type f | grep -i \"$1\" | ...\n</code></pre> </li>\n<li><p> Untuk mencari konten file saja, hapus <code>find|</code> sebagai gantinya: </p> <pre><code> grep -ir \"$1\" * | ...\n</code></pre> </li>\n<li><p> Saya t <em> aku s </em> mungkin untuk menggabungkan keduanya, dengan memberi secara eksplisit <em> grep </em> file &quot;stdin&quot;: </p> <pre><code> find -type f | grep -i \"$1\" - * | ...\n\n find -type f | grep -i \"$1\" /dev/stdin * | ...\n</code></pre> <p> (<code>/dev/stdin</code> bekerja dengan semua program Linux, sedangkan <code>-</code> adalah konvensi yang digunakan oleh <em> beberapa </em> program, termasuk grep.) </p></li>\n</ul></li>\n<li><p> Di detik <em> grep </em> perintah, ekspresi reguler pencarian agak terlalu luas. (Ingatlah bahwa ini adalah regex, bukan string tetap.) <code>.svn</code> bahkan akan cocok dengan &quot;<code>not-a-svn-file</code>&quot;. </p>\n\n<p> Untuk mengecualikan direktori <code>.svn</code>, gunakan <code>grep -v \"/\\.svn/\"</code> sebagai gantinya. </p>\n\n<p> Jika mencari file <em> kandungan </em> (<code>grep -ir ...</code>), bahkan lebih baik lagi jika perintah <code>grep -v</code> dihilangkan seluruhnya, dan tambahkan <code>--exclude-dir=\".svn\"</code> ke yang pertama. </p></li>\n</ol>\n\n<h2 class=\"h4\"> Anda dapat berhenti membaca pada saat ini </h2>\n\n<p> Item di bawah ini hanyalah praktik yang baik dalam <em> SH </em> skrip. </p>\n\n<ol>\n<li><p> Kata kunci <code>function</code> tidak diperlukan: <code>ffind() { ...</code> sudah cukup, dan berfungsi di semua kerangka POSIX (sedangkan <code>function ffind</code> <em> tidak akan </em> ). </p></li>\n<li><p> Jika skrip, program, atau fungsi gagal, ia harus mengembalikan status &quot;gagal&quot; ke induknya. Sesuai kesepakatan, program Unix menganggap <code>0</code> berarti &quot;berhasil&quot; dan yang lainnya &quot;gagal&quot; (meskipun ada pengecualian untuk yang terakhir). </p>\n\n<p> Untuk mengembalikan status secara eksplisit, gunakan <code>return &lt;num&gt;</code> dalam fungsi (atau <code>exit &lt;num&gt;</code> dalam skrip mandiri): </p> <pre><code>else\n    echo \"'$1' is not a valid resource\" &gt;&amp;2\n    return 1\nfi\n</code></pre> </li>\n<li><p> Demikian pula, pesan kesalahan tidak boleh dicampur dengan stdout normal, tetapi ditulis ke <em> stderr </em> (fd # 2) sebagai gantinya, menggunakan operator pengalihan <code>&gt;&amp;</code> (lihat contoh di atas). Dengan cara ini Anda dapat mengarahkan output normal ke sebuah file (mis. <code>ffind intVal &gt; results.txt</code>) sementara masih ada kesalahan yang ditampilkan di layar. </p></li>\n</ol>\n\n<h2 class=\"h4\"> Kode tetap </h2> <pre><code>ffind()\n{\n     if [ \"$1\" ] ; then\n         grep -ir --exclude-dir=\".svn\" \"$1\" .\n     else\n         echo \"'$1' is not a valid resource\" &gt;&amp;2\n         return 1\n     fi\n}\n</code></pre> <h2 class=\"h4\"> Alat yang lebih baik </h2>\n\n<p><a href=\"http://betterthangrep.com/\" rel=\"nofollow noopener\" target=\"_blank\"> ack </a> mengklaim sebagai &quot;lebih baik dari grep&quot;. Menjalankan <code>ack \"testing :\"</code> akan mencari kode sumber Anda, dan secara otomatis melewati <code>.svn</code> dan direktori serupa. </p>","votes":"9","source":"https://superuser.com/a/468797","author":"<a href=\"https://superuser.com/users/1686/user1686\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">user1686</span></a>","replies":[]}]}
