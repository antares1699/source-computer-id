{"title":"Potong file di pipa","draft":false,"url":"/potong-file-di-pipa-hsra9ujx","votes":"4","answers_count":"6","categories":["Komputer"],"tags":["pipe","bash-scripting"],"snippet":"Apakah ada cara sederhana untuk memotong file di dalam pipa? Secara khusus, saya ingin memotong empat byte terakhir dari sebuah file sebelum memasukkannya ke proses lain.  Idealnya, saya bisa menulis sesuatu seperti:...","body":"<p> Apakah ada cara sederhana untuk memotong file di dalam pipa? Secara khusus, saya ingin memotong empat byte terakhir dari sebuah file sebelum memasukkannya ke proses lain. </p>\n\n<p> Idealnya, saya bisa menulis sesuatu seperti: </p>\n\n<p> <code>cat input.txt | some-process | truncate --size=-4 | another-process &gt; output.txt</code> </p>\n\n<p> tetapi tampaknya perintah <code>truncate</code> hanya beroperasi &quot;di tempat&quot; pada file di disk. </p>","source":"https://superuser.com/questions/393482/truncate-file-in-a-pipe","author":"<a href=\"https://superuser.com/users/27902/kostmo\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">kostmo</span></a>","replies":[{"reply":"<code>cat input.txt | some-process</code> lebih baik ditulis sebagai <code>some_process &lt; input.txt</code>.","author":"<a href=\"https://superuser.com/users/50883/benoit\" target=\"_blank\" rel=\"nofollow noopener\">Benoit</a>"}],"answers":[{"answer":"<p> Ini seperti jika saya menyuruh Anda untuk mengangkat tangan segera setelah saya mengucapkan <em> keempat dari kata terakhir </em> Saya akan mengatakan. Saya tidak akan memberi tahu Anda sebelumnya berapa banyak kata yang akan saya ucapkan. </p>\n\n<p> Pipa adalah a <em> aliran </em> . Datanya tidak memiliki ukuran, ia hanya memiliki operasi untuk mendapatkan elemen berikutnya darinya dan / atau memasukkan elemen ke dalamnya, dan hasilnya adalah sepotong data atau sinyal bahwa tidak ada lagi data. </p>\n\n<p> Jadi, kecuali Anda pertama kali mengambil semua data dari aliran, menempatkannya ke dalam buffer, menghitung panjangnya, &quot;memundurkan&quot; aliran, dan kemudian mengambil empat elemen yang lebih sedikit, itu tidak dapat dilakukan. </p>\n\n<p> EDIT: Saya perlu melakukan lebih banyak pemikiran daripada menghasilkan analogi yang cerdas :) Aliran tidak mengatakan &quot;hentikan saya segera n elemen sebelum yang terakhir&quot;, melainkan &quot;kirimkan semua elemen kecuali n terakhir&quot;, dan dengan mempertahankan buffer yang hanya terdiri dari n elemen, dan menunggu hingga n elemen pertama diterima sebelum mentransmisikan yang pertama, itu mungkin. Jelas ini tidak akan berfungsi dalam situasi seperti telekomunikasi di mana Anda ingin data dikirim segera setelah diterima seperti yang Anda bisa jika Anda menginginkan n elemen pertama. Dan saya berasumsi <code>truncate</code> tidak melakukannya dengan cara ini. </p>\n\n<p> (percobaan downvoting diri -1) </p>","votes":"6","source":"https://superuser.com/a/393494","author":"<a href=\"https://superuser.com/users/70484/paul-richter\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Paul Richter</span></a>","replies":[{"reply":"Anda mendapatkan upvote saya, karena jawaban Anda membantu saya menyadari bahwa panjang file / streaming tidak diketahui saat runtime, yang mendorong saya untuk menulis skrip Python.","author":"<a href=\"https://superuser.com/users/27902/kostmo\" target=\"_blank\" rel=\"nofollow noopener\">kostmo</a>"}]},{"answer":"<p> Saya merasa konyol setelah menulis skrip Python itu. </p>\n\n<p> Ada perintah shell bawaan <code>head</code> untuk melakukannya: </p>\n\n<p> <code>cat input.txt | some-process | head --bytes=-4 | another-process &gt; output.txt</code> </p>\n\n<p><strong> Edit: </strong> Perintah GNU <code>head</code> memiliki file <a href=\"http://git.savannah.gnu.org/cgit/coreutils.git/tree/src/head.c#n309\" rel=\"nofollow noopener\" target=\"_blank\"> implementasi yang serupa secara konseptual </a> (yaitu hemat memori) ke <a href=\"https://superuser.com/a/393550/27902\" target=\"_blank\" rel=\"nofollow noopener\"> implementasi Python saya </a> di bawah. Satu perbedaan adalah bahwa ia membulatkan ukuran buffer melingkar (<code>N</code>, jumlah byte yang dihilangkan) menjadi kelipatan dari beberapa ukuran buffer standar. </p>","votes":"5","source":"https://superuser.com/a/393552","author":"<a href=\"https://superuser.com/users/27902/kostmo\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">kostmo</span></a>","replies":[{"reply":"asalkan versi <code>head</code> tidak terlalu tua yang akan berfungsi.","author":"<a href=\"https://superuser.com/users/50883/benoit\" target=\"_blank\" rel=\"nofollow noopener\">Benoit</a>"}]},{"answer":"<p> <code>sed</code> dapat beroperasi pada baris terakhir. Ini mengasumsikan 4 karakter terakhir berada dalam satu baris: </p> <pre><code>printf \"%s\\n\" abcdef ghijkl mnopqr | sed '$s/....$//'\n</code></pre> <p> keluaran </p> <pre><code>abcdef\nghijkl\nmn\n</code></pre>","votes":"1","source":"https://superuser.com/a/393637","author":"<a href=\"https://superuser.com/users/4714/glenn-jackman\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">glenn jackman</span></a>","replies":[]},{"answer":"<p> Saya tidak dapat menemukan perintah shell bawaan untuk melakukan ini, jadi saya rasa itu berarti tidak ada solusi &quot;satu baris&quot;. Namun, saya dapat menulis skrip Python untuk melakukan apa yang saya butuhkan: </p> <pre class=\"lang-py prettyprint-override\"><code>#!/usr/bin/env python\n'''\nUsage:\npipetruncate.py &lt;N&gt;\n\nTruncates a stream in a pipe at N bytes before the EOF.\nUses memory proportional to N.\n'''\n\nimport sys\n\nbuffer_length = int(sys.argv[1])\ncircular_buffer = [0]*buffer_length\ncount = 0\nwhile True:\n    ch = sys.stdin.read(1)\n    if not len(ch): # EOF\n        break\n\n    index = count % buffer_length\n    nextchar = circular_buffer[index]\n    circular_buffer[index] = ch\n\n    count += 1\n    if count > buffer_length:\n        sys.stdout.write(nextchar)\n\nsys.stdout.close()</code></pre> <p> Lalu saya memohon </p>\n\n<p> <code>cat input.txt | some-process | ./pipetruncate.py 4 | another-process &gt; output.txt</code> </p>","votes":"0","source":"https://superuser.com/a/393550","author":"<a href=\"https://superuser.com/users/27902/kostmo\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">kostmo</span></a>","replies":[]},{"answer":"<p> Menghabiskan sebagian dari pagi hari menulis skrip python juga. Tentu saja, lebih baik Anda menggunakan &quot;kepala&quot; Anda daripada menulis lebih banyak kode. Pokoknya ini versi saya. Ini jelek tapi saya pikir ini adalah skrip python pertama saya: </p> <pre><code>#!/usr/bin/python\n\n# stream_trunc: cut the last n bits of a stream\n\nimport sys\n\nif len(sys.argv) &lt;&gt; 2:\n    print 'Usage: ' + sys.argv[0] + ' &lt;number&gt;'\n    exit(1)\n\nnum = sys.argv[1]\n\nif num.isdigit() != True:\n    print 'Argument should be a number'\n    print 'Usage: ' + sys.argv[0] + ' &lt;number&gt;'\n    exit(1)\n\nn = int(num)\nbuf = sys.stdin.read(n)\nc = sys.stdin.read(1)\n\nwhile c != '':\n    sys.stdout.write(buf[0])\n    buf = buf[1:] + c\n    c = sys.stdin.read(1)\n</code></pre>","votes":"0","source":"https://superuser.com/a/393580","author":"<a href=\"https://superuser.com/users/119923/jorge-juan\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Jorge Juan</span></a>","replies":[]},{"answer":"<p> Saya heran belum ada yang menyebutkan <code>dd</code>. </p>\n\n<p> Ini akan membaca 1024 byte input pertama: </p> <pre><code>$ dd if=inputfile of=truncated_file count=1024\n</code></pre> <p> Ini akan melewati 2048 byte input pertama: </p> <pre><code>$ dd if=inputfile of=truncated_file skip=2048\n</code></pre> <p> Dengan menghapus parameter <code>if</code> dan / atau <code>of</code>, <code>dd</code> akan membaca dari STDIN dan menulis ke STDOUT. Artinya, Anda dapat melakukan hal-hal seperti ini: </p> <pre><code>$ cat input.txt | dd count=1024 | another-process &gt; output.txt\n</code></pre> <p> Bergantung pada versi <code>dd</code> yang Anda jalankan, Anda dapat menentukan unit ukuran untuk parameter <code>count</code> dan <code>skip</code> (lihat halaman manual untuk lebih detil). </p>","votes":"0","source":"https://superuser.com/a/1234439","author":"<a href=\"https://superuser.com/users/455748/kchr\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">kchr</span></a>","replies":[{"reply":"perhatikan bahwa (di Ubuntu setidaknya, ukuran blok default <code>dd</code>s adalah 512 byte; ini berarti <code>count=1024</code> akan terbaca (1024 * 512) = <i> 524288 byte </i> kecuali Anda juga menentukan <code>iflag=count_bytes</code>; hal yang sama berlaku untuk parameter <code>skip=</code>/<code>iflag=skip_bytes</code> dan <code>seek=</code>/<code>oflag=seek_bytes</code>.","author":"<a href=\"https://superuser.com/users/69539/doktor-j\" target=\"_blank\" rel=\"nofollow noopener\">Doktor J</a>"}]}]}
