{"title":"Untuk apa &quot;ln -L&quot; (--logical)?","draft":false,"url":"/untuk-apa-quotln-lquot-logical-jgz3yejx","votes":"4","answers_count":"2","categories":["Komputer"],"tags":["linux","hardlink","ln","proc"],"snippet":"Saya dapat membaca di halaman manual ln:     -L, --logical          make hard links to symbolic link references  Saya membaca bahwa ln -L dapat digunakan untuk menautkan ulang file yang telah dihapus tetapi masih...","body":"<p> Saya dapat membaca di halaman manual ln: </p> <pre><code>   -L, --logical\n          make hard links to symbolic link references\n</code></pre> <p> Saya membaca bahwa <code>ln -L</code> dapat digunakan untuk menautkan ulang file yang telah dihapus tetapi masih terbuka, menggunakan sistem file <code>/proc</code>. Sebagai contoh: </p> <pre><code>ln -L /proc/1234/fd/12 /tmp/my-file\n</code></pre> <p> Tetapi saya mendapatkan <code>ENOENT</code>: Tidak ada file atau direktori seperti itu. Jika saya mencoba pada sistem file yang berbeda, saya mendapatkan tautan lintas perangkat tidak valid. </p>\n\n<p> Jika saya tidak dapat menggunakan <code>ln -L</code> untuk memulihkan file yang terhapus, lalu untuk apa itu digunakan? </p>","source":"https://superuser.com/questions/337292/what-is-ln-l-logical-for","author":"<a href=\"https://superuser.com/users/36520/user36520\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">user36520</span></a>","replies":[],"answers":[{"answer":"<p> Utilitas GNU terutama didokumentasikan dengan <code>info</code> halaman. Dari <a href=\"http://www.gnu.org/software/coreutils/manual/html_node/ln-invocation.html\" rel=\"nofollow noopener\" target=\"_blank\"> halaman info GNU ln </a> : </p> <pre><code>‘-L’\n‘--logical’\n    If -s is not in effect, and the source file is a symbolic link,\n    create the hard link to the file referred to by the symbolic link,\n    rather than the symbolic link itself. \n</code></pre> <p> Jadi ini hanyalah referensi tautan simbolis yang diberikan sebagai argumen sumber. </p>","votes":"4","source":"https://superuser.com/a/337299","author":"<a href=\"https://superuser.com/users/11317/reinierpost\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">reinierpost</span></a>","replies":[]},{"answer":"<p> Jawaban yang lebih ramah pemula ... </p>\n\n<h2 class=\"h4\"> Beberapa hal mendasar sebelumnya </h2>\n\n<p> Pandangan sederhana tentang bagaimana file disimpan pada sistem UNIX / Linux adalah: Ada entri direktori yang terdiri dari nama yang Anda lihat <em> ls -l </em> dan nomor Inode (Anda mungkin melihat dengan <em> ls -i </em> ). Inode berisi informasi aktual tempat data Anda disimpan di sistem file (antara lain seperti kepemilikan, izin, Inode lainnya jika diperlukan, dan sebagainya): </p>\n\n<p> (Waktunya untuk bersenang-senang UTF-8 ... ;-)) </p>\n\n<h3 class=\"h5\"> Tampilan sederhana: </h3> <pre><code>┌─────────────────┐    ┌───────┐    ┌─────────────┐\n│ directory entry │ ─► │ Inode │ ─► │ data blocks │\n└─────────────────┘    └───────┘    └─────────────┘\n</code></pre> <p> Sekarang untuk perbedaan antara Hard dan symbolic link: </p>\n\n<p> Tautan keras hanyalah entri direktori yang menunjuk ke Inode yang sama dengan yang sudah ada, sedangkan tautan simbolik hanyalah file khusus yang berisi nama file annother (disimpan langsung di dalam Inode, jika nama jalur cukup kecil untuk cocok). Inilah alasannya, mengapa </p>\n\n<ul>\n<li> Tautan keras ke file yang sama tidak dapat memiliki izin akses file yang berbeda (karena ini disimpan dalam Inode) </li>\n<li> Tautan keras harus berada dalam sistem file yang sama </li>\n</ul>\n\n<h3 class=\"h5\"> Tampilan sederhana yang diperluas </h3> <pre><code> ┌─────────────────┐   \n │    hard link    │ ───────┐\n └─────────────────┘        ▼\n ┌─────────────────┐    ┌───────┐    ┌─────────────┐\n │  example_file   │ ─► │ Inode │ ─► │ data blocks │\n └─────────────────┘    └───────┘    └─────────────┘\n          ▲\n          └───────────────────────┐\n                                  │\n ┌─────────────────┐    ┌─────────┴──────────┐\n │  symbolic link  │ ─► │ filename reference │\n └─────────────────┘    └────────────────────┘\n</code></pre> <p> Sekarang kembali ke opsi <code>-L</code> dengan <code>-s</code> absen: Ini memungkinkan Anda, untuk membuat file <em> tautan keras </em> dari file di mana a <em> tautan simbolis </em> menunjuk ke (Seperti &quot;tautan keras&quot; pada contoh di atas). </p>\n\n<h2 class=\"h4\"> Mengapa itu bisa membantu memulihkan file yang telah dihapus, tetapi masih digunakan oleh program terbuka? </h2>\n\n<p> Perilaku ini pasti sangat bergantung pada implementasi dan jarak tempuh Anda mungkin berbeda-beda di semua platform UNIX / Linux, tetapi saya akan mencoba menjelaskan bagaimana caranya. <em> bisa </em> kerja: </p>\n\n<p> Saat file dihapus (katakanlah via <em> rm (1) </em> ) panggilan sistem yang dipanggil selalu <em> batalkan tautan (2) </em> . Ini menghapus entri direktori dan mengurangi penghitung tautan (dipertahankan dalam Inode) satu per satu. </p>\n\n<p> Jika penghitung tautan mencapai nol, saatnya bagi OS untuk membersihkan (benar-benar melepaskan blok data tempat inode menunjuk dan kemudian Inode itu sendiri. <em> TAPI </em> jika file masih terbuka, tugas ini biasanya ditunda sampai program yang menggunakan inode berakhir. </p>\n\n<p> Saat ini sebagian besar sistem UNIX mempertahankan hierarki sistem file <code>/proc</code> di mana seseorang dapat mencari referensi untuk membuka file, yaitu <em> (mengherankan!) </em> tautan simbolis. Mengingat bahwa seseorang menemukan entri yang benar, <code>ln -L</code> <em> mungkin </em> membantu membuat ulang tautan ke inode, meningkatkan penghitung tautan lagi dan dengan demikian mencegah OS menghapus inode (jika pengguna yang beruntung cukup cepat dan program masih berjalan). </p>\n\n<p> Catatan: Agar ini berfungsi, lokasi tautan baru harus berada pada sistem file yang sama dengan yang asli! </p>\n\n<h3 class=\"h5\"> Contoh Terakhir </h3> <pre><code> ┌─────────────────┐   \n │   rescue_link   │ ───────┐\n └─────────────────┘        ▼\n ┌─────────────────┐    ┌───────┐    ┌─────────────┐\n │ *** removed *** │    │ Inode │ ─► │ data blocks │\n └─────────────────┘    └───────┘    └─────────────┘\n          ▲\n          └───────────────────────┐\n                                  │\n ┌─────────────────┐    ┌─────────┴──────────┐\n │ /proc/bla/fd/n  │ ─► │ filename reference │\n └─────────────────┘    └────────────────────┘\n</code></pre> <h2 class=\"h4\"> Kata-kata terakhir </h2>\n\n<p> Ada banyak hal yang dapat mencegah pembuatan tautan yang benar dan itu sangat tergantung pada bagaimana tautan simbolik itu sendiri diimplementasikan dan saya harus mengakui: Saya sangat meragukan ini akan bekerja dengan banyak varian UNIX - tapi mungkin sukarelawan yang mau meluangkan waktu untuk menguji ini? </p>","votes":"6","source":"https://superuser.com/a/337365","author":"<a href=\"https://superuser.com/users/97796/ktf\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">ktf</span></a>","replies":[]}]}
