{"title":"Menggunakan find atau grep untuk menemukan nama file dengan karakter beraksen dari sistem pengkodean yang berbeda (Windows ke Linux)","draft":false,"url":"/menggunakan-find-atau-grep-untuk-menemukan-nama-file-dengan-karakter-beraksen-dari-sistem-pengkodean-yang-berbeda-windows-ke-linux-ovsucwuq","votes":"4","answers_count":"3","categories":["Komputer"],"tags":["linux","bash","find","grep"],"snippet":"Saya mencoba memberi tag terlambat ke pertanyaan yang mirip dengan pertanyaan saya di stackoverflow (  Temukan Nama File Non-UTF8 di Sistem File Linux  ) untuk mendapatkan balasan lebih lanjut, sejauh ini tidak...","body":"<p> Saya mencoba memberi tag terlambat ke pertanyaan yang mirip dengan pertanyaan saya di stackoverflow ( <a href=\"https://stackoverflow.com/q/623764/522104\" target=\"_blank\" rel=\"nofollow noopener\"> Temukan Nama File Non-UTF8 di Sistem File Linux </a> ) untuk mendapatkan balasan lebih lanjut, sejauh ini tidak berhasil, jadi begini lagi ... </p>\n\n<p> Saya memiliki masalah yang sama dengan OP pada tautan di atas dan konvmv adalah alat yang hebat untuk memperbaiki sistem file sendiri. Oleh karena itu, pertanyaan saya bersifat akademis, tetapi saya merasa tidak memuaskan (sebenarnya saya tidak percaya) bahwa &#39;temukan&#39; tidak dapat menemukan karakter ascii non standar. </p>\n\n<p> Apakah ada orang di luar sana yang akan tahu kombinasi opsi apa yang digunakan untuk menemukan nama file yang berisi karakter non standar pada apa yang tampaknya menjadi FS unicode, dalam kasus saya karakternya tampaknya 8bits diperpanjang ascii daripada unicode, file-nya berasal dari mesin Windows (iso-8859-1) dan saya secara teratur perlu mengambilnya. Saya ingin melihat bagaimana find dan / atau grep dapat melakukan hal yang sama seperti konvmv. </p>\n\n<p> File contoh: </p> <pre><code>&gt; ls\nAbc�def ÉÈéèáà-rest everest éverest\n\n&gt; ls -b\nAbc\\251def  ÉÈéèáà-rest  everest  éverest\n</code></pre> <p> File pertama berasal dari Windows (atau disimulasikan dengan <code>touch $(printf \"Abc\\xA9def\")</code>). </p> <pre><code>&gt; find . -regex '.*[^a-zA-Z./].*'\n./ÉÈéèáà-rest\n\n&gt; ls | egrep '[^a-zA-Z]'\nÉÈéèáà-rest\n</code></pre> <p> Hampir semuanya hilang (tanda hubung menyimpan file itu, dapat dilihat dengan grep berwarna). Apa pun yang terjadi di sini bukanlah yang saya harapkan: baik find maupun grep tidak dapat menganggap huruf beraksen berada di luar kisaran yang disediakan [^ a-zA-Z. /]. </p> <pre><code>&gt; find . -regex '.*é.*'\n./éverest\n./ÉÈéèáà-rest\n\n&gt; ls | egrep 'é'\nÉÈéèáà-rest\néverest\n\n&gt; ls | egrep '[é]'\nÉÈéèáà-rest\néverest\n\n&gt; find . -regex '.*[é].*'\n./éverest\n./ÉÈéèáà-rest\n</code></pre> <p> Anehnya keduanya mampu mengambil aksen standar saat disediakan (termasuk dalam jangkauan). Uji coba temukan atau grep apa pun dengan \\ xA9, \\ 0251 atau \\ o251 gagal (tidak ada kecocokan). </p> <pre><code>&gt; ls | fgrep e\nAbc�def\nÉÈéèáà-rest\neverest\néverest\n</code></pre> <p> Mencari karakter non-kontroversial menunjukkan semua file dengan grep, seperti yang saya harapkan. </p> <pre><code>&gt; find . -regex '.*e.*'\n./éverest\n./ÉÈéèáà-rest\n./everest\n\n&gt; find . -name '*e*'\n./éverest\n./ÉÈéèáà-rest\n./everest\n</code></pre> <p> find, bagaimanapun, sangat diskriminatif: bahkan mencari karakter normal, menurut saya itu menghilangkan nama file yang mengandung karakter di luar rentang karakter yang dapat diterima untuk skema pengkodean nama sistem file. </p>\n\n<p> Sejauh yang saya khawatirkan jika file tersebut ada di filesystem, maka find harus menemukannya, bukan? Tapi mungkin ada fitur yang tidak saya ketahui? </p>\n\n<p> Setiap wawasan akan sangat dihargai. </p>","source":"https://superuser.com/questions/218825/using-find-or-grep-to-locate-filenames-with-accented-characters-from-a-different","author":"<a href=\"https://superuser.com/users/58086/asoundmove\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">asoundmove</span></a>","replies":[],"answers":[{"answer":"<p> Alat GNU tampaknya memiliki kode yang menyebabkan huruf beraksen diperlakukan seperti huruf dasarnya saat mencocokkan kelas karakter regex, jika didukung oleh pengkodean karakter. Ini dimaksudkan sebagai fitur semacam &quot;lakukan yang saya maksud&quot; untuk membuat penulisan ekspresi reguler lebih mudah, tetapi dalam hal ini fitur tersebut menghalangi Anda. </p>\n\n<p> Coba modifikasi berikut pada baris perintah &quot;temukan&quot; Anda: </p> <pre><code>LANG=C find . -regex '.*[^a-zA-Z./].*'\n</code></pre> <p> Ini menetapkan variabel lingkungan LANG hanya dalam konteks perintah &quot;temukan&quot;. Karena pengkodean bahasa &quot;C&quot; hanya mendukung ASCII, huruf beraksen tidak akan lagi diperlakukan sebagai huruf dasarnya, sehingga akan dicocokkan dengan benar oleh ekspresi reguler Anda. </p>","votes":"9","source":"https://superuser.com/a/218831","author":"<a href=\"https://superuser.com/users/57026/jander\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Jander</span></a>","replies":[{"reply":"Akan lebih dapat diandalkan untuk menjalankan <code>LC_CTYPE=C find …</code> atau <code>LC_ALL=C find …</code>. Prioritas variabel lingkungan adalah <code>LC_ALL</code> terlebih dahulu, jika tidak ada <code>LC_xxx</code> untuk kategori lokal yang diinginkan (di sini ctype, yaitu kumpulan karakter dan pengkodean), jika juga tidak ada <code>LANG</code>. Jadi, jika sudah Anda memiliki <code>LC_CTYPE</code> di lingkungan (umum di 95% dunia yang bahasanya tidak dapat ditulis dalam ASCII), <code>LANG=</code> tidak akan mengubah apa pun.","author":"<a href=\"https://superuser.com/users/42315/gilles-so-stop-being-evil\" target=\"_blank\" rel=\"nofollow noopener\">Gilles &#x27;SO- stop being evil&#x27;</a>"}]},{"answer":"<p> Jawaban Jander bekerja dengan sempurna, bagi mereka yang tertarik untuk mendapatkan lebih banyak dari ini, berikut satu tip lagi. </p>\n\n<p> Dengan LANG = C, temukan menampilkan karakter non-ascii dengan tanda tanya. Untuk mengonversinya kembali ke tampilan normal dengan sistem file itu, cukup pipa output ke cat. </p> <pre><code>LANG=C find . -regex '.*[^a-zA-Z./-].*'\n./??verest\n./????????????-rest\n./Abc?def\n\nLANG=C find . -regex '.*[^a-zA-Z./-].*' | cat\n./éverest\n./ÉÈéèáà-rest\n./Abc�def\n</code></pre>","votes":"5","source":"https://superuser.com/a/218842","author":"<a href=\"https://superuser.com/users/58086/asoundmove\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">asoundmove</span></a>","replies":[{"reply":"Apa yang sebenarnya terjadi adalah <code>find</code> mengubah karakter yang tidak dapat dicetak menjadi <code>?</code>, tetapi hanya jika mencetak ke terminal. Dengan <code>find … | cat</code>, itu tidak mencetak ke terminal sehingga mencetak byte saat mereka datang. Dengan <code>LANG=C</code>, setiap karakter non-ASCII tidak dapat dicetak.","author":"<a href=\"https://superuser.com/users/42315/gilles-so-stop-being-evil\" target=\"_blank\" rel=\"nofollow noopener\">Gilles &#x27;SO- stop being evil&#x27;</a>"}]},{"answer":"<pre><code>find . | grep -E '.*[^[:print:]].*'\n</code></pre> <p> Untuk daftar semua kelas karakter posix, lihat: <a href=\"http://www.regular-expressions.info/posixbrackets.html\" rel=\"nofollow noopener\" target=\"_blank\"> http://www.regular-expressions.info/posixbrackets.html </a></p>","votes":"0","source":"https://superuser.com/a/1000856","author":"<a href=\"https://superuser.com/users/365890/tom-hale\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Tom Hale</span></a>","replies":[{"reply":"Ini terlihat seperti solusi yang elegan namun sepertinya tidak berhasil untuk saya.","author":"<a href=\"https://superuser.com/users/58086/asoundmove\" target=\"_blank\" rel=\"nofollow noopener\">asoundmove</a>"}]}]}
