{"title":"Bagaimana cara menjalankan fungsi di bash atau zsh pada setiap huruf yang diketik menjadi prompt?","draft":false,"url":"/bagaimana-cara-menjalankan-fungsi-di-bash-atau-zsh-pada-setiap-huruf-yang-diketik-menjadi-prompt-k8fubdv4","votes":"4","answers_count":"2","categories":["Komputer"],"tags":["linux","command-line","bash","zsh","tmux"],"snippet":"Saya tahu tentang  preexec ()  kait untuk zsh dan cara ini bisa dicapai dalam bash. (  tautan  )  Tapi bisakah saya mendapatkan  masukan saat ini  saat masih mengetik?  Ide di balik pertanyaan...","body":"<p> Saya tahu tentang <strong> preexec () </strong> kait untuk zsh dan cara ini bisa dicapai dalam bash. ( <a href=\"https://superuser.com/questions/175799/does-bash-have-a-hook-that-is-run-before-executing-a-command\" target=\"_blank\" rel=\"nofollow noopener\"> tautan </a> ) </p>\n\n<p> Tapi bisakah saya mendapatkan <strong> masukan saat ini </strong> saat masih mengetik? </p>\n\n<p> Ide di balik pertanyaan ini adalah sebagai berikut: </p>\n\n<p> untuk memungkinkan belajar lebih cepat tentang perintah, argumen, dan pintasan, saya ingin mencari perintah yang sedang diketik dalam &quot;database&quot; yang menyediakan petunjuk &quot;help / good-to-know / shortcut&quot; dan menunjukkannya di sesi lain dengan screen / tmux saat mengetik di sisi lain. </p>\n\n<p> Apakah mungkin untuk memeriksa perintah saat ini yang sedang diketik? Jika tidak berhasil pada setiap penekanan tombol, loop timer mungkin juga berfungsi. </p>","source":"https://superuser.com/questions/604812/how-to-execute-a-function-in-bash-or-zsh-on-every-letter-being-typed-into-prompt","author":"<a href=\"https://superuser.com/users/226207/nicolai-fr%c3%b6hlich\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Nicolai Fr&#246;hlich</span></a>","replies":[],"answers":[{"answer":"<p> Saya hanya bisa menjawab untuk <code>zsh</code>, di mana ini bisa dilakukan, ya. </p>\n\n<p> Pertama, sudah ada beberapa widget untuk <em> penyelesaian bertahap </em> . Yang pertama rupanya oleh Y. Fujii. Meskipun <a href=\"http://mimosa-pudica.net/zsh-incremental.html\" rel=\"nofollow noopener\" target=\"_blank\"> situsnya </a> dalam bahasa Jepang, Anda dapat dengan mudah mengetahuinya tanpa perlu berbicara bahasa itu, cara kerjanya, dan cara menggunakannya. <a href=\"https://github.com/hchbaw/auto-fu.zsh\" rel=\"nofollow noopener\" target=\"_blank\"> Fu-otomatis </a> merupakan perpanjangan dari skrip asli. </p>\n\n<p> Sejauh ini referensinya. Pada <code>zsh</code> itu <em> editor garis zsh </em> (<code>zle</code>) bertanggung jawab atas penggunaan interaktif baris perintah. Terlepas dari banyak variabel lain yang disediakan untuk widget (lihat <code>man zshzle</code>), ini menarik bagi Anda karena Anda ingin menangkap <em> baris perintah saat ini </em> : </p>\n\n<blockquote>\n  <p><strong> $ BUFFER </strong> :\n               Seluruh konten buffer edit. </p>\n  \n  <p><strong> $ LBUFFER </strong> :\n               Bagian buffer yang terletak di sebelah kiri posisi kursor. </p>\n  \n  <p><strong> $ RBUFFER </strong> :\n               Bagian buffer yang terletak di sebelah kanan posisi kursor. </p>\n</blockquote>\n\n<p> Variabel ini dapat ditulis, apa yang akan mengubah baris perintah saat ini! </p>\n\n<p> Untuk menangkap setiap penekanan tombol, Anda dapat memodifikasi widget <code>self-insert</code> yang dijalankan (secara default) untuk setiap penekanan tombol kecuali <code>LF</code> atau <code>CR</code>. Berikut adalah contoh, yang tidak berguna, tetapi menambahkan titik untuk setiap penekanan tombol ke <code>$RBUFFER</code> - hanya untuk menggambarkan bagaimana ini bekerja: </p> <pre><code>function self-insert() {\n  RBUFFER+=\".\"\n  # execute some other command, but ensure they don't produce any output.\n  zle .self-insert\n  }\nzle -N self-insert\n</code></pre> <p> <code>.self-insert</code> adalah widget bawaan, jadi kami tidak mengalami infinity loop. </p>\n\n<p> Jadi, Anda dapat memulai dari awal atau mulai dari skrip Fujii dan memodifikasinya. Salah satu manfaat yang terakhir adalah, bahwa ia juga melakukan beberapa penanganan untuk menghapus penekanan tombol yang saya abaikan di sini. </p>","votes":"6","source":"https://superuser.com/a/604846","author":"<a href=\"https://superuser.com/users/195224/mpy\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">mpy</span></a>","replies":[{"reply":"terima kasih atas jawaban Anda yang luar biasa - inilah yang saya cari. sekarang saya dapat memeriksa $ BUFFER pada keystroke dan memutuskan file bantuan mana yang akan ditampilkan di terminal kedua saya. ya! :)","author":"<a href=\"https://superuser.com/users/226207/nicolai-fr%c3%b6hlich\" target=\"_blank\" rel=\"nofollow noopener\">Nicolai Fr&#xF6;hlich</a>"},{"reply":"@nifr: Sama-sama ... btw. nya <i> zsh </i> itu luar biasa <code>;)</code>","author":"<a href=\"https://superuser.com/users/195224/mpy\" target=\"_blank\" rel=\"nofollow noopener\">mpy</a>"}]},{"answer":"<p> Untuk Bash Anda dapat membuat skrip <code>test.sh</code> berikut: </p> <pre><code>#!/usr/bin/env bash\n\nARRAY=('1' '2' '3' '4' '5' '6' '7' '8' '9' '0' '-' '=' 'BACKSPACE' ''\n'q' 'w' 'e' 'r' 't' 'y' 'u' 'i' 'o' 'p' '[' ']' 'NEWLINE' '' \n'a' 's' 'd' 'f' 'g' 'h' 'j' 'k' 'l' ';' \"'\" '' '' '' 'z' 'x' 'c' \n'v' 'b' 'n' 'm' '0' ',' '.' '/' '' '' 'SPACE')\n\nwhile read row \ndo\n    if [[ \"$row\" == *press* ]]\n    then\n        index=$((${row/key press   /}-10))\n        if [[ \"${ARRAY[$index]}\" == 'NEWLINE' ]] \n        then\n                printf \"\\n\"\n        elif [[ \"${ARRAY[$index]}\" == 'BACKSPACE' ]] \n        then\n            echo  -ne \"\\b \\b\"\n        elif [[ \"${ARRAY[$index]}\" == 'SPACE' ]] \n        then\n            printf \" \"\n        else\n            printf \"%s\" \"${ARRAY[$index]}\"\n        fi\n    fi\ndone\n</code></pre> <p> Ini adalah skrip sederhana yang menerima beberapa kode keyboard dan mencetaknya di layar. Sekarang berikan kode keyboard untuk itu: </p> <pre><code>$ stdbuf -o0 xinput test 'AT Translated Set 2 keyboard' | bash test.sh\n</code></pre> <p> Sekarang jika Anda mengetik di terminal lain, itu akan menerima nilai kunci. Saya tidak tahu apakah ada cara cerdas untuk memetakan kode kunci ke nilai ASCII mereka, jadi saya hanya melakukan pemetaan sederhana. Anda juga dapat meningkatkan kode ini untuk bereaksi terhadap kunci lain. Namun perlu dicatat bahwa skrip akan menerima semua input keyboard, tidak hanya diteruskan ke satu terminal yang diberikan. </p>\n\n<p> Adapun tugas itu sendiri (memeriksa perintah saat ini sedang diketik) Anda dapat menggunakan <code>compgen -c</code> untuk menghasilkan daftar penyelesaian yang mungkin berdasarkan argumen yang diteruskan: </p> <pre><code> $ compgen -c 'ls' | head -1\n ls\n $ compgen -c 'lsp' | head -1\n lspci\n</code></pre>","votes":"2","source":"https://superuser.com/a/604973","author":"<a href=\"https://superuser.com/users/185478/nykakin\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Nykakin</span></a>","replies":[{"reply":"terima kasih atas jawaban rinci Anda :) sayangnya saya tidak dapat memverifikasi itu berfungsi karena tampaknya tidak ada stdbuf di cygwin (yang saya terpaksa gunakan di tempat kerja saat ini). Pasti akan mencobanya akhir pekan ini.","author":"<a href=\"https://superuser.com/users/226207/nicolai-fr%c3%b6hlich\" target=\"_blank\" rel=\"nofollow noopener\">Nicolai Fr&#xF6;hlich</a>"},{"reply":"@nifr: apakah Anda mencobanya? dapatkah Anda memposting apakah itu berhasil?","author":"<a href=\"https://superuser.com/users/23135/iconoclast\" target=\"_blank\" rel=\"nofollow noopener\">iconoclast</a>"}]}]}
