{"title":"Format heksadesimal dan penyimpanan di hard drive komputer: Apakah disimpan dalam setengah byte?","draft":false,"url":"/format-heksadesimal-dan-penyimpanan-di-hard-drive-komputer-apakah-disimpan-dalam-setengah-byte-h9soswo4","votes":"4","answers_count":"3","categories":["Komputer"],"tags":["hard-drive","storage","hexadecimal"],"snippet":"Izinkan saya untuk mengatakan bahwa saya bukan spesialis komputer. Lebih dari segalanya, saya penasaran dengan informasinya.  Dalam percakapan dengan pakar ilmu komputer, saya diberi tahu bahwa rangkaian nilai numerik desimal, seperti 73829182093,...","body":"<p> Izinkan saya untuk mengatakan bahwa saya bukan spesialis komputer. Lebih dari segalanya, saya penasaran dengan informasinya. </p>\n\n<p> Dalam percakapan dengan pakar ilmu komputer, saya diberi tahu bahwa rangkaian nilai numerik desimal, seperti 73829182093, bisa jadi <strong> disimpan </strong> pada hard drive yang hanya menempati setengah dari byte yang dibutuhkan dengan memanfaatkan sistem heksadesimal. Seperti yang dikatakan oleh spesialis, rangkaian enam angka desimal dapat disimpan sebagai 3-byte, karena setiap angka dapat diwakili oleh digit hex, yang hanya berukuran 4-bit. Apakah ini benar terkait dengan penyimpanan di hard drive? Catatan, saya merujuk penyimpanan pada hard drive, bukan memori yang diperlukan untuk menampilkan. </p>\n\n<p> Pemahaman saya sebelumnya adalah bahwa semua informasi disimpan dalam bentuk biner (0s dan 1s) pada hard drive, dan dalam blok 8-bit, di hard drive komputer modern. Dan heksadesimal itu digunakan untuk memfasilitasi <strong> layar </strong> informasi, jadi manusia tidak perlu membaca blok bit yang panjang. </p>\n\n<p> Jika ini benar, apakah ini berarti bahwa dalam skenario tertentu, blok 8 bit pada hard drive, di bawah penyimpanan heksadesimal, akan menjadi pengkodean untuk dua setengah byte data, bukan 8 bit penuh untuk sebuah karakter, seperti huruf &quot;M&quot;? Atau pada hard drive, apakah setengah byte sebenarnya diwakili dengan 8 bit penuh dan kemudian dihilangkan begitu saja saat ditampilkan? </p>\n\n<p> Terima kasih. </p>","source":"https://superuser.com/questions/1175060/hexadecimal-format-and-storage-on-a-computer-hard-drive-does-it-store-in-half-t","author":"<a href=\"https://superuser.com/users/693644/j-j\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">J. J.</span></a>","replies":[{"reply":"Sebenarnya, HDD menyimpan data di beberapa sektor, mis. 512 byte. Mengubah satu bit dalam satu byte pada drive memerlukan penulisan ulang seluruh sektor.","author":"<a href=\"https://superuser.com/users/502557/ron-maupin\" target=\"_blank\" rel=\"nofollow noopener\">Ron Maupin</a>"},{"reply":"@RonMaupin Tapi itu tidak masalah, dan bahkan itu sewenang-wenang. Di pihak kita (dan di &quot;pihak kita&quot; saya menarik garis itu pada pengembang kernel / driver) mereka <i> muncul </i> untuk beroperasi pada byte, dan selama mereka terus melakukannya, kami sebenarnya tidak peduli bagaimana penyimpanan itu sendiri <i> diimplementasikan </i> .","author":"<a href=\"https://superuser.com/users/245945/jason-c\" target=\"_blank\" rel=\"nofollow noopener\">Jason C</a>"}],"answers":[{"answer":"<blockquote>\n  <p> Pemahaman saya sebelumnya adalah bahwa semua informasi disimpan dalam bentuk biner (0s dan 1s) pada hard drive, dan dalam blok 8-bit, di hard drive komputer modern. Dan heksadesimal itu digunakan untuk memfasilitasi tampilan informasi, jadi manusia tidak perlu membaca blok bit yang panjang. </p>\n</blockquote>\n\n<p> Itu 100% benar. Heksadesimal hanyalah a <em> perwakilan </em> data; tidak ada yang istimewa tentang sifat heksadesimal dibandingkan dengan format lain. Itu tidak mengaktifkan kompresi data atau semacamnya. </p>\n\n<p> Saya pikir yang dimaksud teman Anda adalah perbedaan antara <strong> mewakili angka sebagai string karakter </strong> melawan <strong> mewakili angka sebagai angka </strong> . </p>\n\n<p> Untuk unsigned integer - yang merupakan representasi bilangan dalam bit (nol dan satu) dari 0 ke bilangan tertentu, tetap, maksimum - bilangan maksimum yang dapat diwakili oleh N bit adalah 2 ^ N, minus 1, dengan asumsi Anda mulai dengan 0. </p>\n\n<p> Jadi, jika Anda memiliki 8 bit (alias 1 byte), Anda dapat merepresentasikan setiap angka dari 0 hingga 255 tanpa kehilangan informasi; Anda dapat memanipulasi delapan bit ini antara 0 dan 1 untuk secara jelas mewakili setiap angka dari 0 hingga 255, inklusif. Atau dari 1 hingga 256, jika Anda mau. Tidak masalah. Komputer cenderung merepresentasikannya mulai dari 0. </p>\n\n<p> Jika Anda memiliki 16 bit (2 byte), Anda dapat mewakili setiap angka dari 0 hingga 65535 (yaitu 2 ^ 16 - 1). 32 bit, setiap angka dari 0 hingga 4294967295. 64 bit, setiap angka dari 0 hingga angka 1,8 dengan <strong> sembilan belas angka nol </strong> . </p>\n\n<p> Anda mungkin tahu dari aljabar bahwa 2 ^ N adalah <em> eksponensial </em> fungsi. Artinya, meskipun 64 bit itu saja <em> delapan kali lebih banyak bit </em> dari 8 bit, dapat menyimpan cara, cara, <strong> cara </strong> lebih banyak data dalam 8-kali-lebih-bit daripada angka <code>255*8</code> (yang hanya 2040!). 2040 adalah angka yang sangat kecil dibandingkan dengan sekitar 180000000000000000000. Dan 64 bit dapat menyimpan SETIAP angka dari 0 hingga maksimum itu. </p>\n\n<p> Salah satu implikasi menarik dari bilangan bulat yang disimpan dengan cara ini adalah programmer harus memutuskan <em> di muka </em> seberapa besar penyimpanan yang dibutuhkan, yang pada gilirannya, menentukan jumlah maksimum yang dapat diwakili oleh bilangan bulat tertentu. Jika Anda mencoba menyimpan nomor yang lebih besar dari yang dapat ditangani penyimpanan, Anda mendapatkan sesuatu yang dipanggil <em> meluap </em> . Ini terjadi, misalnya, jika Anda memiliki bilangan bulat 8-bit, yang disetel ke 255, dan Anda meminta komputer untuk menambahkan 1 ke dalamnya. Nah, Anda tidak dapat merepresentasikan 256 dalam bilangan bulat yang rentangnya 0 hingga 255! Apa yang biasanya terjadi adalah &quot;membungkus&quot; kembali ke awal, dan kembali ke 0. </p>\n\n<p> Sana <em> adalah </em> program yang menjalankan matematika dalam mode yang disebut &quot;presisi sewenang-wenang&quot; yang secara otomatis mengubah ukuran penyimpanannya untuk tumbuh semakin besar tergantung pada seberapa besar angka yang ditangani; misalnya, jika Anda mengalikan 255 dengan 100000, jawabannya harus melebihi 8 bit, dan melampaui 16 bit, tetapi akan cocok dengan bilangan bulat 32-bit. Jika Anda memasukkan angka atau melakukan operasi matematika yang menghasilkan angka lebih besar dari maksimum untuk bilangan bulat 64-bit, itu harus mengalokasikan lebih banyak ruang untuk itu. </p>\n\n<hr>\n\n<p> NAMUN - jika Anda merepresentasikan angka sebagai a <strong> string karakter </strong> , maka setiap angka akan menggunakan ruang sebanyak a <em> surat </em> dalam prosa tertulis. &quot;ASDF&quot; dan &quot;1234&quot; menempati ruang yang persis sama. &quot;OneTwoThreeFourFive&quot; (19 karakter) menggunakan ruang yang sama dengan &quot;1234567890123456789&quot;. Jumlah ruang yang dibutuhkan bertambah <strong> linier </strong> dengan nomor <em> nomor </em> (atau huruf, atau <em> karakter </em> , secara umum) yang Anda miliki. Itu karena setiap karakter dapat mewakili banyak sekali karakter di dalam <em> set karakter </em> , dan angka hanyalah karakter dalam kumpulan karakter. Urutan tertentu dari nol dan satu akan menghasilkan angka &quot;3&quot;, urutan yang berbeda akan menghasilkan &quot;4&quot;, dll. </p>\n\n<p> Biasanya karakter disimpan menggunakan 8 atau 16 bit, tetapi beberapa karakter <em> pengkodean </em> mengambil sejumlah variabel bit tergantung pada karakter (seperti UTF-8), atau selalu mengambil jumlah bit yang lebih besar (seperti UCS-32). </p>\n\n<p> Jika setiap karakter mengambil 8 bit, &quot;OneTwoThreeFourFive&quot; dan &quot;1234567890123456789&quot; keduanya mengambil 152 bit. Tapi &quot;1234567890123456789&quot; bisa muat di dalam file <strong> Integer 64-bit unsigned </strong> , yang ... hanya dikonsumsi <em> 64 bit </em> . Itu penghematan 88 bit! Dan kami bahkan tidak menggunakan trik &quot;kompresi data&quot; seperti Zip, 7-Zip, RAR, dll. </p>","votes":"5","source":"https://superuser.com/a/1175066","author":"<a href=\"https://superuser.com/users/144607/allquixotic\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">allquixotic</span></a>","replies":[]},{"answer":"<blockquote>\n  <p> Pemahaman saya sebelumnya adalah bahwa semua informasi disimpan dalam bentuk biner (0s dan 1s) pada hard drive, dan dalam blok 8-bit, di hard drive komputer modern. Dan heksadesimal itu digunakan untuk memfasilitasi tampilan informasi, jadi manusia tidak perlu membaca blok bit yang panjang. </p>\n</blockquote>\n\n<p> Pemahaman Anda sebelumnya benar-benar tepat, dan saya merasa Anda sudah memahami sisa jawaban ini, tetapi saya ingin menjelaskan beberapa gagasan yang sering disamakan orang. Saya akan berusaha sesingkat mungkin, tetapi itu akan sulit. </p>\n\n<h2 class=\"h4\"> Byte, Penyimpanan </h2>\n\n<p> Data biasanya disimpan di hard drive (atau dalam memori) dalam blok 8-bit yang disebut byte. Sebuah bit tunggal memiliki dua kemungkinan nilai, yang, secara konvensi, kita sebut sebagai 0 dan 1. Oleh karena itu, sebuah byte tunggal memiliki 2 <sup> 8 </sup> = 256 kemungkinan nilai. </p>\n\n<p> Saya sebenarnya tidak tahu mengapa blok 8-bit adalah unit tipikal. Saya tidak begitu paham dengan sejarah perkembangan komputer untuk mengetahui hal itu, tetapi setidaknya saya dapat memberi tahu Anda bahwa kami <em> terus </em> menggunakan byte 8-bit pada sistem umum karena kami agak terkunci pada saat ini dan tidak ada alasan untuk mengubahnya. </p>\n\n<p> Juga, karena saya tahu ini akan muncul, pada kenyataannya data tidak selalu disimpan di drive dalam blok satu byte atau satu byte pada satu waktu. Hard drive tipikal sering menggunakan blok yang lebih besar, dll. Namun, untuk cakupan pertanyaan Anda, tidak ada yang penting. Yang penting adalah itu <em> muncul di hadapan kita </em> bahwa hard drive beroperasi pada byte individu. Implementasi sebenarnya adalah topik yang menarik tetapi tidak mempengaruhi kita di sini: secara tradisional, manusia umumnya mendiskusikan penyimpanan dalam hal byte individu, dan kita mungkin <em> adalah </em> manusia. </p>\n\n<h2 class=\"h4\"> Biner, Heksadesimal </h2>\n\n<p> Alasan kita sering menggunakan notasi biner ketika membahas nilai hal-hal yang berhubungan dengan bit seperti byte adalah karena itu paling masuk akal. Karena bit memiliki dua kemungkinan nilai, ini secara alami diterjemahkan menjadi representasi bilangan biner (arti biner setiap digit memiliki dua nilai yang mungkin, berlawanan dengan sistem desimal yang biasanya kita gunakan setiap hari, di mana setiap digit memiliki sepuluh kemungkinan nilai). </p>\n\n<p> Alasan kami programmer juga suka menggunakan notasi heksadesimal (setiap digit memiliki enam belas kemungkinan nilai) adalah karena itu <em> sangat nyaman </em> . Kebetulan rentang yang diwakili oleh satu digit heksadesimal sama persis dengan rentang yang diwakili oleh empat digit biner. Dan ini cocok dengan byte 8-bit kami: dua digit hex dapat mewakili setiap nilai byte. Ini juga sistem yang dapat diatur untuk otak kita, sangat mudah untuk menghubungkan hex ke biner setelah Anda terbiasa. </p>\n\n<p> Kami bisa saja menggunakan sistem base-256 secara tertulis, tetapi itu akan merepotkan, karena sulit untuk menghasilkan 256 karakter yang mudah diketik, diucapkan, dan diingat. Kita bisa saja menggunakan sistem basis 17 tetapi itu tidak sesuai dengan bilangan biner 8 digit. Jadi kami menggunakan heksadesimal, karena itu sangat masuk akal bagi kami. </p>\n\n<h2 class=\"h4\"> Teks </h2>\n\n<p> Kami banyak menggunakan teks, jadi demi keuntungan kami menemukan cara standar untuk mewakili karakter yang kami gunakan setiap hari sebagai rangkaian byte. Pemetaan karakter ke byte ini disebut &quot;pengkodean karakter&quot; atau &quot;kumpulan karakter&quot;. Tentu saja, kami payah dalam benar-benar menyetujui berbagai hal, dan juga banyak pemetaan yang berbeda dikembangkan secara mandiri untuk banyak kebutuhan yang berbeda, jadi kami memiliki banyak himpunan karakter, seperti ASCII, atau ISO-8859-1, atau <a href=\"https://en.wikipedia.org/wiki/JIS_encoding\" rel=\"nofollow noopener\" target=\"_blank\"> JIS </a> . </p>\n\n<p> Selain itu, unicode diciptakan untuk mencoba mendefinisikan standar yang membuat semua orang senang, menyatukan semua pengkodean berbagai karakter kami, maka dinamai &quot;unicode&quot;. </p>\n\n<p> Tetapi intinya adalah, teks diwakili oleh serangkaian byte, dan arti sebenarnya dari setiap rangkaian byte ditentukan oleh berbagai pengkodean karakter, dan fakta bahwa byte mewakili teks sama sekali bergantung pada asumsi bahwa program yang membaca byte memahami bahwa mereka seharusnya mewakili teks. ASCII adalah salah satu yang nyaman untuk dibicarakan karena setiap karakter memetakan tepat satu byte, dan juga sangat tua, sangat sederhana, sangat banyak digunakan, dan meskipun sangat tidak memadai untuk komunitas global, masih sangat populer dan mudah untuk didiskusikan. </p>\n\n<h2 class=\"h4\"> Semantik </h2>\n\n<p> Ini, saya yakin, hal yang paling membingungkan bagi banyak orang. </p>\n\n<p><em> Byte hanyalah byte. Mereka pada dasarnya memiliki nilai yang sewenang-wenang. Apa sebenarnya nilai-nilai itu <strong> berarti </strong> ditentukan hanya oleh konteks dan oleh apa program yang sebenarnya membacanya dengan mereka. </em></p>\n\n<p> Misalnya, mengingat bahwa satu byte dapat mengambil 256 nilai, nilai 97 (biner 01100001, heksadesimal 61), pada akhirnya, dapat berarti <em> banyak </em> hal yang berbeda: </p>\n\n<ul>\n<li> Jika byte diperlakukan sebagai nilai integer, itu adalah angka 97. </li>\n<li> Jika byte diperlakukan sebagai karakter ASCII, itu adalah huruf <code>a</code>. </li>\n<li> Jika byte diperlakukan sebagai instruksi mesin untuk prosesor yang kompatibel dengan Intel x86, itu adalah instruksi <code>POPA</code> atau <code>POPAD</code> (tidak masalah jika Anda tidak tahu apa ini, bukan itu intinya). </li>\n<li> Jika byte mewakili piksel dalam gambar skala abu-abu, itu mungkin <a href=\"http://www.colorpicker.com/616161\" rel=\"nofollow noopener\" target=\"_blank\"> warna abu-abu ini </a> . </li>\n<li> Jika byte adalah bagian dari beberapa data peta untuk beberapa permainan, mungkin itu pohon atau pagar atau semacamnya. </li>\n<li> Dll </li>\n</ul>\n\n<p> Bahkan untuk nilai numerik pola bit dapat memiliki arti yang berbeda, misalnya: </p>\n\n<ul>\n<li> Terkadang kami puas dengan nilai 0-255. Di lain waktu kami ingin menangani bilangan negatif jadi kami menggeser kisaran nilai semantik ke -128 hingga 127 dan menggunakan bit pertama untuk menunjukkan apakah itu negatif atau tidak. Atau terserah. Langit adalah batasnya (meskipun, seperti pengkodean karakter, ada sekumpulan aturan standar yang disepakati secara umum untuk nilai integer juga). </li>\n<li> Terkadang karena berbagai keadaan, kami bahkan menyandikan nilai integer dengan cara lain, mis. <a href=\"https://en.wikipedia.org/wiki/Binary-coded_decimal\" rel=\"nofollow noopener\" target=\"_blank\"> BCD </a> . </li>\n<li> Terkadang kita perlu merepresentasikan bilangan bulat yang lebih besar. Jadi kami menggunakan banyak byte. Bahkan ini punya pilihan, lihat <a href=\"https://en.wikipedia.org/wiki/Endianness\" rel=\"nofollow noopener\" target=\"_blank\"> &quot;ketekunan&quot; </a> . </li>\n<li> Terkadang kita perlu merepresentasikan angka desimal. Banyak pilihan di sini juga, lihat <a href=\"https://en.wikipedia.org/wiki/Floating_point\" rel=\"nofollow noopener\" target=\"_blank\"> floating-point </a> dan <a href=\"https://en.wikipedia.org/wiki/Fixed-point_arithmetic\" rel=\"nofollow noopener\" target=\"_blank\"> titik pasti </a> untuk opsi di sini. </li>\n</ul>\n\n<p> Inti dari semua ini adalah byte hanyalah satu byte, itu tidak berarti apa-apa sampai Anda memiliki konteks. Jika sebuah program menulis beberapa byte dengan makna yang dimaksudkan, hanya program yang membacanya dan menafsirkannya sebagai memiliki makna yang sama yang dapat memahaminya dengan tepat. </p>\n\n<h2 class=\"h4\"> Menyatukan Ini Semua </h2>\n\n<p> Jadi sekarang, menghubungkan ini semua kembali ke jawaban Anda, ini seharusnya sangat sederhana sekarang: </p>\n\n<ul>\n<li> Teman Anda mengacu pada gagasan Anda menyimpan nomor sebagai <em> representasi tekstual dari nilainya dalam heksadesimal </em> . Misalnya, nilai 97, dalam hex mungkin 61. Ini adalah angka dua digit, berisi karakter &quot;6&quot; diikuti dengan &quot;1&quot;. Dienkode sebagai <a href=\"http://www.asciitable.com/\" rel=\"nofollow noopener\" target=\"_blank\"> ASCII </a> itu akan menjadi dua byte: nilai 54 diikuti dengan nilai 49 (desimal). <em> Tetapi itu hanya memiliki arti jika, ketika Anda membaca kembali byte tersebut, Anda memahaminya sebagai dua digit heksadesimal yang dikodekan ASCII. </em></li>\n<li> Anda juga bisa menyimpan nilai 97. Itu hanya satu byte. Itu setengah dari panjang opsi sebelumnya. Tapi tentu saja, <em> yang hanya memiliki arti jika, ketika Anda membaca kembali byte tersebut, Anda memahaminya sebagai terkait langsung dengan nilai integer </em> . </li>\n</ul>\n\n<p><em> Khas </em> , kami para pemrogram mungkin akan memilih opsi kedua, tetapi itu benar-benar tergantung pada konteks. Misalnya, dalam dokumen HTML, yang dirancang untuk menjadi teks yang dapat dibaca manusia, kami masih menyimpan atribut seperti <code>width=\"97\"</code>. Tentu mungkin membutuhkan lebih sedikit ruang untuk menggunakan beberapa representasi yang lebih ketat di sini, tapi kemudian akan merepotkan untuk tulis HTML. Jadi itu sangat tergantung pada konteks dan kasus penggunaan. </p>\n\n<p> Saya harap setidaknya sebagian dari ini masuk akal. </p>","votes":"3","source":"https://superuser.com/a/1175070","author":"<a href=\"https://superuser.com/users/245945/jason-c\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Jason C</span></a>","replies":[]},{"answer":"<blockquote>\n  <p> string enam angka desimal dapat disimpan sebagai 3-byte </p>\n</blockquote>\n\n<p> Kedengarannya seperti BCD, desimal berkode biner, representasi versus karakter ASCII numerik (byte penuh per digit). Empat bit digunakan untuk mewakili nilai 0 hingga 9. (Enam nilai lainnya tidak ditentukan / tidak valid.) <br> Nilai BCD dapat dibongkar (satu digit BCD per byte) atau dikemas (dua digit BCD per byte). </p>\n\n<p> Keuntungan menggunakan BCD versus biner adalah kenyamanan untuk tampilan manusia (yaitu konversi sepele) dan tidak ada kehilangan akurasi untuk pecahan desimal (misalnya sepersepuluh adalah bilangan biner berulang yang tak terbatas). </p>\n\n<p> Kalkulator biasanya menggunakan representasi BCD, bukan biner. String panjang angka pada kartu kredit dan kartu keamanan / akses biasanya dikodekan sebagai string BCD pada strip magnetik atau dalam paket RF yang ditransmisikan. <br> Komputer digital biasanya menggunakan representasi biner untuk kalkulasi dan penyimpanan. CPU mungkin memiliki instruksi untuk melakukan aritmatika BCD. </p>","votes":"0","source":"https://superuser.com/a/1175069","author":"<a href=\"https://superuser.com/users/83462/sawdust\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">sawdust</span></a>","replies":[]}]}
