{"title":"Apakah itu bug? Penutupan segera jendela cmd saat ini saat menjalankan: move nul 2&gt; &amp; 0","draft":false,"url":"/apakah-itu-bug-penutupan-segera-jendela-cmd-saat-ini-saat-menjalankan-move-nul-2gt-amp-0-wc1cpjd2","votes":"4","answers_count":"1","categories":["Komputer"],"tags":["windows","command-line","batch","cmd.exe"],"snippet":"Akhirnya, saya gunakan  move nul 2&gt;&amp;0  dalam skrip saya untuk &quot;tiba-tiba&quot; menutup jendela cmd saat ini, dan dengan demikian segera membatalkan / menutup kelelawar yang sedang berjalan.  Saya tidak bisa mengatakan itu...","body":"<p> Akhirnya, saya gunakan <strong> <code>move nul 2&gt;&amp;0</code> </strong> dalam skrip saya untuk &quot;tiba-tiba&quot; menutup jendela cmd saat ini, dan dengan demikian segera membatalkan / menutup kelelawar yang sedang berjalan. </p>\n<p> Saya tidak bisa mengatakan itu bekerja seperti bunuh diri dalam naskah, tapi saya biasanya menyebutnya begitu. </p>\n<p> Faktanya, ini menghasilkan pembunuhan otomatis yang memperluas / mencapai efek juga di jendela cmd saat ini. </p>\n<p> Ini adalah sesuatu yang lain dari sekedar menutup / mengakhiri kelelawar yang sedang berlari. </p>\n<p> Pada dasarnya digunakan untuk beberapa batch dimana nilai variabelnya <strong> <code>&quot;%cmdcmdline%&quot;</code> </strong> untuk menanggapi dengan menjalankan dipanggil oleh klik, bukan hanya menutup bat, juga menutup jendela yang diaktifkan / dimuat dengan mengklik bat. </p>\n<p> Yang saya heran adalah: </p>\n<p><strong> 1. </strong> Apa yang menjelaskan perilaku ini? <br>\n<strong> 2. </strong> Apakah ini bug? <br>\n<strong> 3. </strong> Di masa depan mungkinkah itu tidak berperilaku sama? </p>\n<p> Beberapa contoh kode: </p> <pre><code>@echo off \n\ntitle &#60;nul \ntitle to kill or not to kill?\n\nmode 50,05\n\necho\\%cmdcmdline%|find \"%~0\" &#62;nul && (\n     echo\\\n     echo\\ so sorry bro, I'll kill myself\n     echo\\ and this CMD.exe window too!\n     \n     timeout 5 /nobreak \n     <b>move nul 2&#62;&0</b> \n   )\n\necho/ will run this code bro!\necho/\necho/ keep itself alive: %date% %time:~0,5%\necho/\npause</code></pre>","source":"https://superuser.com/questions/1620933/would-that-be-a-bug-immediate-closing-of-the-current-cmd-window-when-executing","author":"<a href=\"https://superuser.com/users/969781/it-wasnt-me\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">It Wasn&#39;t Me</span></a>","replies":[{"reply":"Terkait <a href=\"https://stackoverflow.com/questions/818255/in-the-shell-what-does-21-mean\" title=\"in the shell what does 21 mean\" target=\"_blank\" rel=\"nofollow noopener\"> stackoverflow.com/questions/818255/â€¦ </a> Saya menduga bahwa &quot;0&quot; adalah <code>stdin</code> dan pada dasarnya Anda menggemakan karakter ilegal ke <code>stdin</code> dan memaksa sesi konsol untuk memutuskan sambungan. Hasilnya adalah sesi perintah Anda ditutup dan mengambil skrip bersamanya.","author":"<a href=\"https://superuser.com/users/19943/mokubai\" target=\"_blank\" rel=\"nofollow noopener\">Mokubai&#9830;</a>"},{"reply":"@DrinkSomePimpJuiceIT perintah (ada) commad: echo 2&gt; &amp; 4 juga melakukan hal yang sama, dan saya tahu itu, tapi saya menghargai komentar Anda ...","author":"<a href=\"https://superuser.com/users/969781/it-wasnt-me\" target=\"_blank\" rel=\"nofollow noopener\">It Wasn&#x27;t Me</a>"},{"reply":"<code>echo 2&gt;&amp;4</code> memberikan pesan kesalahan (diharapkan), tetapi tidak mematikan jendela. Sama dengan <code>echo 2&gt;&amp;0</code> atau <code>echo 2&gt;0</code>. Saya tidak mencoba perintah lain, tetapi jelas itu bukan &quot;perintah apa pun&quot;.","author":"<a href=\"https://superuser.com/users/217811/stephan\" target=\"_blank\" rel=\"nofollow noopener\">Stephan</a>"},{"reply":"Apa yang salah dengan menggunakan <code>exit</code>?","author":"<a href=\"https://superuser.com/users/22383/neil\" target=\"_blank\" rel=\"nofollow noopener\">Neil</a>"}],"answers":[{"answer":"<p> Saya kesulitan dengan frasa Anda &quot;jendela cmd saat ini&quot; - tidak yakin apa yang Anda maksud. Dalam pikiran saya, Anda menggabungkan dua konsep yang berbeda </p>\n<ul>\n<li> Ada proses konsol - analog dengan, tetapi tidak persis sama dengan terminal </li>\n<li> Dan ada proses cmd.exe yang dijalankan di dalam jendela konsol </li>\n</ul>\n<p> Perintah Anda merusak proses cmd.exe, dan proses konsol Anda dengan bersih dimatikan karena tidak lagi memiliki proses yang berjalan di dalamnya. </p>\n<p> Ini mudah dibuktikan jika Anda menjalankan perintah dalam proses cmd.exe anak ekstra - cmd.exe anak lumpuh, tetapi induk tetap valid, sehingga jendela konsol juga tetap berjalan. Berikut ini contoh mulai dari proses cmd.exe baru yang berjalan di konsol. </p> <pre><code>Microsoft Windows [Version 10.0.18363.1256]\n(c) 2019 Microsoft Corporation. All rights reserved.\n\nP:\\&gt;set context=outer\n\nP:\\&gt;cmd\nMicrosoft Windows [Version 10.0.18363.1256]\n(c) 2019 Microsoft Corporation. All rights reserved.\n\nP:\\&gt;set context=inner\n\nP:\\&gt;move nul 2&gt;&amp;0\n\nP:\\&gt;set context\ncontext=outer\n\nP:\\&gt;\n</code></pre> <p> Fakta bahwa konteks = luar pada akhirnya membuktikan bahwa lingkungan dalam telah hilang, alasannya adalah bahwa proses batin telah gagal. Jika saya kemudian mengeluarkan perintah KELUAR, maka proses cmd.exe luar berhenti dan konsol ditutup. </p>\n<p> Sekarang mengapa perintah Anda crash cmd.exe. Tidak ada yang istimewa tentang penggunaan perintah <code>MOVE</code> atau perangkat <code>nul</code> Anda. Bagian penting adalah bahwa cmd.exe mencoba untuk menulis pesan kesalahan ke stderr setelah itu telah diarahkan ke stdin. Jelas itu tidak dapat berfungsi, jadi penulisan gagal - ini adalah pemicu yang menyebabkan cmd.exe macet. </p>\n<p> Efek yang sama dapat dicapai dengan kesalahan pembagian dengan nol melalui <code>SET /A 1/0 2&gt;&amp;0</code>. </p>\n<p> Penting untuk diperhatikan bahwa pengalihan sebenarnya berhasil. Pengalihan tidak peduli bahwa stdin tidak dapat menerima keluaran, ia secara membabi buta menjalankan pengalihan. Kegagalan hanya terjadi jika rutinitas penulisan kesalahan cmd.exe mencoba untuk benar-benar menulis ke stderr yang diarahkan ulang. </p>\n<p> Sangat mudah untuk mendemonstrasikan bahwa pengalihan berhasil jika Anda mengalihkan perintah yang tidak menulis ke stderr. Misalnya, <code>echo Hello world 2&gt;&amp;0</code> melakukan pengalihan yang tidak masuk akal dan berhasil menulis pesan ke stdout. </p>\n<p> Di suatu tempat di DosTips saya memiliki beberapa posting di mana saya menyelidiki bagaimana cmd.exe menangani kesalahan I / O. Saya berharap saya dapat menemukan posting itu. Saya yakin pengujian saya melibatkan pengalihan stdout atau stderr ke perangkat yang dapat dilepas, dan kemudian berhenti. Selama jeda, saya akan melepas perangkat, lalu melanjutkan. Saya kemudian akan mengamati perilaku ketika saya mencoba untuk menulis ke perangkat yang hilang melalui stdout atau stderr. Dari apa yang saya ingat, semua gagal menulis ke stderr segera crash cmd.exe. </p>\n<p> Apakah ini bug atau cacat desain? Tidak yakin. Orang dapat berargumen bahwa mungkin hal teraman untuk dilakukan jika pelaporan kesalahan gagal adalah menghentikannya. Tapi saya tidak yakin itu adalah &quot;fitur&quot; yang direncanakan karena ketika menulis ke stdout gagal, tidak ada pesan kesalahan atau kesalahan yang dikembalikan apa-apa-pernah! Output menghilang begitu saja ke eter, cmd.exe dengan riang berjalan seolah-olah tidak ada hal buruk yang terjadi. Tidak mungkin bagi batch untuk mendeteksi kegagalan saat menulis ke stdout. Menurut saya itu mengerikan. Saya hanya bisa berasumsi bahwa pengembang cmd.exe tidak pernah repot-repot mempertimbangkan kemungkinan itu. Jadi jika itu benar, maka fakta bahwa kegagalan stderr crash dengan mudah bisa menjadi kecelakaan (bahagia?). </p>\n<p> Ada beberapa perbedaan lain antara perilaku stdout dan stderr. Keduanya adalah buffer, tetapi mereka berperilaku berbeda jika ada buffer overflow. Saya berharap saya dapat mengingat apa perbedaan itu :-( </p>\n<p><em><strong> Memperbarui </strong></em></p>\n<p> Saya menemukan beberapa investigasi saya di <a href=\"https://www.dostips.com/forum/viewtopic.php?t=6881\" rel=\"nofollow noopener\" target=\"_blank\"> https://www.dostips.com/forum/viewtopic.php?t=6881 </a></p>\n<p> Menulis ke stdout sedikit lebih rumit daripada yang tersirat pada tulisan saya di atas. Cmd.exe memiliki beberapa rutinitas internal yang mencoba menulis ke stdout. Sebagai contoh: </p>\n<ul>\n<li> Perintah ECHO </li>\n<li> Pesan SET / P (prompt untuk input) </li>\n<li> Prompt baris perintah dan gema baris perintah batch (saat ECHO ON) </li>\n<li> Output dari perintah seperti DIR, dll. </li>\n</ul>\n<p> Beberapa dari titik masuk yang menulis ke stdout ini mungkin memiliki perilakunya sendiri saat terjadi kegagalan tulis. Tautan saya di atas menjelaskan perbedaan antara ECHO dan SET / P misalnya. </p>\n<p> Saya tidak yakin, tapi saya yakin pesan kesalahan untuk stderr berbeda. Saya yakin semua pelaporan kesalahan disalurkan melalui satu rutinitas internal yang macet ketika ada kesalahan tulis. Tautan saya di atas tidak benar-benar menyelidiki ini. Saya masih mencari posting selanjutnya yang lebih baik menyelidiki kesalahan I / O (dan masalah buffering) </p>","votes":"10","source":"https://superuser.com/a/1621015","author":"<a href=\"https://superuser.com/users/109090/dbenham\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">dbenham</span></a>","replies":[{"reply":"&#39;Jendela cmd&#39; dari proses saat ini, tanpa proses anak, dan mulai sekarang, saya akan lebih pintar, terima kasih !. Saya hanya akan menggunakannya dalam satu lingkaran untuk menjamin jangkauan dalam proses anak: <b> <code>For &#47; L %% L in (1 1 99) do move nul 2&gt;&amp;0</code> </b> d;)","author":"<a href=\"https://superuser.com/users/969781/it-wasnt-me\" target=\"_blank\" rel=\"nofollow noopener\">It Wasn&#x27;t Me</a>"},{"reply":"\\ o \\ | o | / o / Terima kasih atas penjelasan Anda yang lengkap dan ringkas! Konten apa pun yang dapat diakses buffer Anda, di buffer lain (dan perilaku saat digunakan dalam pengalihan, dll ...), harap luangkan waktu dan tambahkan dan kami ucapkan terima kasih atas kontribusi aneh Anda.","author":"<a href=\"https://superuser.com/users/969781/it-wasnt-me\" target=\"_blank\" rel=\"nofollow noopener\">It Wasn&#x27;t Me</a>"}]}]}
