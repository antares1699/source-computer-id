{"title":"Coerce scp (1), sftp (1), atau rsync (1) untuk mentransfer pipa bernama","draft":false,"url":"/coerce-scp-1-sftp-1-atau-rsync-1-untuk-mentransfer-pipa-bernama-7sy7ekag","votes":"4","answers_count":"3","categories":["Komputer"],"tags":["ssh","scp","pipe","btrfs"],"snippet":"Saya bermaksud untuk mentransfer backup penuh dan inkremental dari subvolume btrfs saya ke layanan pengarsipan tape. Layanan memperlihatkan titik akhir FTP dan SSH. Jika saya diizinkan untuk menjalankan perintah sewenang-wenang pada titik...","body":"<p> Saya bermaksud untuk mentransfer backup penuh dan inkremental dari subvolume btrfs saya ke layanan pengarsipan tape. Layanan memperlihatkan titik akhir FTP dan SSH. Jika saya diizinkan untuk menjalankan perintah sewenang-wenang pada titik akhir SSH, maka saya akan melakukan hal berikut untuk melakukan pencadangan tambahan: </p> <pre><code>btrfs send -p $LAST_SUBVOLUME $NEXT_SUBVOLUME | compress | encrypt |\n    ssh -p $PORT $USER@$ENDPOINT \"cat &gt; $SUBVOLUME.$YYYYMMDD.btrfs.bz2.gpg\"\n</code></pre> <p> Saya, bagaimanapun, tidak diperbolehkan melakukan itu: </p> <pre><code>$ ssh -p $PORT $USER@$ENDPOINT\nLast login: Mon Jan  3 01:23:45 2067 from 123.456.789.123\n\nThis account is restricted by rssh.\nAllowed commands: scp sftp rsync \n\nIf you believe this is in error, please contact your system administrator.\n\nConnection to some.remote.endpoint closed.\n</code></pre> <p> Jadi yang saya pikirkan untuk dilakukan adalah menggunakan protokol SCP untuk transfer. Namun, biner <code>scp</code> saya menolak untuk mentransfer pipa bernama: </p> <pre><code>$ scp -P $PORT &lt;(btrfs send -p $LAST_SUBVOLUME $NEXT_SUBVOLUME | compress | encrypt) \\\n    $USER@$ENDPOINT:$SUBVOLUME.$YYYYMMDD.btrfs.bz2.gpg\n/dev/fd/63: not a regular file\n</code></pre> <p><s> Ironisnya, ternyata, <a href=\"https://bugs.launchpad.net/ubuntu/+source/openssh/+bug/275418\" rel=\"nofollow noopener\" target=\"_blank\"> <code>scp</code> dulu melakukan hal yang benar </a> . Saya kira tidak semua orang mengira mentransfer pipa bernama bisa waras / berguna. </s> <strong> EDIT (03-06-2017): </strong> Ini adalah observasi yang salah. Sebagaimana dicatat oleh Kenster, protokol SCP tidak mengizinkan pengiriman file dengan ukuran yang tidak diketahui. </p>\n\n<p><strong> UPDATE (2017-06-04): </strong> Saya juga mencoba mentransfer data menggunakan protokol SFTP. Rupanya, protokol FTP mengizinkan pengiriman file dengan ukuran yang tidak diketahui, sebagaimana dibuktikan dengan dukungan untuk data perpipaan di <code>ftp</code> ( <a href=\"http://www.krazyworks.com/using-ftp-with-pipes/\" rel=\"nofollow noopener\" title=\"Using FTP with pipes | KrazyWorks\" target=\"_blank\"> tautan </a> ) dan <code>ncftpput</code> ( <a href=\"http://www.ncftp.com/ncftp/doc/ncftpput.html\" rel=\"nofollow noopener\" title=\"ncftpput(1) manual page\" target=\"_blank\"> tautan </a> , bagian Deskripsi, paragraf terakhir) biner. Saya tidak menemukan dukungan seperti itu pada klien SFTP yang saya coba (<code>sftp</code>, <code>lftp</code>), yang mungkin merupakan indikasi bahwa SFTP (tidak seperti FTP) tidak mendukung pengiriman file dengan ukuran yang tidak diketahui (bertentangan dengan apa yang saya kira, SFTP bukan hanya FTP tunelled melalui SSH; itu adalah protokol yang berbeda). </p>\n\n<p><strong> UPDATE (2017-06-05): </strong> Menurut draf internet protokol SFTP versi 3 ( <a href=\"https://filezilla-project.org/specs/draft-ietf-secsh-filexfer-02.txt\" rel=\"nofollow noopener\" title=\"SSH File Transfer Protocol\" target=\"_blank\"> tautan </a> ), setiap paket level aplikasi harus menentukan panjang payload sebelum payload ( <a href=\"https://filezilla-project.org/specs/draft-ietf-secsh-filexfer-02.txt\" rel=\"nofollow noopener\" title=\"SSH File Transfer Protocol\" target=\"_blank\"> tautan </a> , Bagian 3). Namun, SFTP mendukung pencarian dalam file tertulis ( <a href=\"https://filezilla-project.org/specs/draft-ietf-secsh-filexfer-02.txt\" rel=\"nofollow noopener\" title=\"SSH File Transfer Protocol\" target=\"_blank\"> tautan </a> , Bagian 6.4) dengan dukungan eksplisit untuk penulisan di luar akhir file saat ini. Oleh karena itu, jika memungkinkan untuk menggunakan buffer kecil di sisi klien dan mengirim file dengan ukuran yang tidak diketahui dalam potongan berukuran kecil yang diketahui: </p> <pre><code>#!/bin/bash\n# &lt;Exchange SSH_FXP_INIT requests.&gt;\n# &lt;Send an SSH_FXP_OPEN request.&gt;\nCHUNK_SIZE=32768\nOFFSET=0\nIFS=''; while read -r -N $CHUNK_SIZE CHUNK; do\n  ACTUAL_SIZE=`cat &lt;&lt;&lt;\"$CHUNK\" | head -c -1 | wc -c`\n  # &lt;Send an SSH_FXP_WRITE request with payload $CHUNK of size\n  # $ACTUAL_SIZE at offset $OFFSET.&gt;\n  OFFSET=$(($OFFSET+$ACTUAL_SIZE))\ndone &lt; &lt;(command)\n# &lt;Send an SSH_FXP_CLOSE request.&gt;\n</code></pre> <p> Namun, melakukan komunikasi secara manual melalui cangkang akan sangat menyakitkan. Saya mencari klien SFTP yang memperlihatkan fungsionalitas semacam ini. </p>\n\n<h1 class=\"h3\"> Referensi </h1>\n\n<ul>\n<li><a href=\"https://unix.stackexchange.com/questions/291272/can-you-scp-sftp-or-rsync-a-pipe\" target=\"_blank\" rel=\"nofollow noopener\"> Bisakah Anda scp, sftp, atau rsync, pipa? - Unix &amp; Linux Stack Exchange </a></li>\n<li><a href=\"https://serverfault.com/questions/400203/how-to-pipe-data-to-sftp-connection\" target=\"_blank\" rel=\"nofollow noopener\"> ssh - bagaimana cara menyalurkan data ke koneksi sftp? - Kesalahan Server </a></li>\n<li><a href=\"http://www.krazyworks.com/using-ftp-with-pipes/\" rel=\"nofollow noopener\" title=\"Using FTP with pipes | KrazyWorks\" target=\"_blank\"> Menggunakan FTP dengan pipa | KrazyWorks </a></li>\n<li><a href=\"http://www.ncftp.com/ncftp/doc/ncftpput.html\" rel=\"nofollow noopener\" title=\"ncftpput(1) manual page\" target=\"_blank\"> <code>ncftpput(1)</code> halaman manual </a></li>\n<li><a href=\"https://filezilla-project.org/specs/draft-ietf-secsh-filexfer-02.txt\" rel=\"nofollow noopener\" title=\"SSH File Transfer Protocol\" target=\"_blank\"> Protokol Transfer File SSH </a></li>\n</ul>","source":"https://superuser.com/questions/1215633/coerce-scp1-sftp1-or-rsync1-into-transferring-a-named-pipe","author":"<a href=\"https://superuser.com/users/136765/witiko\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Witiko</span></a>","replies":[{"reply":"Saya tidak melihat bahwa <code>scp</code> digunakan untuk menangani pipa. Laporan bug yang Anda tautkan menunjukkan bahwa itu digunakan untuk menggantung tanpa batas pada pipa; sekarang malah memperingatkan Anda. Kedengarannya seperti pelaporan kesalahan yang lebih baik, bukan perubahan perilaku yang mendasarinya.","author":"<a href=\"https://superuser.com/users/424595/user4556274\" target=\"_blank\" rel=\"nofollow noopener\">user4556274</a>"},{"reply":"Yah, saya kira itu telah digantung tepat karena akan mulai membaca pipa bernama seperti file biasa.","author":"<a href=\"https://superuser.com/users/136765/witiko\" target=\"_blank\" rel=\"nofollow noopener\">Witiko</a>"}],"answers":[{"answer":"<p> <code>lftp</code> 4.6.1 dan yang lebih baru seharusnya dapat melakukan ini: <a href=\"https://github.com/lavv17/lftp/issues/104\" rel=\"nofollow noopener\" target=\"_blank\"> https://github.com/lavv17/lftp/issues/104 </a></p>\n\n<p> Sayangnya, perintah yang disarankan dalam masalah yang ditautkan tidak berfungsi, tetapi perintah yang sedikit dimodifikasi berfungsi: </p> <pre><code>lftp -p $port sftp://$user:$pass@$host -e \"put /dev/stdin -o $filename\"\n</code></pre> <p> Karena a <a href=\"https://unix.stackexchange.com/a/205067/33227\" target=\"_blank\" rel=\"nofollow noopener\"> bug </a> , Anda harus memberikan sesuatu di bidang sandi jika Anda menggunakan agen SSH. Tapi string acak apa pun bisa digunakan. </p>\n\n<p> Perintah ini membaca dari <code>/dev/stdin</code>. Jika Anda harus menggunakan pipa dengan nama yang berbeda, saya rasa itu akan bekerja juga - jika tidak, Anda selalu dapat <code>cat named-pipe | lftp ...</code>. </p>\n\n<p> Saya telah menguji <code>lftp</code> dengan unggahan&gt; 100 GB tanpa masalah. </p>\n\n<hr>\n\n<p> <code>rclone</code> juga mendukung SFTP, dan seharusnya dapat mengunggah dari input yang disalurkan dengan perintah <code>rcat</code>, yang akan dirilis pada 1,38 (versi berikutnya). </p>","votes":"3","source":"https://superuser.com/a/1252714","author":"<a href=\"https://superuser.com/users/117590/bob\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Bob</span></a>","replies":[{"reply":"Saya mendapatkan kesalahan <code>put: &#47;dev&#47;stdin: cannot seek on data source</code> dengan binari <code>lftp</code> 4.7.4 dan 4.8.1 yang dirilis oleh proyek Debian. Saya perlu memeriksa apakah ini adalah regresi dalam sumbernya, atau apakah ini adalah masalah build. Saya akan membuat ini menjadi jawaban yang diterima setelah saya berhasil mereproduksi hasil Anda.","author":"<a href=\"https://superuser.com/users/136765/witiko\" target=\"_blank\" rel=\"nofollow noopener\">Witiko</a>"},{"reply":"@Witiko Itu menarik - karena saya menguji <code>lftp</code> saat ini di Debian Stretch. Versi paket <code>4.7.4-1</code>. LFTP versi 4.7.4, Readline 7.0, GnuTLS 3.5.8, zlib 1.2.8. Perintah lengkap yang saya jalankan termasuk pipa dari <code>openssl enc</code> melalui <code>pv</code> dan kemudian ke <code>lftp</code>.","author":"<a href=\"https://superuser.com/users/117590/bob\" target=\"_blank\" rel=\"nofollow noopener\">Bob</a>"},{"reply":"@Witiko Hanya sebagai contoh, <a href=\"https://gist.github.com/BobVul/86271ddaae2733d0f888875dd52c4d45\" rel=\"nofollow noopener\" target=\"_blank\"> gist.github.com/BobVul/86271ddaae2733d0f888875dd52c4d45 </a>","author":"<a href=\"https://superuser.com/users/117590/bob\" target=\"_blank\" rel=\"nofollow noopener\">Bob</a>"},{"reply":"Anda benar, saya salah menentukan port, yang membuat <code>lftp</code> mengeluarkan pesan kesalahan yang tidak membantu di atas. Terima kasih atas sarannya, sangat dihargai!","author":"<a href=\"https://superuser.com/users/136765/witiko\" target=\"_blank\" rel=\"nofollow noopener\">Witiko</a>"},{"reply":"@Witiko Saya rasa saya tersandung pada ini dalam situasi yang sama persis dengan Anda (<code>zfs send | compress | encrypt | upload</code>) - sebenarnya penelitian Anda yang meyakinkan saya untuk melihat ke jalur SFTP daripada SCP / rsync. Jadi, terima kasih atas pertanyaan yang ditulis dengan sangat baik (dan Kenster atas analisisnya tentang SCP / SFTP). Hanya ingin tahu, apakah remote end Anda juga C14?","author":"<a href=\"https://superuser.com/users/117590/bob\" target=\"_blank\" rel=\"nofollow noopener\">Bob</a>"},{"reply":"Ya, benar.","author":"<a href=\"https://superuser.com/users/136765/witiko\" target=\"_blank\" rel=\"nofollow noopener\">Witiko</a>"},{"reply":"Dengan LFTP 4.7.4, saya mendapatkan error <code>put: &#47;dev&#47;stdin: cannot seek on data source</code>.","author":"<a href=\"https://superuser.com/users/136765/witiko\" target=\"_blank\" rel=\"nofollow noopener\">Witiko</a>"},{"reply":"@Witiko Apakah ada yang berubah sejak terakhir kali berfungsi?","author":"<a href=\"https://superuser.com/users/117590/bob\" target=\"_blank\" rel=\"nofollow noopener\">Bob</a>"},{"reply":"Bukan dari pihak saya, dan transfer berfungsi seperti biasa dengan localhost, tetapi sesuatu mungkin telah berubah di C14. Saya akan bermain-main dengan ini selama beberapa minggu ke depan dan melaporkan temuan saya.","author":"<a href=\"https://superuser.com/users/136765/witiko\" target=\"_blank\" rel=\"nofollow noopener\">Witiko</a>"},{"reply":"@Witiko Anda mungkin lebih baik melaporkan masalah ke lftp devs. Mereka mungkin lebih tahu ke mana harus mencari.","author":"<a href=\"https://superuser.com/users/117590/bob\" target=\"_blank\" rel=\"nofollow noopener\">Bob</a>"},{"reply":"Tentu, saya akan melaporkan di sini hanya jika saya merasa jawabannya akan mendapat manfaat dari temuan saya.","author":"<a href=\"https://superuser.com/users/136765/witiko\" target=\"_blank\" rel=\"nofollow noopener\">Witiko</a>"}]},{"answer":"<p> SCP tidak cocok untuk tujuan Anda. Protokol SCP tidak mendukung pengiriman aliran byte berukuran tidak diketahui ke sistem jarak jauh untuk disimpan sebagai file. Pesan protokol SCP untuk mengirim file membutuhkan ukuran file yang akan dikirim terlebih dahulu, diikuti oleh byte yang menyusun file tersebut. Dengan aliran byte yang dibaca dari pipa, Anda biasanya tidak akan tahu berapa banyak byte yang akan dihasilkan pipa sehingga tidak ada cara untuk mengirim pesan protokol SCP termasuk ukuran yang benar. </p>\n\n<p> (Satu-satunya deskripsi online dari protokol SCP yang dapat saya temukan adalah <a href=\"https://web.archive.org/web/20170215184048/https://blogs.oracle.com/janp/entry/how_the_scp_protocol_works\" rel=\"nofollow noopener\" target=\"_blank\"> sini </a> dan <a href=\"https://github.com/net-ssh/net-scp/blob/master/lib/net/scp.rb\" rel=\"nofollow noopener\" target=\"_blank\"> sini </a> . Fokus pada deskripsi pesan &quot;C&quot;.) </p>\n\n<p> Protokol SFTP <em> bisa </em> digunakan untuk hal semacam ini. Sejauh yang saya tahu, utilitas baris perintah <code>sftp</code> normal tidak mendukung membaca pipa dan menyimpannya sebagai file jarak jauh. Tetapi ada pustaka SSH / SFTP untuk sebagian besar bahasa pemrograman modern (perl, python, ruby, C #, Java, C, dll). Jika Anda tahu cara menggunakan salah satu bahasa ini, seharusnya mudah untuk menulis utilitas yang melakukan apa yang Anda butuhkan. </p>\n\n<p> Jika Anda terjebak dengan skrip shell, sangat mungkin untuk memalsukan cukup banyak protokol SCP untuk mentransfer file. Berikut contohnya: </p> <pre><code>#!/bin/bash\ncmd='cat /etc/group'\n\nsize=$($cmd | wc -c)    \n{\n        echo C0644 $size some-file\n        $cmd\n        echo -n -e '\\000'\n} | ssh user@host scp -v -p -t /some/directory\n</code></pre> <p> Ini akan membuat <code>some-file</code> pada <code>/some/directory</code> pada sistem jarak jauh dengan izin 644. Isi file akan menjadi apa pun yang <code>$cmd</code> tulis ke keluaran standarnya. Perhatikan bahwa Anda menjalankan perintah dua kali, dengan konsumsi sumber daya dan efek samping apa pun yang menyiratkannya. Dan perintahnya <em> harus </em> menghasilkan jumlah byte yang sama setiap kali. </p>","votes":"6","source":"https://superuser.com/a/1215719","author":"<a href=\"https://superuser.com/users/54530/kenster\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Kenster</span></a>","replies":[{"reply":"Saya akan sangat senang untuk melakukan dua operan - yang pertama untuk mengetahui ukurannya dan yang kedua untuk melakukan pengiriman melalui scp; ini bukan solusi yang paling elegan, tetapi incremental backup semuanya akan di-cache di RAM. Perpustakaan adalah pilihan, tapi saya berharap saya bisa melakukan ini dari shell.","author":"<a href=\"https://superuser.com/users/136765/witiko\" target=\"_blank\" rel=\"nofollow noopener\">Witiko</a>"},{"reply":"Terima kasih atas penelitian yang dilakukan untuk menulis skrip shell itu. Bagi saya, ini adalah jawaban yang memuaskan untuk pertanyaan awal. Namun, saya masih akan menjelajahi rute SFTP, karena perbedaan kecepatan antara single-pass dan two-pass akan terlihat untuk backup yang lebih besar.","author":"<a href=\"https://superuser.com/users/136765/witiko\" target=\"_blank\" rel=\"nofollow noopener\">Witiko</a>"}]},{"answer":"<p> Jika Anda bisa menulis perl, Anda bisa mencoba menggunakan <a href=\"https://metacpan.org/pod/Net::SFTP::Foreign\" rel=\"nofollow noopener\" target=\"_blank\"> Net :: SFTP :: Asing </a> yang dapat mentransfer file dari deskriptor file terbuka melalui SFTP: </p> <pre><code>#!/usr/bin/perl\n# untested!\nuse Net::SFTP::Foreign;\nmy $user = ...;\nmy $host = ...;\nmy $remote_path = ...;\nmy $btrfs_cmd = 'btrfs send -p $LAST_SUBVOLUME $NEXT_SUBVOLUME';\nmy $sftp = Net::SFTP::Foreign-&gt;new(\"$user\\@$host\", ...);\nopen my($pipe), \"$btrfs_cmd | compress | encrypt |\"\n    or die $!;\n$sftp-&gt;put($fh, $remote_path);\n</code></pre>","votes":"2","source":"https://superuser.com/a/1262071","author":"<a href=\"https://superuser.com/users/42742/salva\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">salva</span></a>","replies":[]}]}
