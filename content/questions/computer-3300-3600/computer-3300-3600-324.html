{"title":"Bagaimana cara memecahkan Hash terenkripsi ganda","draft":false,"url":"/bagaimana-cara-memecahkan-hash-terenkripsi-ganda-hluoru8h","votes":"4","answers_count":"2","categories":["Komputer"],"tags":["security","encryption","passwords","hashing","decryption"],"snippet":"Saya membuat hash yang dienkripsi seperti ini: $What_i_made=BCrypt(MD5(Plain Text Password)) dan saya ingin tahu apakah itu bisa dipecahkan. Saat ini, saya memikirkan dua cara:  Brute force $What_i_made untuk mendapatkan Hash MD5 lalu...","body":"<p> Saya membuat hash yang dienkripsi seperti ini: <code>$What_i_made=BCrypt(MD5(Plain Text Password))</code> dan saya ingin tahu apakah itu bisa dipecahkan. Saat ini, saya memikirkan dua cara: </p>\n<ol>\n<li> Brute force <code>$What_i_made</code> untuk mendapatkan Hash MD5 lalu lakukan serangan kamus pada Hash MD5. Namun, ini akan memakan waktu lama karena Bcrypt sangat lambat dan MD5 terdiri dari 32 karakter. </li>\n<li> <code>$result=Bcrypt(MD5(random combination))</code> dan bandingkan <code>$result</code> dengan <code>$What_i_made</code>sampai cocok. Ini akan jauh lebih cepat, tetapi saya tidak begitu yakin bagaimana melakukan ini. Saya mencoba John dan Hashcat tetapi saya tidak begitu yakin bagaimana Anda dapat melakukan ini dengan mereka, jadi saya beralih ke komunitas untuk meminta bantuan. Terima kasih. :) </li>\n</ol>\n<p> BTW, alat lain yang berfungsi juga akan dilakukan dan saya lebih suka metode yang memungkinkan untuk mencoba setiap kombinasi daripada ataks kamus. </p>","source":"https://superuser.com/questions/1561434/how-do-i-crack-a-double-encrypted-hash","author":"<a href=\"https://superuser.com/users/1124943/smartoinker\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">SmartOinker</span></a>","replies":[{"reply":"Perhatikan bahwa hash bukanlah enkripsi; ada hash ganda di sini, tetapi tidak ada enkripsi.","author":"<a href=\"https://superuser.com/users/440104/marcelm\" target=\"_blank\" rel=\"nofollow noopener\">marcelm</a>"}],"answers":[{"answer":"<p> Sebagai peretas kata sandi, saya mendorong semua target saya untuk menggunakan teknik ini. ;) </p>\n<p> Sepertinya ide yang bagus, tapi ternyata melawan serangan dunia nyata, <strong> membungkus hash unsalted dengan bcrypt terbukti lebih lemah daripada hanya menggunakan bcrypt </strong> . </p>\n<p> Ini karena penyerang dapat melakukan ini: </p>\n<ol>\n<li> Dapatkan kata sandi MD5 yang ada - <em> bahkan yang belum retak </em></li>\n<li> Jalankan MD5 ini sebagai daftar kata pada korpus <code>bcrypt(md5($pass))</code> Anda, untuk mengidentifikasi bcrypts dengan MD5 yang dikenal </li>\n<li> pecahkan MD5 <strong> di luar bcrypt </strong> dengan kecepatan yang jauh lebih tinggi </li>\n</ol>\n<p> Dengan kata lain, dalam banyak kasus, Anda cukup memecahkan hash bagian dalam terlebih dahulu. Dan untuk hash cepat seperti MD5, itu berarti untuk kata sandi apa pun yang dapat diretas <em> pertama </em> , resistensi bcrypt terhadap serangan brute-force adalah <em> secara dramatis </em> melemah. </p>\n<p> (Saya tidak dapat mengambil kredit untuk teknik ini, tetapi ini sangat efektif - terutama ketika pengguna menggunakan kembali kata sandi di beberapa situs, dan penyerang memiliki akses ke data kata sandi yang bocor.) </p>\n<p> Berikut adalah skenario pengguna tunggal yang lebih spesifik: </p>\n<ul>\n<li> Pengguna jo@example.net memiliki akun di Situs B yang menggunakan bcrypt (md5 ($ pass)) </li>\n<li> Situs B disusupi, dan daftar hash kata sandinya bocor secara online </li>\n<li> Penyerang memperoleh kebocoran Situs B. </li>\n<li> Penyerang melakukan lari cepat terhadap dump Situs B dan menentukan dari pengujian bahwa situs tersebut menggunakan bcrypt (md5 ($ pass)) </li>\n<li> Penyerang pertama kali memeriksa untuk melihat apakah ada kebocoran lain yang diketahui dalam koleksinya berisi jo@example.net </li>\n<li> Jika demikian, dan salah satu kebocoran lainnya menggunakan MD5, Penyerang cukup mencoba MD5 lain jo@example.net untuk melihat apakah Jo menggunakan kembali sandinya, dan itu yang &quot;di dalam&quot; bcrypt </li>\n<li> Jika MD5 Jo ada di dalam bcrypt itu, Penyerang sekarang dapat menyerang MD5 itu dengan kecepatan tinggi sampai mereka menemukan celah. Penyerang sekarang mengetahui sandi asli joe@example.net di Situs B </li>\n</ul>\n<p> Sekarang, bayangkan Penyerang ingin menyerang 100.000 bcrypt hash di Situs B ... tetapi Penyerang juga memiliki akses ke <em> ribuan </em> kebocoran lainnya: </p>\n<ul>\n<li> Penyerang menulis skrip untuk memeriksa semua kebocoran MD5 untuk alamat email yang cocok dengan Situs B </li>\n<li> Penyerang pertama kali mencoba MD5 khusus pengguna terhadap setiap bcrypt pengguna tertentu dari Situs B. (Ini adalah &quot;serangan korelasi&quot;). Penyerang dengan cepat memecahkan sekitar 20% (yang juga menghilangkan garam mereka dari serangan keseluruhan, meningkatkan kecepatan serangan untuk sisa hash) </li>\n<li> Penyerang selanjutnya mencoba yang lain <em> dikenal </em> MD5s dari kata sandi umum, dan juga menghapus bcrypts tersebut dari serangan </li>\n<li> Penyerang kemudian mencoba lainnya <em> tidak diketahui </em> MD5 dari kebocoran tersebut. Jika mereka menemukannya, mereka kemudian dapat menyerang MD5 tersebut sebagai MD5 langsung (tanpa melibatkan bcrypt sama sekali) </li>\n</ul>\n<p> Dan ya, serangan juga dapat dilakukan secara langsung - baik dengan MD5 membuat sendiri kata sandi kandidat, atau menggunakan alat yang secara bawaan mendukung <code>bcrypt(md5($pass))</code>, seperti <a href=\"https://hashes.org/mdxfind.php\" rel=\"nofollow noopener\" target=\"_blank\"> MDXfind </a> : </p> <pre><code>$ echo &quot;password&quot; | tee bcrypt-md5.dict \npassword\n\n$ echo -n 'password' | md5sum | awk '{print $1}'\n5f4dcc3b5aa765d61d8327deb882cf99\n\n$ htpasswd -bnBC 10 &quot;&quot; 5f4dcc3b5aa765d61d8327deb882cf99 | tr -d ':\\n' | tee bcrypt-md5.hash; echo \n$2y$10$JUbSRB0GQv.yKorqYdBaqeVYLtbZ/sRXdbPWt6u/6R3tqbaWTlQyW\n\n$ mdxfind -h '^BCRYPTMD5$' -f bcrypt-md5.hash bcrypt-md5.dict \nWorking on hash types: BCRYPTMD5 \nTook 0.00 seconds to read hashes\nSearching through 0 unique hashes from bcrypt-md5.hash\nSearching through 1 unique BCRYPT hashes\nMaximum hash chain depth is 0\nMinimum hash length is 512 characters\nUsing 4 cores\nBCRYPTMD5 $2y$10$JUbSRB0GQv.yKorqYdBaqeVYLtbZ/sRXdbPWt6u/6R3tqbaWTlQyW:password\n\nDone - 1 threads caught\n1 lines processed in 0 seconds\n1.00 lines per second\n0.07 seconds hashing, 2 total hash calculations\n0.00M hashes per second (approx)\n1 total files\n1 BCRYPTMD5x01 hashes found\n1 Total hashes found\n</code></pre> <p> Sayangnya (untuk penyerang;)), sepertinya <a href=\"https://github.com/magnumripper/JohnTheRipper\" rel=\"nofollow noopener\" target=\"_blank\"> John the Ripper edisi &quot;jumbo&quot; </a> tidak mendukung algoritme ini menggunakan sintaks dinamisnya: </p> <pre><code>$ john --format=dynamic='bcrypt(md5($pass))' --test\nError: dynamic hash must start with md4/md5/sha1 and NOT a *_raw version. This expression one does not\n</code></pre> <p> Tetapi bagi penyerang yang terfokus, jauh lebih efisien jika hanya menggali MD5 tersebut dari hash Anda, lalu menyerang MD5 tersebut dengan kecepatan miliaran kandidat per detik pada GPU. </p>\n<p> Jika Anda ingin melakukan sesuatu seperti ini - misalnya, untuk mengatasi maksimum 72 karakter bcrypt - gunakan garam per-polos, lada di seluruh situs, atau enkripsi sebenarnya pada langkah MD5. </p>","votes":"6","source":"https://superuser.com/a/1561612","author":"<a href=\"https://superuser.com/users/34685/royce-williams\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Royce Williams</span></a>","replies":[{"reply":"Bisakah Anda menjelaskan ELI5 bagaimana Anda &quot;menggali MD5 dari hashes&quot;? Pemahaman saya adalah Anda berasumsi bahwa MD5 dapat diretas secara instan, jadi MD5 secara efektif adalah sandi teks biasa. Saya tidak mengerti bagaimana itu lebih lemah dari bcrypt biasa. Poin # 2 di daftar Anda seharusnya sama lambatnya dengan serangan kamus terhadap bcrypt biasa, karena Anda harus memeriksa setiap MD5 terhadap setiap bcrypt (karena salt).","author":"<a href=\"https://superuser.com/users/194694/gronostaj\" target=\"_blank\" rel=\"nofollow noopener\">gronostaj</a>"},{"reply":"@gronostaj Pertanyaan yang adil - Saya telah memperluas jawaban saya dengan lebih spesifik.","author":"<a href=\"https://superuser.com/users/34685/royce-williams\" target=\"_blank\" rel=\"nofollow noopener\">Royce Williams</a>"},{"reply":"Terima kasih, saya mengerti sekarang. Teknik ini memungkinkan Anda (secara relatif) dengan cepat memverifikasi jika seseorang menggunakan kembali kata sandi dari DB bocor lain yang hanya menggunakan MD5. Tetapi ini hanya berfungsi jika orang itu menggunakan kembali kata sandinya dan MD5-nya sudah bocor dan dikaitkan dengan akun mereka. Jadi meskipun itu memang membuat cracking lebih cepat secara signifikan, itu tidak menempatkan orang tersebut pada risiko tambahan karena MD5 sudah dikenal, bukan?","author":"<a href=\"https://superuser.com/users/194694/gronostaj\" target=\"_blank\" rel=\"nofollow noopener\">gronostaj</a>"},{"reply":"Ini tidak terbatas pada <i> individu </i> penggunaan kembali sandi, atau kebocoran sendiri .. Jika Anda bisa mencocokkan <i> apa saja </i> MD5 yang diketahui - digunakan oleh pengguna lain, di set data lain, dll. - lalu Anda dapat menyerang MD5 tersebut di luar bcrypt <i> meskipun MD5 tersebut belum memiliki teks biasa </i> . Jika Anda berhasil melewati korpus besar dan menemukan 10.000 MD5 yang tidak dikenal di dalam bcrypts, Anda kemudian dapat memecahkan MD5 yang tidak diketahui itu dengan kecepatan super tinggi - jauh lebih cepat daripada Anda dapat menyerang bcrypt yang tidak dikenal yang setara.","author":"<a href=\"https://superuser.com/users/34685/royce-williams\" target=\"_blank\" rel=\"nofollow noopener\">Royce Williams</a>"},{"reply":"Hai @Royce Williams, maaf atas balasannya yang terlambat tetapi saya masih tidak begitu mengerti mengapa bcrypt (md5 ($ pass)) dapat diretas lebih cepat daripada bcrypt murni. Katakanlah saya memiliki hash bcrypt (md5 ()) dan saya memutuskan untuk melakukan serangan korelasi dengan beberapa dump lain yang memiliki hash md5: kata sandi teks biasa, bukankah perlu waktu yang sama untuk mencoba hash md5 di bcrypt (md5 ()) hash Saya ingin memecahkan sebelum mengambil kata sandi teks biasa sebagai kebalikan dari ketika saya memiliki hash bcrypt murni, dan saya hanya dapat mencoba kata sandi teks biasa dari dump lain di hash Bcrypt yang ingin saya retak? Terima kasih.","author":"<a href=\"https://superuser.com/users/1124943/smartoinker\" target=\"_blank\" rel=\"nofollow noopener\">SmartOinker</a>"},{"reply":"Karena <i> Anda tidak perlu memecahkan MD5 sebelum mencobanya di bcrypt. </i> Penyerang mengambil setumpuk MD5 dari kebocoran lain, dan mencobanya di bcrypts. Jika Penyerang mendapatkan hit, mereka hanya mencoba untuk memecahkan MD5 dengan kecepatan yang gila. Jika masih belum jelas, saya mendorong Anda untuk benar-benar memainkannya di atas kertas untuk beberapa iterasi sampai Anda melihat perbedaannya.","author":"<a href=\"https://superuser.com/users/34685/royce-williams\" target=\"_blank\" rel=\"nofollow noopener\">Royce Williams</a>"},{"reply":"Hmm, saya masih belum terlalu yakin dengan apa yang Anda maksud. Jika saya menggunakan hash bcrypt murni, penyerang dapat memecahkan md5 yang mereka dapatkan dari kebocoran lain dengan kecepatan gila sebelum mencobanya pada hash bcrypt murni saya. Jika mereka melakukannya, bukankah waktu yang dibutuhkan akan sama dengan yang Anda sebutkan di atas? Atau, jika penyerang mendapatkan kebocoran dehashed dan mencobanya di bcrypt murni, bukankah itu lebih cepat daripada mencobanya di hashes bcrypt (md5 ())? Terima kasih banyak. (P. S Maaf jika qns saya terdengar bodoh tapi saya tidak ahli di bidang ini.)","author":"<a href=\"https://superuser.com/users/1124943/smartoinker\" target=\"_blank\" rel=\"nofollow noopener\">SmartOinker</a>"}]},{"answer":"<p> Hash komposit ini tidak memiliki keunggulan dibandingkan bcrypt biasa. Ini bisa sedikit lebih lemah karena tabrakan MD5, tapi saya rasa tidak ada yang bisa memanfaatkannya untuk membuat serangan ini lebih cepat. Bagaimanapun, tidak ada alasan untuk melakukan hash kata sandi dengan MD5. Sekarang, ke jawaban sebenarnya. </p>\n<hr>\n<p> Pendekatan Anda # 2 tidak akan berfungsi karena bcrypt menggunakan garam acak terintegrasi. Melakukan hash pada input yang sama dua kali akan menghasilkan dua hash yang berbeda karena garam yang berbeda akan dihasilkan. </p>\n<p> Hasil dari bcrypt sebenarnya adalah struktur data yang mengandung hash dan salt yang sebenarnya. Untuk memverifikasi apakah kata sandi benar, Anda harus mengekstrak garam asli dari struktur hash asli dan menggunakannya untuk mencirikan kata sandi yang akan diverifikasi. Jika hash yang dihasilkan cocok dengan aslinya, kata sandi tersebut valid. Fitur ini biasanya disediakan oleh implementasi bcrypt. </p>\n<hr>\n<p> Jika Anda akan melakukan serangan kamus, cukup lakukan pra-hash semua entri dalam kamus Anda dengan MD5 dan kemudian jalankan serangan kamus bcrypt dengan kamus MD5s. Membalikkan MD5 untuk kata sandi yang berhasil diretas akan sangat mudah dan saya biarkan Anda mengetahuinya. </p>\n<p> Serangan brute-force dasar di mana semua kombinasi diuji tidak praktis terhadap bcrypt dan MD5 tidak relevan. </p>","votes":"6","source":"https://superuser.com/a/1561441","author":"<a href=\"https://superuser.com/users/194694/gronostaj\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">gronostaj</span></a>","replies":[{"reply":"Hai, terima kasih atas tanggapan cepat Anda, tetapi saya tidak begitu mengerti mengapa pendekatan # 2 tidak berhasil (maaf saya seorang pemula). Karena saya memiliki garam, mengapa saya tidak bisa BcryptWithSalt (MD5 (semua kombinasi acak)) sebelum membandingkan hasilnya dengan hash asli saya. Terima kasih","author":"<a href=\"https://superuser.com/users/1124943/smartoinker\" target=\"_blank\" rel=\"nofollow noopener\">SmartOinker</a>"},{"reply":"Anda bisa, tetapi jika Anda akan memeriksa semua input acak, itu tidak praktis seperti yang saya tulis di paragraf terakhir saya berkat bcrypt yang lambat. Saya berasumsi Anda hanya ingin melakukan hash MD5 dengan bcrypt lagi.","author":"<a href=\"https://superuser.com/users/194694/gronostaj\" target=\"_blank\" rel=\"nofollow noopener\">gronostaj</a>"},{"reply":"Oke, jadi saya harus mendapatkan daftar kamus, hash MD5 sebelum mengenkripsi hash MD5 dengan garam yang saat ini saya miliki (yang merupakan 22 karakter pertama dari hash)?","author":"<a href=\"https://superuser.com/users/1124943/smartoinker\" target=\"_blank\" rel=\"nofollow noopener\">SmartOinker</a>"},{"reply":"Perangkat lunak peretas kata sandi yang kompeten akan menangani struktur hash bcrypt dengan sendirinya, Anda tidak perlu khawatir tentang itu. Anda hanya perlu menyediakan kamus hash MD5.","author":"<a href=\"https://superuser.com/users/194694/gronostaj\" target=\"_blank\" rel=\"nofollow noopener\">gronostaj</a>"},{"reply":"Ok terima kasih banyak atas bantuan Anda, dan saya punya satu pertanyaan terakhir: Bagaimana Bcrypt benar-benar bekerja? Ketika saya mencari di Google, saya menemukan bahwa Bcrypt menambahkan garam di belakang kata sandi teks biasa sebelum melakukan hashing, sehingga memberi kami hash Bcrypt. Yang tidak saya mengerti adalah bahwa karena garam sudah dicakup dalam 31 karakter terakhir dari hash, untuk apa 22 karakter pertama (juga disebut sebagai garam di google)? Terima kasih.","author":"<a href=\"https://superuser.com/users/1124943/smartoinker\" target=\"_blank\" rel=\"nofollow noopener\">SmartOinker</a>"},{"reply":"Itu tidak benar-benar spesifik bcrypt, itu cara kerja penggaraman. Tanpa salt jika dua password identik, hashnya juga identik. Jika 1000 pengguna berbagi kata sandi, penyerang segera mengetahuinya karena ada 1000 hash yang identik. Memecahkan hash tunggal ini membuka 1000 akun. Anda tidak dapat memaksa pengguna untuk memilih kata sandi yang berbeda, tetapi Anda dapat memberi setiap pengguna string acak (garam) yang ditambahkan ke kata sandi secara internal sebelum melakukan hashing. Ini secara efektif membuat hash berbeda. Anda juga perlu menyimpan salt ini dalam cleartext karena Anda harus menambahkannya ke kata sandi untuk memverifikasinya.","author":"<a href=\"https://superuser.com/users/194694/gronostaj\" target=\"_blank\" rel=\"nofollow noopener\">gronostaj</a>"},{"reply":"Jadi algoritma Bcrypt di server akan menambahkan basis 64 garam (22 karakter pertama) ke awal / akhir kata sandi teks yang jelas, bcrypt, lalu bandingkan dengan hash asli (31 karakter terakhir)?","author":"<a href=\"https://superuser.com/users/1124943/smartoinker\" target=\"_blank\" rel=\"nofollow noopener\">SmartOinker</a>"},{"reply":"Pada dasarnya ya. Ini sebenarnya lebih rumit, <a href=\"https://en.wikipedia.org/wiki/Bcrypt\" rel=\"nofollow noopener\" target=\"_blank\"> Wikipedia </a> memiliki beberapa pseudocode yang bagus tetapi Anda memerlukan pengetahuan kriptografi untuk memahami semuanya. Tetapi jika Anda menambahkan garam ke, katakanlah, MD5, algoritme Anda akan berfungsi. Jangan lakukan ini, meskipun MD5 asin lebih baik daripada MD5 tanpa garam, namun tetap tidak aman.","author":"<a href=\"https://superuser.com/users/194694/gronostaj\" target=\"_blank\" rel=\"nofollow noopener\">gronostaj</a>"},{"reply":"Baik. Terima kasih banyak atas balasan cepat dan tanggapan informatif Anda :)","author":"<a href=\"https://superuser.com/users/1124943/smartoinker\" target=\"_blank\" rel=\"nofollow noopener\">SmartOinker</a>"},{"reply":"Ada satu alasan untuk menggunakan BCrypt (MD5 (Password)). Jika sistem Anda saat ini menggunakan MD5 (Sandi) dan Anda ingin beralih ke sesuatu yang aman, Anda dapat menghitung BCrypt (MD5 (Sandi)) untuk semua sandi yang ada tanpa mengharuskan pengguna mengubah sandi mereka.","author":"<a href=\"https://superuser.com/users/7170/cjm\" target=\"_blank\" rel=\"nofollow noopener\">cjm</a>"}]}]}
