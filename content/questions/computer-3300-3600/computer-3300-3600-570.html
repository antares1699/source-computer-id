{"title":"cara cepat untuk menemukan bentangan besar angka nol dalam file","draft":false,"url":"/cara-cepat-untuk-menemukan-bentangan-besar-angka-nol-dalam-file-247yubum","votes":"4","answers_count":"5","categories":["Komputer"],"tags":["linux","command-line","data-recovery"],"snippet":"Saya baru-baru ini memulihkan sebagian disk yang rusak sebesar 2,5TB. ddrescue membuat gambar, yang dapat saya pasang dalam mode loopback, 2,1TB dipulihkan, 450GB hilang, sayangnya tersebar di seluruh disk.  Untuk melihat file...","body":"<p> Saya baru-baru ini memulihkan sebagian disk yang rusak sebesar 2,5TB. <code>ddrescue</code> membuat gambar, yang dapat saya pasang dalam mode loopback, 2,1TB dipulihkan, 450GB hilang, sayangnya tersebar di seluruh disk. </p>\n\n<p> Untuk melihat file mana yang terpengaruh, saya dapat menggunakan <code>filefrag -v</code> dan melihat file peta yang dibuat oleh <code>ddrescue</code>. </p>\n\n<p> TAPI itu akan memakan waktu lama. Saya menemukan bahwa karena ini hanya file video yang saya pulihkan, angka nol besar tidak diharapkan, tetapi ada, di mana <code>ddrescue</code> tidak membaca data dari disk. </p>\n\n<p> Jadi saya memerlukan perintah untuk memindai file jika ada patch besar (sewenang-wenang) dari semua nol di file tersebut. Pada kenyataannya, ini akan selalu berupa kelipatan 512 byte, dan selalu dimulai pada alamat 512 byte. Apakah ada perintah yang dapat memindai file untuk urutan byte biner seperti itu (yaitu 512 × &#39;\\ 0&#39;)? </p>","source":"https://superuser.com/questions/1242510/quick-way-to-find-large-stretches-of-zeros-in-files","author":"<a href=\"https://superuser.com/users/605122/ro-ee\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Ro-ee</span></a>","replies":[{"reply":"File log yang dihasilkan oleh <code>ddrescue</code> akan berisi dengan tepat area mana yang tidak dikloning. Anda juga bisa menggunakan <a href=\"https://sourceforge.net/projects/ddrescueview/\" rel=\"nofollow noopener\" target=\"_blank\"> ddrescueview.dll </a> untuk melihat mereka.","author":"<a href=\"https://superuser.com/users/278831/andrea-lazzarotto\" target=\"_blank\" rel=\"nofollow noopener\">Andrea Lazzarotto</a>"},{"reply":"ya, tetapi saya harus menggunakan filefrag untuk menemukan blok mana yang digunakan oleh file tertentu. Pencarian terbalik dari file peta yang akan dicetak untuk setiap * atau? atau - area yang ditandai di file peta file mana yang terpengaruh tentu saja akan melakukan trik: Saya akan melihat semua file yang terpengaruh dan menganggap file tersebut tidak disebutkan sebagai ok. Tapi saya akan tetap berpegang pada jawaban yang diberikan xenoid, ini memiliki kecepatan yang layak.","author":"<a href=\"https://superuser.com/users/605122/ro-ee\" target=\"_blank\" rel=\"nofollow noopener\">Ro-ee</a>"}],"answers":[{"answer":"<p> Saya telah memodifikasi <a href=\"https://superuser.com/a/1242571/764326\" target=\"_blank\" rel=\"nofollow noopener\"> jawaban xenoid </a> untuk melihat <em> secara khusus </em> untuk byte nol, berdasarkan <a href=\"https://superuser.com/a/612336/764326\" target=\"_blank\" rel=\"nofollow noopener\"> ini jawaban pertanyaan lainnya </a> tentang cara grep untuk null byte: </p> <pre><code>grep -Pal '\\x00{512}' the_files\n</code></pre>","votes":"4","source":"https://superuser.com/a/1243770","author":"<a href=\"https://superuser.com/users/764326/mj713\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">MJ713</span></a>","replies":[{"reply":"Saya melakukan beberapa pembandingan untuk ini, dengan versi ini di sistem saya, dibutuhkan 20 detik alih-alih 2 menit untuk file yang sama untuk diproses ... dapat dimengerti, karena mencari urutan tertentu jauh lebih cepat daripada mencari urutan SETIAP yang sama. karakter dengan panjang yang sama ...","author":"<a href=\"https://superuser.com/users/605122/ro-ee\" target=\"_blank\" rel=\"nofollow noopener\">Ro-ee</a>"}]},{"answer":"<p> Membuat <code>grep</code> terlihat secara eksplisit untuk karakter nol membuatku tidak sadar. Namun, membuatnya mencari 512 karakter identik yang berurutan (yang kemungkinannya hampir tidak mungkin) agak lebih sederhana: </p> <pre><code>grep -Eal '(.)\\1{511}' the_files\n</code></pre> <p> daftar file di mana urutan 512 karakter identik telah ditemukan. Parameter <code>-a</code> diperlukan untuk membuatnya cocok dengan karakter nol (jika tidak, mereka dianggap sebagai karakter akhir baris dan diabaikan). </p>","votes":"2","source":"https://superuser.com/a/1242571","author":"<a href=\"https://superuser.com/users/670091/xenoid\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">xenoid</span></a>","replies":[]},{"answer":"<p><a href=\"https://superuser.com/a/1242571/432690\" target=\"_blank\" rel=\"nofollow noopener\"> jawaban xenoid </a> mungkin akan menemukan file yang terpengaruh untuk Anda dengan cepat. Untuk mengonfirmasi dan menganalisis lebih lanjut, Anda dapat menjalankan: </p> <pre><code>&lt;\"file\" tr '\\000-\\377' 'oL' | fold -w 512 | grep -vn 'L' | cut -f 1 -d ':'\n</code></pre> <p> Ini bekerja sebagai berikut: </p>\n\n<ol>\n<li> <code>\"file\"</code> dibuka dan dialirkan ke perintah pertama. </li>\n<li> <code>tr</code> mengonversi setiap karakter nol menjadi <code>o</code>, setiap karakter bukan nol menjadi <code>L</code>. </li>\n<li> <code>fold</code> menyisipkan baris baru setelah setiap 512 karakter. Saat ini aliran dapat diperlakukan sebagai teks murni. </li>\n<li> <code>grep</code> mengambil baris yang tidak berisi <code>L</code> dan mencetaknya dengan nomornya. </li>\n<li> <code>cut</code> mengisolasi angka-angka ini (membersihkan <code>ooo…</code>). </li>\n</ol>\n\n<p> Dengan cara ini Anda mendapatkan nomor urut dari potongan 512 byte yang diisi dengan nol. Penomoran dimulai dengan <code>1</code>. Teruskan keluaran ke <code>wc -l</code> untuk melihat berapa banyak potongan yang terpengaruh dalam file tertentu. </p>","votes":"2","source":"https://superuser.com/a/1242588","author":"<a href=\"https://superuser.com/users/432690/kamil-maciorowski\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Kamil Maciorowski</span></a>","replies":[{"reply":"Itu adalah beberapa sihir tingkat lanjut ... Saya telah menulis sebuah program kecil yang mencoba untuk mengambil blok yang hilang dari disk asli dan yang sudah melakukan perhitungan yang benar, tetapi cukup lambat, tetapi bersama dengan program itu saya dapat mengetahui berapa banyak MB yang hilang . Saya akan mencoba solusi Anda, karena saya rasa ini mungkin lebih cepat.","author":"<a href=\"https://superuser.com/users/605122/ro-ee\" target=\"_blank\" rel=\"nofollow noopener\">Ro-ee</a>"}]},{"answer":"<p> Pendekatan berbeda, oleh karena itu jawaban lain dari saya. </p>\n<p> Anda dapat menggunakan <code>ddrescue</code> itu sendiri untuk mencari nol. Gunakan <code>--generate-mode</code>. </p>\n<blockquote>\n<p> Ketika <code>ddrescue</code> dipanggil dengan opsi <code>--generate-mode</code> itu beroperasi dalam &quot;mode pembangkitan&quot;, yang berbeda dari &quot;mode penyelamatan&quot; default. Artinya, jika Anda menggunakan opsi <code>--generate-mode</code>, <code>ddrescue</code> tidak menyelamatkan apa pun. Ini hanya mencoba menghasilkan <code>mapfile</code> untuk digunakan nanti. </p>\n<p> […] </p>\n<p> <code>ddrescue</code> dalam beberapa kasus dapat menghasilkan perkiraan <code>mapfile</code>, dari <code>infile</code> dan salinan (sebagian) pada <code>outfile</code>, yang hampir sebagus <code>mapfile</code>. Itu membuat ini hanya dengan mengasumsikan bahwa sektor yang mengandung semua nol tidak diselamatkan. </p>\n<p> […] </p> <pre><code>ddrescue --generate-mode infile outfile mapfile\n</code></pre> </blockquote>\n<p><sup> ( <a href=\"https://www.gnu.org/software/ddrescue/manual/ddrescue_manual.html#Generate-mode\" rel=\"nofollow noopener\" target=\"_blank\"> sumber </a> ) </sup></p>\n<p> Anggaplah file Anda <code>outfile</code> dari proses <code>ddrescue</code> sebelumnya. Kita tidak dapat menggunakannya sebagai <code>infile</code> (karena <code>ddrescue</code> menolak untuk bekerja ketika <code>infile</code> dan <code>outfile</code> adalah file yang sama), kita memerlukan yang dummy, <code>/dev/zero</code> sudah cukup. Untuk menemukan setiap nol yang Anda butuhkan <code>-b 1</code>. Ini adalah perintah (<code>mapfile</code> tidak boleh ada): </p> <pre><code>ddrescue -b 1 --generate-mode /dev/zero file mapfile\n</code></pre> <p> Setiap entri dengan <code>?</code> dalam daftar blok data di dalam <code>mapfile</code> berarti blok nol (dengan <code>-b 1</code> satu nol juga merupakan blok). Lihat <a href=\"https://www.gnu.org/software/ddrescue/manual/ddrescue_manual.html#Mapfile-structure\" rel=\"nofollow noopener\" target=\"_blank\"> struktur mapfile untuk <code>ddrescue</code> </a> . Anda kemudian dapat mengambil informasi dari <code>mapfile</code>. </p>\n<p> Misalnya perintah berikut akan memberi Anda panjang (heksadesimal, dalam byte karena <code>-b 1</code>) dari blok nol terbesar (keluaran kosong berarti tidak ada): </p> <pre><code>grep '0x.*0x.*[?]' mapfile | awk -F ' ' '{print $2}' | sort -ru | head -n 1\n</code></pre> <hr>\n<p> Untuk mempercepat, Anda mungkin ingin menggunakan ukuran blok yang lebih besar (<code>-b</code>), tetapi kemudian blok nol yang dimulai dalam satu blok dan berakhir dalam blok berikutnya mungkin tidak diperhatikan meskipun ukurannya sedikit lebih panjang dari ukuran blok yang dipilih; penggantian kerugian mereka menjadi penting. </p>\n<p> Agar tidak melewatkan bentangan nol dengan panjang <code>N</code> byte atau lebih, Anda memerlukan ukuran blok paling banyak <code>M=$(((N+1)/2))</code> byte (misalnya maksimal <code>5</code> untuk <code>ddrescue</code>, <code>mapfile</code> untuk <code>N=11</code>). Perintah </p> <pre><code>ddrescue -b &quot;$M&quot; --generate-mode /dev/zero file mapfile\n</code></pre> <p> akan menghasilkan mapfile di mana setiap baris dengan <code>?</code> dalam daftar blok data berarti setidaknya <code>M</code> nol (di offset kanan), tetapi setiap bentangan <code>N</code> nol (terlepas dari offsetnya) pasti akan menghasilkan baris seperti itu. Karena dua blok <code>M</code> setidaknya <code>N</code>, alasan berikut berlaku: </p>\n<p> Mengambil baris dengan <code>?</code> dari daftar blok data, </p>\n<ul>\n<li> jika panjangnya (kolom kedua pada <code>mapfile</code>, ingat satuannya adalah <code>M</code>) adalah <code>0x2</code> atau lebih besar maka Anda memiliki <code>N</code> atau lebih nol pada posisi ini; </li>\n<li> jika panjangnya <code>0x1</code> maka Anda harus menyelidiki lebih lanjut jika ada setidaknya <code>N</code> angka nol di sekitar posisi ini; </li>\n<li> jika tidak ada baris seperti itu maka tidak ada bentangan <code>N</code> nol dalam file tersebut. </li>\n</ul>\n<hr>\n<blockquote>\n<p> Pada kenyataannya, ini akan selalu berupa kelipatan 512 byte, dan selalu dimulai pada alamat 512 byte </p>\n</blockquote>\n<p> Pada kasus ini </p> <pre><code>ddrescue -b 512 --generate-mode /dev/zero file mapfile\n</code></pre> <p> akan menemukan dan memetakan semuanya. </p>","votes":"2","source":"https://superuser.com/a/1371177","author":"<a href=\"https://superuser.com/users/432690/kamil-maciorowski\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Kamil Maciorowski</span></a>","replies":[{"reply":"Itulah metode yang saya gunakan di sini, lalu ddrescueview untuk mendapatkan presentasi grafis yang lebih nyaman: <a href=\"https://superuser.com/questions/1267818/rebuild-massively-fragmented-files-with-a-partial-image-and-a-list-of-their-sect\" title=\"rebuild massively fragmented files with a partial image and a list of their sect\" target=\"_blank\" rel=\"nofollow noopener\"> superuser.com/questions/1267818/… </a>","author":"<a href=\"https://superuser.com/users/486863/gabrielb\" target=\"_blank\" rel=\"nofollow noopener\">GabrielB</a>"}]},{"answer":"<p> Saya tertarik dengan ini, karena ini adalah sesuatu yang kadang-kadang saya inginkan, dan saya melakukan sedikit pencarian, menghasilkan <a href=\"https://github.com/nneonneo/bgrep\" rel=\"nofollow noopener\" target=\"_blank\"> program Python 3 ini </a> . </p>\n\n<p> Saya melakukan perintah <code>wget</code> di bagian bawah halaman dan berfungsi dengan sempurna (meskipun Anda mungkin memerlukan <code>sudo</code>, tergantung izin Anda). Seperti <code>grep</code>, ia memiliki banyak opsi canggih, termasuk pencarian Ekspresi Reguler: contoh di tajuk menunjukkan beberapa di antaranya; <code>bgrep --help</code> memberikan daftar lengkapnya. </p>\n\n<p> Untuk penggunaan Anda, Anda akan membutuhkan string run dengan 512 nol ganda di dalamnya: jangan ketik mereka, gunakan sesuatu seperti: </p> <pre><code>bgrep -l $(for f in {0..511}; do echo -n 00; done) files...\n</code></pre> <p> Anda mungkin ingin menggunakan opsi <code>-r</code> untuk melintasi pohon direktori lengkap. </p>\n\n<p> Saya telah menambahkan jawaban ini, bukan karena yang lain tidak memadai (saya sangat menyukai kecerdikan urutan perintah Kamil Maciorowski), tetapi karena itu mungkin berharga bagi orang lain (seperti saya) dengan masalah terkait yang menemukan pertanyaan ini. </p>","votes":"1","source":"https://superuser.com/a/1242624","author":"<a href=\"https://superuser.com/users/327367/afh\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">AFH</span></a>","replies":[]}]}
