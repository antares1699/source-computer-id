{"title":"Bagaimana cara mengikuti perangkat blokir di Linux?","draft":false,"url":"/bagaimana-cara-mengikuti-perangkat-blokir-di-linux-zk2bwv3l","votes":"4","answers_count":"1","categories":["Komputer"],"tags":["linux","tail"],"snippet":"Saya mencoba mendapatkan hanya 1024 byte terakhir dari / dev / sda2. Ketika saya melakukan sudo tail -c 1024 /dev/sda2 | hd, prompt berhenti sampai saya menekan Ctrl-C. Namun, ketika saya tail...","body":"<p> Saya mencoba mendapatkan hanya 1024 byte terakhir dari / dev / sda2. Ketika saya melakukan <code>sudo tail -c 1024 /dev/sda2 | hd</code>, prompt berhenti sampai saya menekan Ctrl-C. Namun, ketika saya <code>tail -c 1024 ddfilecopyofsda2 | hd</code>, saya segera mendapatkan output yang bagus dari file 1024 byte terakhir. Saya membaca di sini ( <a href=\"https://unix.stackexchange.com/questions/60034/what-are-character-special-and-block-special-files-in-a-unix-system\" target=\"_blank\" rel=\"nofollow noopener\"> https://unix.stackexchange.com/questions/60034/what-are-character-special-and-block-special-files-in-a-unix-system </a> ) bahwa &quot;Blokir perangkat biasanya dapat dicari&quot;, jadi apa yang saya lewatkan? </p>","source":"https://superuser.com/questions/1267402/how-do-i-tail-a-block-device-in-linux","author":"<a href=\"https://superuser.com/users/409147/clearcom0\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">clearcom0</span></a>","replies":[],"answers":[{"answer":"<p> Berikut salah satu cara untuk mendapatkan 1024 byte terakhir dari perangkat blok: </p> <pre><code>last_bytes() { sudo dd if=$2 iflag=skip_bytes skip=$(($(sudo blockdev --getsize64 $2) - $1)) bs=1M ; } ; last_bytes 1024 DEVICE\n</code></pre> <p> Ganti <code>DEVICE</code> dengan jalur perangkat. Dalam kasus Anda, Anda akan menggunakan <code>/dev/sda2</code>. </p>\n\n<hr>\n\n<p> Sekarang untuk pertanyaan yang lebih menarik untuk dijawab… </p>\n\n<h2 class=\"h4\"> Mengapa <code>tail -c 1024 /dev/sda2</code> mencari di seluruh disk? </h2>\n\n<p> Alasannya adalah bagaimana <code>tail</code> diimplementasikan. Ketika <code>tail</code> mengetahui ukuran file yang dibaca, ia tahu persis berapa banyak yang harus dicari. Jika tidak, ia harus membaca file atau streaming sepenuhnya untuk mengetahui seberapa jauh menghitung mundur. </p>\n\n<p> Dengan pipa, masuk akal, seperti <code>cat /dev/sda2 | tail -c 1024</code>. <code>tail</code> menerima konten sebagai aliran dan tidak memiliki cara untuk mengetahui kapan data akan berakhir. </p>\n\n<p> Anda mungkin berharap <code>tail -c 1024 /dev/sda2</code> dapat mengetahui ukuran <code>/dev/sda2</code>, tetapi sebenarnya, ketika <pre><code>last_bytes() { sudo dd if=$2 iflag=skip_bytes skip=$(($(sudo blockdev --getsize64 $2) - $1)) bs=1M ; } ; last_bytes 1024 DEVICE\n</code></pre> mencari <code>/dev/sda2</code>, itu dibuka sebagai perangkat blok dan bukan file biasa. </p>\n\n<p> Detail implementasinya adalah <code>tail</code> panggilan <a href=\"https://linux.die.net/man/2/fstat\" rel=\"nofollow noopener\" target=\"_blank\"> <code>fstat()</code> </a> untuk mendapatkan informasi tentang file tersebut. </p>\n\n<h3 class=\"h5\"> <code>tail</code> pada file biasa </h3>\n\n<p> Berikut adalah bagian yang relevan dari <code>strace</code> dari contoh <code>tail</code> membuka file: </p> <pre><code>21:30:27 open(\"/var/log/syslog\", O_RDONLY) = 3\n21:30:27 fstat(3, {st_dev=makedev(0, 22), st_ino=4715, st_mode=S_IFREG|0640, st_nlink=1, st_uid=104, st_gid=4, st_blksize=131072, st_blocks=54, st_size=175500, st_atime=2017/11/10-21:28:39.243133398, st_mtime=2017/11/10-21:30:20.438031639, st_ctime=2017/11/10-21:30:20.438031639}) = 0\n21:30:27 lseek(3, 0, SEEK_CUR)          = 0\n21:30:27 lseek(3, 174476, SEEK_SET)     = 174476\n</code></pre> <p> <code>fstat()</code> menyediakan <code>st_size=175500</code>. Sekarang <code>tail</code> hanya perlu menghitung mundur 1024 byte: </p>\n\n<blockquote>\n  <p> 175500 - 1024 = 174476 </p>\n  \n  <p> … Dan inilah tepatnya yang dilakukan <code>tail</code>: </p> <pre><code>lseek(3, 174476, SEEK_SET)     = 174476\n</code></pre> </blockquote>\n\n<h3 class=\"h5\"> <code>tail</code> pada perangkat blok </h3>\n\n<p> <code>fstat()</code> tidak mengembalikan ukuran kali ini !: </p> <pre><code>21:29:43 open(\"/dev/sda\", O_RDONLY)     = 3\n21:29:43 fstat(3, {st_dev=makedev(0, 6), st_ino=17488, st_mode=S_IFBLK|0660, st_nlink=1, st_uid=0, st_gid=6, st_blksize=4096, st_blocks=0, st_rdev=makedev(8, 0), st_atime=2017/11/10-09:21:15.643998960, st_mtime=2017/11/10-09:21:15.555998962, st_ctime=2017/11/10-09:21:15.555998962}) = 0\n</code></pre> <p> Dengan tidak adanya <code>st_size</code>, <code>tail</code> tidak dapat mengetahui seberapa jauh harus dicari, jadi defaultnya adalah membaca seluruh perangkat blok sampai akhir. </p>\n\n<p> Inilah sebabnya mengapa Anda biasanya harus menggunakan alat perangkat blok seperti <code>dd</code> untuk memanipulasi perangkat blok daripada alat yang ditujukan untuk file biasa seperti <code>tail</code>. </p>\n\n<hr>\n\n<p> Anda mungkin bertanya, &quot;Bagaimana <code>blockdev --getsize64</code> mendapatkan ukuran perangkat blok dengan cepat?&quot; </p>\n\n<p> Inilah <code>sudo strace -vvvfts1000 blockdev --getsize64 /dev/sda</code>: </p> <pre><code>21:53:15 open(\"/dev/sda\", O_RDONLY)     = 3\n21:53:15 ioctl(3, BLKGETSIZE64, [512110190592]) = 0\n</code></pre> <p> <code>blockdev</code> dimaksudkan untuk mendapatkan ioctls perangkat blok, dan <code>BLKGETSIZE64</code> mendapatkan ukuran perangkat blok. </p>\n\n<hr>\n\n<p> Adapun <em> Mengapa </em> <code>tail</code> tidak melakukan <code>BLKGETSIZE64</code>, saya tidak tahu. Itu <a href=\"https://git.savannah.gnu.org/cgit/coreutils.git/tree/src/tail.c\" rel=\"nofollow noopener\" target=\"_blank\"> Kode sumber </a> acara: </p> <pre><code>#define IS_TAILABLE_FILE_TYPE(Mode) \\\n  (S_ISREG (Mode) || S_ISFIFO (Mode) || S_ISSOCK (Mode) || S_ISCHR (Mode))\n</code></pre> <p> Saya hanya tahu dari baris itu bahwa tanpa <a href=\"https://www.gnu.org/software/libc/manual/html_node/Testing-File-Type.html\" rel=\"nofollow noopener\" target=\"_blank\"> <code>S_ISBLK()</code> </a> , penulis tidak bermaksud <code>tail</code> untuk mendukung perangkat blokir. </p>","votes":"10","source":"https://superuser.com/a/1267407","author":"<a href=\"https://superuser.com/users/83694/deltik\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Deltik</span></a>","replies":[{"reply":"Saya berharap saya dapat memberi suara positif pada jawaban ini sekitar 5 kali! Terima kasih atas penjelasannya yang mendetail!","author":"<a href=\"https://superuser.com/users/409147/clearcom0\" target=\"_blank\" rel=\"nofollow noopener\">clearcom0</a>"},{"reply":"Catatan GNU dd sejak 8.16 (2012-03-26) mendukung opsi <code>iflag=skip_bytes</code>. Hal ini memungkinkan seseorang untuk secara efisien melewati bagian input yang berubah-ubah sementara tidak bergantung pada ukuran blok yang digunakan untuk I / O. Seseorang sering ingin menggunakan <code>bs</code> besar untuk efisiensi.","author":"<a href=\"https://superuser.com/users/11613/pixelbeat\" target=\"_blank\" rel=\"nofollow noopener\">pixelbeat</a>"},{"reply":"Terima kasih @pixelbeat! Saya telah memperbarui jawaban saya untuk menggunakan <code>dd iflag=skip_bytes</code> sebagai gantinya.","author":"<a href=\"https://superuser.com/users/83694/deltik\" target=\"_blank\" rel=\"nofollow noopener\">Deltik</a>"}]}]}
