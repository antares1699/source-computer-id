{"title":"Masalah dengan netcat melalui UDP","draft":false,"url":"/masalah-dengan-netcat-melalui-udp-l30dkyes","votes":"4","answers_count":"2","categories":["Komputer"],"tags":["networking","udp","debian-jessie","netcat"],"snippet":"Saat memecahkan masalah, masalah dijelaskan  sini  , Saya mencoba sesuatu yang sangat mendasar: Saya mencoba menyiapkan koneksi netcat yang sangat dasar melalui UDP, dan saya perhatikan itu tidak berfungsi seperti yang saya...","body":"<p> Saat memecahkan masalah, masalah dijelaskan <a href=\"https://superuser.com/questions/1237099/how-to-pxe-boot-over-wan\" target=\"_blank\" rel=\"nofollow noopener\"> sini </a> , Saya mencoba sesuatu yang sangat mendasar: Saya mencoba menyiapkan koneksi netcat yang sangat dasar melalui UDP, dan saya perhatikan itu tidak berfungsi seperti yang saya harapkan. </p>\n\n<p> Seperti ilustrasi TCP di bawah ini, saya mengharapkan kasus UDP untuk menggemakan output yang sama di Window 1 saat saya mengetiknya di Window 2; sebaliknya, saya tidak mendapatkan output di Window 1 dalam kasus UDP. </p>\n\n<p> Saya menjalankan Debian Jessie di laptop saya, dan saya menjalankan Wireshark dengan filter pengambilan berikut: </p> <pre><code>udp and not (port 123 or port 5353 or port 1900)\n</code></pre> <p> Di satu jendela terminal, saya mulai dengan tes TCP dengan menjalankan perintah berikut: </p> <pre><code>$ nc -l 6900\n</code></pre> <p> Di jendela terminal kedua, saya menjalankan yang berikut ini: </p> <pre><code>$ nc localhost 6900\n</code></pre> <p> Di Window 2, saya mengetik &quot;satu&quot; dan menekan Enter, lalu saya mengetik &quot;dua&quot; dan menekan Enter, dan akhirnya saya menekan Ctrl + D untuk keluar. </p>\n\n<p> Setelah menekan Enter pada &quot;satu&quot;, saya melihat &quot;satu&quot; bergema di Jendela 1. Setelah menekan Enter pada &quot;dua&quot;, saya melihat &quot;dua&quot; bergema di Jendela 1. Saat saya menekan Ctrl + D, kedua contoh netcat keluar dan saya kembali ke prompt. </p>\n\n<p> Ini menunjukkan saya bisa mendapatkan koneksi TCP tanpa masalah. Selanjutnya, saya mencoba UDP. </p>\n\n<p> Jendela 1: </p> <pre><code>$ nc -l -u 6900\n</code></pre> <p> Jendela 2: </p> <pre><code>$ nc -u localhost 6900\n</code></pre> <p> Itu lucu. Saya rasa saya hanya bisa mengetik &quot;satu&quot;, tekan Enter, lalu &quot;dua&quot;, dan tekan Enter, dan saya secara otomatis kembali ke prompt di Window 2. </p>\n\n<p> Di Jendela 1, saya tidak melihat keluaran apa pun. </p>\n\n<p> Saya mencoba lagi dengan <code>-v</code> di Jendela 1: </p> <pre><code>$ nc -v -l -u 6900\nListening on [0.0.0.0] (family 0, port 6900)\n</code></pre> <p> Lucu ketika saya mencoba lagi dengan <code>-v</code> di Jendela 2: </p> <pre><code>$ nc -v -u localhost 6900\n$\n</code></pre> <p> Ini seperti netcat tidak pernah berlari; Saya segera kembali ke prompt. </p>\n\n<p><strong> Memperbarui: </strong> Jika saya mengganti <code>localhost</code> dengan <code>127.0.0.1</code>, ada kemajuan. </p>\n\n<p> Dengan &quot;server&quot; mendengarkan di Jendela 1: </p> <pre><code>$ nc -v -l -u 6900\none\ntwo\nthree\n</code></pre> <p> Saya bisa mendapatkan keluaran bergema dari Jendela 2 saat mengetik &quot;satu&quot;, &quot;dua&quot;, dan &quot;tiga&quot;: </p> <pre><code>$ nc -u 127.0.0.1 6900\none\ntwo\nthree\n^C\n</code></pre> <p> <code>-v</code> masih membingungkan, karena sama seperti di atas. </p>","source":"https://superuser.com/questions/1238038/trouble-with-netcat-over-udp","author":"<a href=\"https://superuser.com/users/315584/jia103\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">jia103</span></a>","replies":[],"answers":[{"answer":"<p> Menggunakan macOS, saya sampai pada kesimpulan yang berbeda. Kuncinya adalah IPv6. <code>localhost</code> menyelesaikan baik IPv6 dan IPv4. Namun, baris perintah berikut akan menyebabkan <code>nc</code> mendengarkan di IPv4: </p> <pre><code>nc -l -u 6900\n</code></pre> <p> Hasil: </p> <pre><code>$ lsof -n -i:6900\nCOMMAND   PID  USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME\nnc      63923 fuzzy    3u  IPv4 0xad7f669b928a178b      0t0  UDP *:6900\n</code></pre> <p> Sekarang saat Anda menggunakan ini untuk &quot;menghubungkan&quot;: </p> <pre><code>nc -u localhost 6900\n</code></pre> <p> ... itu benar-benar terhubung ke IPv6. Ketika Anda menggunakan <code>127.0.0.1</code> itu tidak akan. </p>\n\n<p> Namun, itu tidak terhubung, karena UDP tidak memiliki koneksi. Dengan demikian, tidak ada cara untuk mengetahui apakah ujung sambungan jarak jauh benar-benar ada. Dengan demikian, ia tidak dapat mendeteksi bahwa ia harus kembali ke IPv4. Pesan Anda akan terkirim, tetapi tidak ada yang mendengarkan pesan-pesan itu. </p>\n\n<p> Saat mengirim, hal berikut dapat diamati: </p> <pre><code>$ tcpdump -i lo0 udp port 6900\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on lo0, link-type NULL (BSD loopback), capture size 262144 bytes\n00:46:37.543273 IP6 localhost.54473 &gt; localhost.6900: UDP, length 6\n</code></pre> <p> Dengan TCP, ia akan mencoba menyambung di IPv6, menentukan bahwa ini tidak berfungsi, dan coba lagi dengan IPv4: </p> <pre><code>$ tcpdump -i lo0 port 6900\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on lo0, link-type NULL (BSD loopback), capture size 262144 bytes\n00:50:21.495107 IP6 localhost.64306 &gt; localhost.6900: Flags [SEW], seq 1432891337, win 65535, options [mss 16324,nop,wscale 5,nop,nop,TS val 766376063 ecr 0,sackOK,eol], length 0\n00:50:21.495136 IP6 localhost.6900 &gt; localhost.64306: Flags [R.], seq 0, ack 1432891338, win 0, length 0\n00:50:21.495231 IP localhost.64307 &gt; localhost.6900: Flags [S], seq 307818799, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 766376063 ecr 0,sackOK,eol], length 0\n00:50:21.495283 IP localhost.6900 &gt; localhost.64307: Flags [S.], seq 4254625238, ack 307818800, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 766376063 ecr 766376063,sackOK,eol], length 0\n00:50:21.495295 IP localhost.64307 &gt; localhost.6900: Flags [.], ack 1, win 12759, options [nop,nop,TS val 766376063 ecr 766376063], length 0\n00:50:21.495306 IP localhost.6900 &gt; localhost.64307: Flags [.], ack 1, win 12759, options [nop,nop,TS val 766376063 ecr 766376063], length 0\n</code></pre> <p> Anda dapat memaksa <code>nc</code> untuk menggunakan IPv4: </p> <pre><code>nc -4u localhost 6900\n</code></pre>","votes":"6","source":"https://superuser.com/a/1238095","author":"<a href=\"https://superuser.com/users/219095/daniel-b\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Daniel B</span></a>","replies":[]},{"answer":"<h3 class=\"h5\"> tl; dr </h3>\n<p> Lihat <em> kesimpulan </em> di bagian paling akhir. </p>\n<hr>\n<h3 class=\"h5\"> Pembukaan </h3>\n<p> Saya bisa menjelaskan hasil Anda. Saya menggunakan Kubuntu, bukan Debian, tetap saya percaya poin utamanya adalah umum. Untuk memahami sepenuhnya apa yang terjadi, sebaiknya analisis kasus TCP, lalu bandingkan dengan UDP. </p>\n<p> Jika Anda ingin mereplikasi penelitian saya, jangan hentikan atau bunuh <code>nc</code> kecuali saya katakan atau ia berakhir dengan sendirinya. Bunuh <code>nc</code>s ketika saya katakan. Ini sangat penting. Setelah membaca jawaban lengkapnya, Anda akan memahami maksud dari ini. </p>\n<p> Analisis ini membutuhkan banyak terminal (atau <code>tmux</code>, atau <code>screen</code>). </p>\n<hr>\n<h3 class=\"h5\"> Kasus TCP </h3>\n<p> Pertama-tama, singkirkan semua proses <code>nc</code> sebelumnya. </p> <pre><code>killall nc\n</code></pre> <p> Jalankan proses mendengarkan: </p> <pre><code>nc -l 6900\n</code></pre> <p> Periksa output <code>lsof -i :6900</code>. <code>nc</code> Anda terdaftar sebagai proses mendengarkan di sana. </p>\n<p> Jalankan proses penghubung: </p> <pre><code>nc localhost 6900\n</code></pre> <p> Periksa keluaran dari <code>lsof -i :6900</code>. Kedua <code>nc</code> adalah ujung dari <em> mapan </em> koneksi. </p>\n<p> Karena <code>nc</code> pertama Anda tidak mendengarkan lagi, Anda dapat menjalankan file <em> kedua </em> proses mendengarkan: </p> <pre><code>nc -l 6900\n</code></pre> <p> dan a <em> kedua </em> proses menghubungkan: </p> <pre><code>nc localhost 6900\n</code></pre> <p> Ketik sesuatu di setiap konsol tempat <code>nc</code> berjalan (jangan lupa untuk menekan <kbd> Memasukkan </kbd> setiap saat). Anda akan melihat ada dua koneksi terpisah. Anda dapat membuat file <em> ketiga </em> satu jika Anda mau. </p>\n<p> Periksa <code>lsof -i :6900</code> lagi. Meskipun dua (sebelumnya) mendengarkan <code>nc</code> menggunakan port yang sama <code>6900</code>, kedua koneksi tidak bercampur karena <code>nc</code>s di ujung lainnya menggunakan <em> berbeda </em> pelabuhan. Ketika sebuah paket datang ke port <code>6900</code>, kernel memeriksa port lain ini dan memutuskan mana dari <code>nc</code> yang mendengarkan (sebelumnya) yang harus menerimanya. </p>\n<p> Anda dapat menjalankan tambahan (tidak berpasangan) menghubungkan <code>nc</code>: </p> <pre><code>nc localhost 6900 || echo fail\n</code></pre> <p> dan itu akan segera gagal. </p>\n<p> Anda masih memiliki dua koneksi terpisah yang dibuat. Hentikan satu <code>nc</code> dari setiap pasangan dengan <kbd> Ctrl </kbd> + <kbd> C </kbd> atau <kbd> Ctrl </kbd> + <kbd> D </kbd> dan Anda akan melihat ujung yang sesuai akan berakhir juga. Ini karena TCP berorientasi pada koneksi. Ketika koneksi diakhiri dengan anggun dari salah satu ujungnya, ujung yang lain diberitahu sehingga dapat bereaksi sesuai - dalam hal ini <code>nc</code> keluar begitu saja. </p>\n<hr>\n<h3 class=\"h5\"> Kasus UDP </h3>\n<p> Penting: </p> <pre><code>killall nc\n</code></pre> <p> Jalankan perintah berikut secara berurutan, masing-masing di konsol terpisah. Periksa juga <code>lsof -i :6900</code> setelah masing-masing untuk melihat apa yang terjadi. Perintahnya adalah: </p> <pre><code>nc -ul 6900\nnc -u localhost 6900\n</code></pre> <p> Ketik sesuatu di (&quot;mendengarkan&quot;) pertama <code>nc</code> (tekan <kbd> Memasukkan </kbd> ); periksa <code>lsof -i :6900</code>; ketik sesuatu di <code>lsof -i :6900</code> kedua (hit <kbd> Memasukkan </kbd> ); periksa <code>lsof -i :6900</code> lagi dan catat perubahannya. </p>\n<p> Kemudian siapkan pasangan lain (di konsol terpisah): </p> <pre><code>nc -ul 6900\nnc -u localhost 6900\n</code></pre> <p> Berikan beberapa string bolak-balik untuk melihat apakah berhasil. Hentikan satu <code>nc</code> dengan <kbd> Ctrl </kbd> + <kbd> C </kbd> ( <kbd> Ctrl </kbd> + <kbd> D </kbd> tidak akan berfungsi) dan perhatikan <code>nc</code> lainnya (di ujung yang sesuai) masih berjalan. Sisi lain dari &quot;koneksi&quot; tidak tahu kapan &quot;koneksi&quot; tersebut &quot;diakhiri&quot;. Seperti yang Anda lihat pada <code>lsof -i :6900</code>, ia tidak mengetahui &quot;koneksi&quot; telah &quot;dibuat&quot; sampai data mulai mengalir. </p>\n<p> Saya mengutip beberapa kata di sini karena UDP tidak memiliki koneksi dan inilah perbedaan utamanya. </p>\n<hr>\n<h3 class=\"h5\"> Apa yang bisa menjadi rumit? </h3>\n<p> Sejauh ini semuanya seharusnya berhasil. Saatnya untuk mulai menjelaskan hasil Anda sebelumnya ketika ada hal-hal yang tidak berhasil. </p>\n<p> Penting: </p> <pre><code>killall nc\n</code></pre> <p> Siapkan <code>nc</code> &quot;mendengarkan&quot;: </p> <pre><code>nc -ul 6900\n</code></pre> <p> Periksa <code>lsof -i :6900</code>. Outputnya akan seperti: </p> <pre><code>… UDP *:6900\n</code></pre> <p> Siapkan &quot;menghubungkan&quot; <code>nc</code>: </p> <pre><code>nc -u localhost 6900\n</code></pre> <p> Periksa <code>lsof -i :6900</code>. Contoh keluaran (<code>54766</code> Anda mungkin berbeda): </p> <pre><code>… UDP *:6900\n… UDP localhost:54766-&gt;localhost:6900\n</code></pre> <p> Meneruskan beberapa data dari <pre><code>nc -uvp 54766 localhost 6900\n</code></pre> kedua ke yang pertama. Periksa <code>lsof -i :6900</code>: </p> <pre><code>… UDP localhost:6900-&gt;localhost:54766\n… UDP localhost:54766-&gt;localhost:6900\n</code></pre> <p> Hentikan <code>nc</code> kedua dengan <kbd> Ctrl </kbd> + <kbd> C </kbd> . Sekali lagi <code>lsof -i :6900</code>: </p> <pre><code>… UDP localhost:6900-&gt;localhost:54766\n</code></pre> <p> Ini berarti <code>lsof -i :6900</code> pertama &quot;berbicara&quot; hanya ke port <code>54766</code> di ujung lain &quot;koneksi&quot;. Saat Anda mencoba menyambungkan dengan <code>nc</code> ketiga: </p> <pre><code>nc -u localhost 6900\n</code></pre> <p> Kemungkinan besar akan memilih port acak yang berbeda di sisinya. Cobalah. Anda akan dapat &quot;melewati&quot; (sekitar) dua baris, seperti yang Anda lakukan dalam pertanyaan Anda, sebelum <code>nc</code> ini berakhir. </p>\n<p> (Catatan: <code>nc</code> ini berakhir karena paket ICMP, lihat <a href=\"https://serverfault.com/a/219007\" target=\"_blank\" rel=\"nofollow noopener\"> ini </a> ; Anda dapat menangkap paket dengan <code>wireshark</code> seperti yang saya lakukan.) </p>\n<p> Namun Anda dapat memaksa port yang tepat (ubah <code>54766</code> agar sesuai dengan output <code>lsof</code> Anda): </p> <pre><code>nc -up 54766 localhost 6900\n</code></pre> <p> dan <code>nc</code> keempat ini akan dapat mengirimkan data! <code>nc</code> pertama tidak akan melihat perbedaannya. Seolah-olah <code>nc</code> kedua tidak pernah diakhiri. </p>\n<p> Hentikan <code>nc</code> keempat sebelum Anda melanjutkan. Biarkan yang pertama berjalan. </p>\n<hr>\n<h3 class=\"h5\"> Opsi <code>-v</code> </h3>\n<p> Misteri terakhir adalah: mengapa <code>nc -v -u localhost 6900</code> segera keluar? </p>\n<p> Dalam contoh di atas kami memiliki empat <code>nc</code>: </p>\n<ol>\n<li><em> pertama </em> - &quot;mendengarkan&quot; satu; </li>\n<li><em> kedua </em> - berhasil terhubung, lalu diakhiri; </li>\n<li><em> ketiga </em> - tidak dapat terhubung karena port lokal yang salah; </li>\n<li><em> yang ke empat </em> - Dapat terhubung berkat port lokal yang benar (paksa). </li>\n</ol>\n<p> Di Kubuntu <code>nc -uv …</code> saya, jika itu <em> kedua </em> satu, mentransmisikan beberapa <code>X</code> karakter, mungkin untuk menyelidiki koneksi. Untuk alasan ini, jika memang begitu <em> ketiga </em> satu, tidak perlu (sekitar) dua baris masukan eksternal untuk gagal, ia langsung gagal. Memiliki <em> pertama </em> <code>nc</code> masih berjalan, coba: </p> <pre><code>nc -uv localhost 6900\n</code></pre> <p> Ini harus gagal. Sekali lagi, Anda dapat memaksa port yang tepat dan itu akan berfungsi seperti <em> yang ke empat </em> <code>nc</code> pada contoh di atas. </p> <pre><code>nc -uvp 54766 localhost 6900\n</code></pre> <p> Ketika saya menjalankan ini, saya dapat melihat <code>X</code>-s tercetak di konsol <em> pertama </em> <code>nc</code>. </p>\n<hr>\n<h3 class=\"h5\"> Pembersihan </h3> <pre><code>killall nc\n</code></pre> <hr>\n<h3 class=\"h5\"> Kesimpulan </h3>\n<p> Sepertinya Anda memiliki (&quot;mendengarkan&quot;) <code>nc</code> yang sudah dikaitkan dengan port tertentu di sisi lain &quot;koneksi&quot;, pasti karena <code>nc</code> lain (atau sesuatu yang lain) yang telah berhasil mengirimkan setidaknya satu paket . <code>nc</code> Anda yang lain mencoba menggunakan port lain di sisinya dan tidak dapat berkomunikasi dengan yang pertama ini. </p>\n<blockquote>\n<p> Jika saya mengganti <code>localhost</code> dengan <code>127.0.0.1</code>, ada kemajuan </p>\n</blockquote>\n<p> Tidak relevan. Saya kira dalam kasus ini Anda baru mulai bersih, seperti yang kami lakukan setelah <code>killall nc</code>. </p>","votes":"4","source":"https://superuser.com/a/1238093","author":"<a href=\"https://superuser.com/users/432690/kamil-maciorowski\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Kamil Maciorowski</span></a>","replies":[{"reply":"Jawaban ini memberikan detail yang sangat bagus dan saya bisa mengikutinya sepanjang waktu; Namun, saya perlu mengubah banyak dari <code>nc</code> perintah untuk menentukan tambahan <code>-4</code> per jawaban Daniel.","author":"<a href=\"https://superuser.com/users/315584/jia103\" target=\"_blank\" rel=\"nofollow noopener\">jia103</a>"}]}]}
