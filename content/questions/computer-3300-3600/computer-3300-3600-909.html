{"title":"Jalankan perintah di antara baris bash pipeâ€¦?","draft":false,"url":"/jalankan-perintah-di-antara-baris-bash-pipe-8rrthbpt","votes":"4","answers_count":"3","categories":["Komputer"],"tags":["linux","command-line","bash","pipe"],"snippet":"Saya ingin menjalankan serangkaian perintah yang melakukan banyak pemrosesan audio. Ini terlihat sebagai berikut dalam pseudocode:  command1 | command2 | command3  Dari command2 dan command3, keduanya mengambil output dari perintah sebelumnya sebagai...","body":"<p> Saya ingin menjalankan serangkaian perintah yang melakukan banyak pemrosesan audio. Ini terlihat sebagai berikut dalam pseudocode: </p> <pre><code>command1 | command2 | command3\n</code></pre> <p> Dari command2 dan command3, keduanya mengambil output dari perintah sebelumnya sebagai input (perilaku stdin / stdout biasa). </p>\n\n<p> Sekarang saya ingin menjalankan command1.1 lain tepat setelah command1, yang sama sekali tidak terhubung ke pipa yang sedang berjalan antara command1 dan command2, kecuali perintah itu tidak boleh dijalankan sebelum command1 selesai sepenuhnya. </p> <pre><code>command1 [; after that run command1.1, even if command2 and command3 are still busy] command2 command3\n</code></pre> <p> Namun saya tidak tahu bagaimana melakukan ini dalam pesta. Saya sudah mencoba tee, tetapi itu membuat perintah dijalankan segera setelah pipa dibuat. Ada ide? </p>\n\n<p> Terima kasih! </p>","source":"https://superuser.com/questions/866335/execute-command-in-between-a-bash-pipe-row","author":"<a href=\"https://superuser.com/users/409812/cunei\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">cunei</span></a>","replies":[],"answers":[{"answer":"<p> Anda dapat mengarahkannya ke subkulit. </p> <pre><code>command1 &amp; &gt; &gt;(command2 | command3) &amp;\nwait $!      # Wait end of process $! (actually the pid of command1)\ncommand_1.1     \n</code></pre> <p> Cara lain adalah dengan membuat pipa bernama <a href=\"http://linux.die.net/man/3/mkfifo\" rel=\"nofollow noopener\" target=\"_blank\"> fifo </a> . <br> Sebuah skrip harus serupa dengan </p> <pre><code>MYFIFO=/tmp/myfifo.$$\nrm -f $MYFIFO\nmkfifo $MYFIFO\ncommand1 &gt; $MYFIFO &amp;\nMYPROGRAM_PID=$!\ncat $MYFIFO  | command2 | command3 &amp;\nwait $MYPROGRAM_PID   # Wait end of process $MYPROGRAM_PID\ncommand_1.1     \n</code></pre>","votes":"4","source":"https://superuser.com/a/866350","author":"<a href=\"https://superuser.com/users/257269/hastur\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Hastur</span></a>","replies":[]},{"answer":"<p> Bagian penting tentang ini adalah &quot;setelah itu&quot; - satu-satunya konsep pipa UNIX yang memiliki &quot;setelah itu&quot; adalah, bahwa pipa biasanya ditutup, tetapi akan dijalankan setelah perintah pertama <strong> dimulai </strong> , bukan setelah ist <strong> berakhir </strong> . </p>\n\n<p> Jadi yang perlu Anda lakukan adalah menggunakan skrip shell - sesuatu yang memiliki konsep &quot;satu demi satu&quot;: </p> <pre><code>echo 'command1' &gt; myscript.sh\necho 'command1.1 &gt;&amp;2' &gt;&gt; myscript.sh\nchmod 755 myscript.sh\n</code></pre> <p> (Tentu saja Anda dapat menggunakan editor favorit Anda untuk mencapainya), lalu jalankan </p> <pre><code>myscript.sh | command2 | command3\n</code></pre> <p> Apa yang sekarang terjadi adalah, bahwa keluaran dari <code>command1</code> akan menjadi keluaran dari skrip shell, sehingga pipa Anda berfungsi. Di dalam skrip Anda, output <code>command1.1</code> akan diarahkan ke STDERR skrip, jadi tidak dikirim ke pipa, tetapi ke terminal </p>","votes":"4","source":"https://superuser.com/a/866345","author":"<a href=\"https://superuser.com/users/300968/eugen-rieck\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">Eugen Rieck</span></a>","replies":[{"reply":"Eugen, gema kedua harus <code>echo &#39;command1.1 &gt;&amp;2&#39; &gt;&gt; myscript.sh</code>","author":"<a href=\"https://superuser.com/users/409497/romeo-ninov\" target=\"_blank\" rel=\"nofollow noopener\">Romeo Ninov</a>"},{"reply":"Mungkin lebih baik <code>.&#47;myscript.sh</code> dari <code>myscript.sh</code>; biasanya direktori saat ini tidak disertakan dalam jalur karena alasan keamanan ...","author":"<a href=\"https://superuser.com/users/257269/hastur\" target=\"_blank\" rel=\"nofollow noopener\">Hastur</a>"},{"reply":"@Hastur Saya meninggalkan semua jalur - dari OQ saya berasumsi, poster itu tahu jalannya","author":"<a href=\"https://superuser.com/users/300968/eugen-rieck\" target=\"_blank\" rel=\"nofollow noopener\">Eugen Rieck</a>"},{"reply":"@EugenRieck Saya setuju, itu bukan untuk Anda atau cunei. Kami semua berharap bahwa jawabannya dapat bermanfaat bagi pembaca lain juga :-) dan, mungkin, salah satu dari mereka dapat melewatkan pada pandangan pertama perbedaan antara perintah yang ada di suatu tempat di <code>PATH</code> dan skrip itu, bahkan jika <i> dapat dieksekusi </i> (<code>chmod 755</code>) dalam direktori saat ini, secara default tidak aktif dari <code>PATH</code>.","author":"<a href=\"https://superuser.com/users/257269/hastur\" target=\"_blank\" rel=\"nofollow noopener\">Hastur</a>"}]},{"answer":"<p> Konstruksi paling sederhana adalah: </p> <pre><code>(command1 ; command1.1) | command2 | command3\n</code></pre> <p> Ada dua masalah potensial dengan ini. Jika <code>command1.1</code> menghasilkan keluaran apapun pada stdout, itu akan dikirim melalui pipa. Selain itu, <code>command2</code> tidak akan melihat EOF pada stdin hingga <code>command1.1</code> selesai. </p>\n\n<p> Jika pipeline awalnya dipanggil dalam konteks di mana deskriptor file stdout dan stderr mengarah ke struct file yang sama, maka ada cara sederhana untuk memperbaiki kedua masalah tersebut: </p> <pre><code>(command1 ; exec 1&gt;&amp;2 command1.1) | command2 | command3\n</code></pre> <p> Ini akan menyebabkan stdout dari command1.1 mengarah ke stderr, yang tidak dialihkan oleh pipa. </p>\n\n<p> Jika awalnya stdout dan stderr mungkin merupakan dua deskriptor file yang berbeda, pendekatan di atas dapat digunakan dengan menyembunyikan sementara stdout awal di nomor deskriptor file lain. Jadi, kecuali Anda benar-benar perlu memisahkan stdout dan stderr dari <code>command1.1</code>, saya tidak akan mengambil pendekatan itu. </p>\n\n<p> Untuk kelengkapannya, jika ingin melakukan itu bisa terlihat seperti ini: </p> <pre><code>(((exec 9&gt;&amp;- command1) ; exec 1&gt;&amp;9 9&gt;&amp;- command1.1) | exec 9&gt;&amp;- command2 | exec 9&gt;&amp;- command3) 9&gt;&amp;1\n</code></pre>","votes":"2","source":"https://superuser.com/a/866376","author":"<a href=\"https://superuser.com/users/326546/kasperd\" target=\"_blank\" rel=\"nofollow noopener\"><span itemprop=\"name\">kasperd</span></a>","replies":[]}]}
